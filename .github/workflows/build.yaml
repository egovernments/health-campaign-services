name: Build Pipeline
run-name: Build ${{ github.event.inputs.pipeline_name }}

on:
  workflow_dispatch:
    inputs:
      pipeline_name:
        description: 'Name of the config pipeline to build and deploy'
        required: true
        type: choice
        options:
          - health-services-common
          - health-services-models
          - product-17
          - product
          - project
          - health-project
          - referralmanagement
          - household
          - household-java-17
          - health-project-java-17
          - project-java-17
          - referralmanagement-java-17
          - individual
          - individual-java-17
          - health-individual
          - health-individual-java-17
          - health-attendance
          - error-handler
          - dashboard-analytics
          - stock
          - stock-java-17
          - egov-survey-services
          - facility
          - facility-java-17
          - transformer
          - transformer-java-17
          - health-service-request
          - service-request
          - health-service-request-17
          - service-request-17
          - pgr-services
          - health-pgr-services
          - pgr-services-17
          - health-pgr-services-17
          - user-otp
          - egov-notification-mail
          - attendance
          - health-hrms
          - health-hrms-java-17
          - egov-hrms
          - egov-hrms-java-17
          - plan-service
          - resource-generator
          - auth-proxy
          - census-service
          - geopode-adapter
          - beneficiary-idgen-17
          - workbench-ui
          - microplan-ui
          - project-factory

env:
  DOCKER_USERNAME: ${{ vars.DOCKER_USERNAME }}
  DOCKER_PASSWORD: ${{ secrets.DOCKER_ACCESS_TOKEN }}

jobs:
  resolve-config:
    name: Resolve ${{ github.event.inputs.pipeline_name }} config
    runs-on: ubuntu-latest
    outputs:
      service_work_dir:   ${{ steps.setenv.outputs.SERVICE_WORK_DIR }}
      service_image_name: ${{ steps.setenv.outputs.SERVICE_IMAGE_NAME }}
      service_dockerfile: ${{ steps.setenv.outputs.SERVICE_DOCKERFILE }}
      db_folder_exists:   ${{ steps.check-db-folder.outputs.folder_exists }}
      db_work_dir:        ${{ steps.setenv.outputs.DB_WORK_DIR }}
      db_image_name:      ${{ steps.setenv.outputs.DB_IMAGE_NAME }}
      db_dockerfile:      ${{ steps.setenv.outputs.DB_DOCKERFILE }}
      tag:                ${{ steps.tag.outputs.tag }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Install yq
        run: |
          VERSION="4.30.8"
          URL="https://github.com/mikefarah/yq/releases/download/v${VERSION}/yq_linux_amd64"
          sudo curl -sSL "$URL" -o /usr/local/bin/yq
          sudo chmod +x /usr/local/bin/yq

      - name: Resolve env from build-config.yml
        id: setenv
        run: |
          PIPELINE_NAME="${{ github.event.inputs.pipeline_name }}"
          DEFAULT_DOCKERFILE="Dockerfile"
          echo "### Pipeline Name - $PIPELINE_NAME" >> $GITHUB_STEP_SUMMARY
          
          # Step 1: List matching config blocks
          MATCHING_CONFIGS=$(yq eval -o=json '.config[] | select(.name | test("/'"$PIPELINE_NAME"'$"))' build/build-config.yml)
          
          # Step 2: Show matched config(s)
          echo "Matching config(s) for pipeline '$PIPELINE_NAME':"
          echo "$MATCHING_CONFIGS" | yq eval -P -  # pretty-print for readability
          
          # Step 3: Check count of matching configs
          MATCH_COUNT=$(echo "$MATCHING_CONFIGS" | yq eval -o=json '.' - | jq -s 'length')
          
          if [ "$MATCH_COUNT" -ne 1 ]; then
            echo "ERROR: Expected exactly 1 matching pipeline config, but found $MATCH_COUNT"
            exit 1
          fi
          
          # Step 4: Extract service build config (image-name not ending with -db)
          SERVICE_BUILD_CONFIG=$(yq eval -o=json '
            .config[]
            | select(.name | test("/'"$PIPELINE_NAME"'$"))
            | .build[]
            | select(.["image-name"] | test("-db$") | not)
            ' build/build-config.yml)
          
          # Step 5: Extract db build config (image-name ending with -db)
          DB_BUILD_CONFIG=$(yq eval -o=json '
            .config[]
            | select(.name | test("/'"$PIPELINE_NAME"'$"))
            | .build[]
            | select(.["image-name"] | test("-db$"))
            ' build/build-config.yml)
          
          # Step 6: Print for confirmation
          echo "SERVICE_BUILD_CONFIG: $SERVICE_BUILD_CONFIG"
          echo "DB_BUILD_CONFIG: $DB_BUILD_CONFIG"
          
          # Step 7: Extract Required Environment Variables
          SERVICE_DOCKERFILE=$(echo "$SERVICE_BUILD_CONFIG" | yq eval -r '.dockerfile // ""' -)
          SERVICE_IMAGE_NAME=$(echo "$SERVICE_BUILD_CONFIG" | yq eval -r '.["image-name"] // ""' -)
          SERVICE_WORK_DIR=$(echo "$SERVICE_BUILD_CONFIG" | yq eval -r '.["work-dir"] // ""' -)
          
          DB_IMAGE_NAME=$(echo "$DB_BUILD_CONFIG" | yq eval -r '.["image-name"] // ""' -)
          DB_WORK_DIR=$(echo "$DB_BUILD_CONFIG" | yq eval -r '.["work-dir"] // ""' -)
          DB_DOCKERFILE=$(echo "$DB_BUILD_CONFIG" | yq eval -r '.["work-dir"] // ""' -)/Dockerfile
          
          # Step 8: Set Default Dockerfile if service dockerfile config is missing
          if [ -z "$SERVICE_DOCKERFILE" ]; then
            echo "No dockerfile entry found for \"$SERVICE\" in build-config.yml; using default"
            SERVICE_DOCKERFILE="$SERVICE_WORK_DIR/$DEFAULT_DOCKERFILE"
          fi
          
          # Step 9: Export to github environment
          echo "SERVICE_WORK_DIR=$SERVICE_WORK_DIR" >> "$GITHUB_OUTPUT"
          echo "SERVICE_IMAGE_NAME=$SERVICE_IMAGE_NAME" >> "$GITHUB_OUTPUT"
          echo "SERVICE_DOCKERFILE=$SERVICE_DOCKERFILE" >> "$GITHUB_OUTPUT"
          echo "DB_WORK_DIR=$DB_WORK_DIR" >> "$GITHUB_OUTPUT"
          echo "DB_IMAGE_NAME=$DB_IMAGE_NAME"  >> "$GITHUB_OUTPUT"
          echo "DB_DOCKERFILE=$DB_DOCKERFILE"  >> "$GITHUB_OUTPUT"
          missing_vars=()
          
          # Step 10: Check if required env variables exists
          for var in SERVICE_WORK_DIR SERVICE_IMAGE_NAME SERVICE_DOCKERFILE; do
            if [ -z "${!var}" ]; then
              echo "ERROR: $var is not set or is empty"
              missing_vars+=("$var")
            fi
          done
          
          if [ ${#missing_vars[@]} -gt 0 ]; then
            echo "Required environment variables are missing: ${missing_vars[*]}"
            exit 1  # Fail the step
          fi

          # Step 11. Put summary for the step
          echo "#### Application Config Summary" >> $GITHUB_STEP_SUMMARY
          echo "Application Work Directory - $SERVICE_WORK_DIR" >> $GITHUB_STEP_SUMMARY
          echo "Image Name - $SERVICE_IMAGE_NAME" >> $GITHUB_STEP_SUMMARY
          echo "Dockerfile Path - $SERVICE_DOCKERFILE" >> $GITHUB_STEP_SUMMARY
          
          echo "#### DB Config Summary" >> $GITHUB_STEP_SUMMARY
          echo "Application Work Directory - $DB_WORK_DIR" >> $GITHUB_STEP_SUMMARY
          echo "Image Name - $DB_IMAGE_NAME" >> $GITHUB_STEP_SUMMARY
          echo "Dockerfile Path - $SERVICE_DOCKERFILE" >> $GITHUB_STEP_SUMMARY

      - name: Check if DB folder exists
        id: check-db-folder
        run: |
          FOLDER_PATH="${{ steps.setenv.outputs.DB_WORK_DIR }}"
          if [ -d "$FOLDER_PATH" ]; then
            echo "folder_exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "folder_exists=false" >> "$GITHUB_OUTPUT"
          fi
      - name: Generate the Next Tag
        id: tag
        run: |
          set -euxo pipefail
          BRANCH="${GITHUB_REF##*/}"
          COMMIT_HASH=$(git rev-parse --short HEAD)
          SERVICE_NAME="${{ steps.setenv.outputs.SERVICE_IMAGE_NAME }}"

          TOKEN=$(curl -s -X POST "https://hub.docker.com/v2/users/login/" \
            -H "Content-Type: application/json" \
            -d "{\"username\": \"$DOCKER_USERNAME\", \"password\": \"$DOCKER_PASSWORD\"}" \
            | jq -r .token)

          if [ -z "$TOKEN" ]; then
            echo "Failed to authenticate with Docker Hub." >&2
            exit 1
          fi

          # Check if repo exists
          HTTP_CODE=$(curl -s -o /dev/null -w '%{http_code}' \
            -H "Authorization: JWT $TOKEN" \
            "https://hub.docker.com/v2/repositories/$DOCKER_USERNAME/$SERVICE_NAME/")

          if [ "$HTTP_CODE" -ne 200 ]; then
            NEXT_TAG="${BRANCH}-${COMMIT_HASH}"
          else
            EXISTING_TAGS=$(curl -s -H "Authorization: JWT $TOKEN" \
              "https://hub.docker.com/v2/repositories/$DOCKER_USERNAME/$SERVICE_NAME/tags?page_size=100" \
              | jq -r '.results[].name')
            LATEST_TAG=$(echo "$EXISTING_TAGS" \
              | grep "^${BRANCH}-${COMMIT_HASH}" || true \
              | sort -V \
              | tail -n 1)
            NEXT_TAG="${LATEST_TAG:-${BRANCH}-${COMMIT_HASH}}"
          fi

          echo "tag=$NEXT_TAG" >> "$GITHUB_OUTPUT"
          echo "NEXT_TAG=$NEXT_TAG" >> "$GITHUB_ENV"
          echo "tag - $NEXT_TAG" >> $GITHUB_STEP_SUMMARY

  build-application:
    name: Build Application Multi Arch
    needs: resolve-config
    uses: ./.github/workflows/build_multiarch_reuse.yml
    with:
      key_name: ${{ github.event.inputs.pipeline_name }}
      image_name: ${{ needs.resolve-config.outputs.service_image_name }}
      dockerfile: ${{ needs.resolve-config.outputs.service_dockerfile }}
      work_dir: ${{ needs.resolve-config.outputs.service_work_dir }}
      tag: ${{ needs.resolve-config.outputs.tag }}
      context: .
    secrets:
      DOCKER_USERNAME: ${{ vars.DOCKER_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.DOCKER_ACCESS_TOKEN }}

  build-application-db:
    name: Build Application DB Multi Arch
    needs: resolve-config
    if: ${{ needs.resolve-config.outputs.db_folder_exists == 'true' }}
    uses: ./.github/workflows/build_multiarch_reuse.yml
    with:
      key_name: ${{ github.event.inputs.pipeline_name }}-db
      image_name: ${{ needs.resolve-config.outputs.db_image_name }}
      dockerfile: ${{ needs.resolve-config.outputs.db_dockerfile }}
      work_dir: ${{ needs.resolve-config.outputs.db_work_dir }}
      tag: ${{ needs.resolve-config.outputs.tag }}
      context: ${{ needs.resolve-config.outputs.db_work_dir }}
    secrets:
      DOCKER_USERNAME: ${{ vars.DOCKER_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.DOCKER_ACCESS_TOKEN }}

  build-application-summary:
    name: Application Build Summary
    needs: build-application
    runs-on: ubuntu-latest
    steps:
      - name: Publish build summary
        run: |
          echo "### Application Docker Image:" >> $GITHUB_OUTPUT
          echo "${{ needs.build-application.outputs.final_image }}" >> $GITHUB_OUTPUT

  build-application-summary-db:
    name: DB Build Summary
    if: ${{ needs.resolve-config.outputs.db_folder_exists == 'true' }}
    needs: build-application-db
    runs-on: ubuntu-latest
    steps:
      - name: Publish build summary
        run: |
          echo "### DB Docker Image:" >> $GITHUB_OUTPUT
          echo "${{ needs.build-application-db.outputs.final_image }}" >> $GITHUB_OUTPUT