import { getExcelWorkbookFromFileURL,getNewExcelWorkbook ,addDataToSheet} from "../utils/excelUtils";
import config from "../config";
import { httpRequest } from "./request";
import { logger } from "./logger";
import { throwError,getLocalizedHeaders,createHeaderToHierarchyMap,
  modifyBoundaryDataHeadersWithMap,modifyBoundaryData,findMapValue,extractFrenchOrPortugeseLocalizationMap,replicateRequest,callGenerate , checkForMixedBoundaryFlowInArrays}
 from "../utils/genericUtils";
import { searchBoundaryRelationshipDefinition  } from "../api/coreApis";
import { BoundaryModels } from "../models";
import { getSheetData ,getAutoGeneratedBoundaryCodesHandler,createBoundaryEntities
  ,createBoundaryRelationship,createExcelSheet,createAndUploadFile
} from "../api/genericApis";
import{validateBoundarySheetDataInCreateFlow} from "../validators/boundaryValidators";
import { transformAndCreateLocalisation } from "./transforms/localisationMessageConstructor";
import {genericResourceTransformer} from "./transforms/searchResponseConstructor";
import {handleResouceDetailsError} from "../api/boundaryApis";
import {resourceDataStatuses} from "../config/constants";
import {produceModifiedMessages} from "../kafka/Producer";
import {deleteRedisCacheKeysWithPrefix} from "./redisUtils";
import {getTableName,executeQuery} from "../utils/db";
const _ = require("lodash");



function getLocalizedName(
  expectedName: string,
  localizationMap?: { [key: string]: string }
) {
  if (!localizationMap || !(expectedName in localizationMap)) {
    return expectedName;
  }
  const localizedName = localizationMap[expectedName];
  return localizedName;
}
// Function to generate localisation module name based on hierarchy type
export const getBoundaryTabName = () => {
  // Construct Boundary tab name from the config
  return config?.boundary?.boundaryTab;
};

const getHeadersOfBoundarySheet = async (
  fileUrl: string,
  sheetName: string,
  getRow = false,
  localizationMap?: any
) => {
  const localizedBoundarySheetName = getLocalizedName(
    sheetName,
    localizationMap
  );
  const workbook: any = await getExcelWorkbookFromFileURL(
    fileUrl,
    localizedBoundarySheetName
  );

  const worksheet = workbook.getWorksheet(localizedBoundarySheetName);
  const columnsToValidate = worksheet
    .getRow(1)
    .values.map((header: any) =>
      header ? header.toString().trim() : undefined
    );

  // Filter out empty items and return the result
  return columnsToValidate.filter((header: any) => typeof header === "string");
};

const getHierarchy = async (
  tenantId: string,
  hierarchyType: string
) => {
  const BoundaryTypeHierarchySearchCriteria: BoundaryModels.BoundaryHierarchyDefinitionSearchCriteria =
  {
    BoundaryTypeHierarchySearchCriteria: {
      tenantId,
      hierarchyType,
    },
  };
  const response: BoundaryModels.BoundaryHierarchyDefinitionResponse =
    await searchBoundaryRelationshipDefinition(
      BoundaryTypeHierarchySearchCriteria
    );
  const boundaryList = response?.BoundaryHierarchy?.[0].boundaryHierarchy;
  return generateHierarchy(boundaryList);
};

function generateHierarchy(boundaries: any[]) {
  // Create an object to store boundary types and their parents
  const parentMap: any = {};

  // Populate the object with boundary types and their parents
  for (const boundary of boundaries) {
    parentMap[boundary.boundaryType] = boundary.parentBoundaryType;
  }

  // Traverse the hierarchy to generate the hierarchy list
  const hierarchyList = [];
  for (const boundaryType in parentMap) {
    if (Object.prototype.hasOwnProperty.call(parentMap, boundaryType)) {
      const parentBoundaryType = parentMap[boundaryType];
      if (parentBoundaryType === null) {
        // This boundary type has no parent, add it to the hierarchy list
        hierarchyList.push(boundaryType);
        // Traverse its children recursively
        traverseChildren(boundaryType, parentMap, hierarchyList);
      }
    }
  }
  return hierarchyList;
}
function traverseChildren(parent: any, parentMap: any, hierarchyList: any[]) {
  for (const boundaryType in parentMap) {
    if (Object.prototype.hasOwnProperty.call(parentMap, boundaryType)) {
      const parentBoundaryType = parentMap[boundaryType];
      if (parentBoundaryType === parent) {
        // This boundary type has the current parent, add it to the hierarchy list
        hierarchyList.push(boundaryType);
        // Traverse its children recursively
        traverseChildren(boundaryType, parentMap, hierarchyList);
      }
    }
  }
}

async function validateHeaders(hierarchy: any[], headersOfBoundarySheet: any, request: any, localizationMap?: any) {
    validateBoundarySheetHeaders(headersOfBoundarySheet, hierarchy, request, localizationMap);
}


function validateBoundarySheetHeaders(headersOfBoundarySheet: any[], hierarchy: any[], request: any, localizationMap?: any) {
    const localizedBoundaryCode = getLocalizedName(getBoundaryColumnName(), localizationMap)
    const boundaryCodeIndex = headersOfBoundarySheet.indexOf(localizedBoundaryCode);
    const keysBeforeBoundaryCode = boundaryCodeIndex === -1 ? headersOfBoundarySheet : headersOfBoundarySheet.slice(0, boundaryCodeIndex);
    if (keysBeforeBoundaryCode.some((key: any, index: any) => (key === undefined || key === null) || key !== hierarchy[index]) || keysBeforeBoundaryCode.length !== hierarchy.length) {
        const errorMessage = `"Boundary Sheet Headers are not the same as the hierarchy present for the given tenant and hierarchy type: ${request?.body?.ResourceDetails?.hierarchyType}"`;
        throwError("BOUNDARY", 400, "BOUNDARY_SHEET_HEADER_ERROR", errorMessage);
    }
}

export const getBoundaryColumnName = () => {
  // Construct Boundary column name from the config
  return config?.boundary?.boundaryCode;
};

async function boundaryBulkUpload(request: any, localizationMap?: any) {
  try {
    logger.info("Boundary Relationship Creation Starts");
    await autoGenerateBoundaryCodes(request, localizationMap);
    await generateProcessedFileAndPersist(request);
  } catch (error: any) {
    console.log(error);
    await handleResouceDetailsError(request, error);
  }
}

/**
 * Handler function for manual boundary codes flow (parallel to getAutoGeneratedBoundaryCodesHandler)
 * Creates boundary map from user-provided codes without generating new ones
 * @param withBoundaryCode - Array of boundaries that already exist with codes (processed boundaries)
 * @param manualBoundaryCode - Array of boundaries with user-provided codes
 * @param hierarchy - Hierarchy array
 * @param localizationMap - Localization map
 * @returns Map of boundary names to their codes
 */
async function getManualBoundaryCodesHandler(
  withBoundaryCode: any[],
  manualBoundaryCode: any[],
  hierarchy: any[],
  localizationMap?: any
): Promise<Map<{ key: string; value: string }, string>> {
  try {
    logger.info("Manual boundary code flow - Creating boundary map from user-provided codes");
    const boundaryMap = new Map<{ key: string; value: string }, string>();
    const boundaryCodeKey = getLocalizedName(config?.boundary?.boundaryCode, localizationMap);

    // Track all boundaries at each hierarchy level that need codes
    const boundariesNeedingCodes = new Map<string, Set<string>>(); // level -> Set of boundary names
    const boundariesWithCodes = new Map<string, Map<string, string>>(); // level -> (boundary name -> code)

    // First, extract existing boundaries and their codes from withBoundaryCode (already processed boundaries)
    withBoundaryCode.forEach((row: any[]) => {
      const rowMap = new Map<string, any>();
      row.forEach((obj: any) => rowMap.set(obj.key, obj.value));

      // Find the boundary code in the row
      const boundaryCodeValue = rowMap.get(boundaryCodeKey);
      if (!boundaryCodeValue) return;

      // Find the last present hierarchy index
      let lastPresentHierarchyIndex = -1;
      for (let i = 0; i < hierarchy.length; i++) {
        const level = hierarchy[i];
        const value = rowMap.get(level);
        if (value && value.toString().trim()) {
          lastPresentHierarchyIndex = i;
        }
      }

      // Store the code for the boundary at the last level
      if (lastPresentHierarchyIndex >= 0) {
        const level = hierarchy[lastPresentHierarchyIndex];
        const boundaryName = rowMap.get(level)?.toString().trim();
        if (boundaryName) {
          if (!boundariesWithCodes.has(level)) {
            boundariesWithCodes.set(level, new Map<string, string>());
          }
          boundariesWithCodes.get(level)?.set(boundaryName, boundaryCodeValue.toString().trim());
        }
      }
    });

    // Initialize tracking maps for each hierarchy level (if not already initialized from withBoundaryCode)
    hierarchy.forEach((level: string) => {
      if (!boundariesNeedingCodes.has(level)) {
        boundariesNeedingCodes.set(level, new Set<string>());
      }
      if (!boundariesWithCodes.has(level)) {
        boundariesWithCodes.set(level, new Map<string, string>());
      }
    });

    // Second pass: Process manualBoundaryCode - Collect all boundaries at each level and identify which ones have codes
    manualBoundaryCode.forEach((row: any[], rowIndex: number) => {
      // Find the boundary code in the row
      const boundaryCodeObj = row.find((obj: any) => obj.key === boundaryCodeKey);
      if (!boundaryCodeObj || !boundaryCodeObj.value || !boundaryCodeObj.value.toString().trim()) {
        throwError(
          "BOUNDARY",
          400,
          "MISSING_BOUNDARY_CODE",
          `Manual flow requires all boundaries to have service codes. Missing or empty code at row ${rowIndex + 2}.`
        );
      }

      const boundaryCode = boundaryCodeObj.value.toString().trim();

      // Find all hierarchy levels present in this row
      const rowMap = new Map<string, any>();
      row.forEach((obj: any) => rowMap.set(obj.key, obj.value));

      // Find the last present hierarchy index
      let lastPresentHierarchyIndex = -1;
      for (let i = 0; i < hierarchy.length; i++) {
        const level = hierarchy[i];
        const value = rowMap.get(level);
        if (value && value.toString().trim()) {
          lastPresentHierarchyIndex = i;
        }
      }

      // Process all hierarchy levels up to the last present one
      for (let i = 0; i <= lastPresentHierarchyIndex; i++) {
        const level = hierarchy[i];
        const boundaryObj = row.find((obj: any) => obj.key === level);

        if (boundaryObj && boundaryObj.value && boundaryObj.value.toString().trim()) {
          const boundaryName = boundaryObj.value.toString().trim();

          // Add to tracking: this boundary needs a code
          boundariesNeedingCodes.get(level)?.add(boundaryName);

          // If this is the last level in this row, it has the code
          if (i === lastPresentHierarchyIndex) {
            boundariesWithCodes.get(level)?.set(boundaryName, boundaryCode);
            // Add to final boundary map
            boundaryMap.set(boundaryObj, boundaryCode);
          }
        }
      }
    });

    // Third pass: Validate that all boundaries have codes (checking both withBoundaryCode and manualBoundaryCode)
    const missingCodes: string[] = [];
    hierarchy.forEach((level: string) => {
      const neededBoundaries = boundariesNeedingCodes.get(level);
      const boundariesWithCodesAtLevel = boundariesWithCodes.get(level);

      neededBoundaries?.forEach((boundaryName: string) => {
        if (!boundariesWithCodesAtLevel?.has(boundaryName)) {
          missingCodes.push(`${level}: "${boundaryName}"`);
        }
      });
    });

    // If any boundaries are missing codes, throw error
    if (missingCodes.length > 0) {
      const missingList = missingCodes.join(", ");
      throwError(
        "BOUNDARY",
        400,
        "MISSING_PARENT_BOUNDARY_CODE",
        `You have not entered the service code for the following boundaries: ${missingList}. In manual flow, all parent/intermediate boundaries must have service codes.`
      );
    }

    logger.info(`Manual boundary code flow - Created boundary map with ${boundaryMap.size} entries`);
    return boundaryMap;
  } catch (error: any) {
    logger.error("Error in getManualBoundaryCodesHandler:", error);
    throw error;
  }
}

const autoGenerateBoundaryCodes = async (
  request: any,
  localizationMap?: any
) => {
  const { hierarchyType, tenantId } = request?.body?.ResourceDetails || {};
  const hierarchy =
    (await getHierarchy(tenantId, hierarchyType)) || [];
  const headersOfBoundarySheet = hierarchy.map(
    (e) => `${hierarchyType.toUpperCase()}_${e.toUpperCase()}`
  );
  const localizedHeadersOfBoundarySheet = getLocalizedHeaders(
    headersOfBoundarySheet,
    localizationMap
  );
  const type = "boundaryManagement";
  const fileResponse = await httpRequest(
    config.host.filestore + config.paths.filestore + "/url",
    {},
    { tenantId, fileStoreIds: request?.body?.ResourceDetails?.fileStoreId },
    "get"
  );
  const localizedBoundaryTab = getLocalizedName(
    getBoundaryTabName(),
    localizationMap
  );
  var boundaryData = await getSheetData(
    fileResponse?.fileStoreIds?.[0]?.url,
    localizedBoundaryTab,
    false,
    undefined,
    localizationMap
  );
  var latLongData: any;
  if (type === "boundaryManagement") {
    validateBoundarySheetDataInCreateFlow(
      boundaryData,
      localizedHeadersOfBoundarySheet
    );
    const result = updateBoundaryDataForBoundaryManagement(
      request,
      boundaryData,
      localizationMap
    );
    latLongData = result.latLongData;
    boundaryData = result.updatedData;
  }
  const updatedBoundaryData = updateBoundaryData(boundaryData, localizedHeadersOfBoundarySheet);
  const headerToHierarchyMap = createHeaderToHierarchyMap(localizedHeadersOfBoundarySheet, hierarchy);
  var modifiedBoundaryData = modifyBoundaryDataHeadersWithMap(updatedBoundaryData, headerToHierarchyMap);
  var manualServiceFlow = false;
  const [withBoundaryCode, withoutBoundaryCode, manualBoundaryCode] = await modifyBoundaryData(
    modifiedBoundaryData,
    localizationMap,
    request
  );
  logger.info(`Boundary data segregation complete - Processed: ${withBoundaryCode.length}, Auto-generate: ${withoutBoundaryCode.length}, Manual: ${manualBoundaryCode.length}`);
  manualServiceFlow = manualBoundaryCode.length > 0 ? true : false;

  checkForMixedBoundaryFlowInArrays(withoutBoundaryCode, manualBoundaryCode);

  let boundaryMap: Map<{ key: string; value: string }, string>;

  if (manualServiceFlow) {
    // Manual flow: Use user-provided boundary codes
    logger.info("Using manual boundary code flow");
    boundaryMap = await getManualBoundaryCodesHandler(
      withBoundaryCode,
      manualBoundaryCode,
      hierarchy,
      localizationMap
    );

    // IMPORTANT: Add already processed boundary codes to the boundaryMap
    // This is crucial for parent-child relationship mapping when new boundaries
    // reference already processed parent boundaries
    const boundaryCodeKey = getLocalizedName(config?.boundary?.boundaryCode, localizationMap);
    withBoundaryCode.forEach((row: any[]) => {
      // Find the last hierarchy level in this row (the boundary that has the code)
      let lastBoundaryObj = null;
      for (let i = hierarchy.length - 1; i >= 0; i--) {
        const hierarchyLevel = hierarchy[i];
        const boundaryObj = row.find((obj: any) => obj.key === hierarchyLevel);
        if (boundaryObj && boundaryObj.value && boundaryObj.value.toString().trim()) {
          lastBoundaryObj = boundaryObj;
          break;
        }
      }

      // Extract the boundary code
      const boundaryCodeObj = row.find((obj: any) => obj.key === boundaryCodeKey);
      if (lastBoundaryObj && boundaryCodeObj && boundaryCodeObj.value) {
        const boundaryCode = boundaryCodeObj.value.toString().trim();
        // Add to boundaryMap if not already present
        const existingCode = findMapValue(boundaryMap, lastBoundaryObj);
        if (!existingCode) {
          boundaryMap.set(lastBoundaryObj, boundaryCode);
        }
      }
    });

    logger.info(`Manual Boundary Code Processing Completed - Total codes in map: ${boundaryMap.size}`);
  } else {
    // Auto-generation flow: Generate boundary codes
    logger.info("Using auto-generation boundary code flow");
    const { mappingMap, countMap } =
      getCodeMappingsOfExistingBoundaryCodes(withBoundaryCode, localizationMap);
    const childParentMap = getChildParentMap([
      ...withBoundaryCode,
      ...withoutBoundaryCode,
    ]);
    boundaryMap = await getAutoGeneratedBoundaryCodesHandler(
      withoutBoundaryCode,
      childParentMap,
      mappingMap,
      countMap,
      request,
      hierarchy
    );
    logger.info("Boundary Code Auto Generation Completed");
  }
  await createBoundaryEntities(request, boundaryMap);
  logger.info(
    "waiting for 2 secs to persist the boundary entities before creating boundary relationship"
  );
  await new Promise((resolve) => setTimeout(resolve, 2000));

  // Create child-parent map and relationships based on flow type
  let modifiedChildParentMap: Map<string, string | null>;
  if (manualServiceFlow) {
    // Manual flow: Create child-parent map from manual boundary codes
    const manualChildParentMap = getChildParentMap([
      ...withBoundaryCode,
      ...manualBoundaryCode,
    ]);
    modifiedChildParentMap = modifyChildParentMap(
      manualChildParentMap,
      boundaryMap
    );
  } else {
    // Auto-generation flow: Use existing child-parent map
    const childParentMap = getChildParentMap([
      ...withBoundaryCode,
      ...withoutBoundaryCode,
    ]);
    modifiedChildParentMap = modifyChildParentMap(
      childParentMap,
      boundaryMap
    );
  }

  await createBoundaryRelationship(
    request,
    boundaryMap,
    modifiedChildParentMap
  );

  // Prepare boundary data for sheet based on flow type
  let boundaryDataForSheet: any[];
  if (manualServiceFlow) {
    // Manual flow: Use manual boundary codes (they already have codes)
    boundaryDataForSheet = addBoundaryCodeToData(
      withBoundaryCode,
      manualBoundaryCode,
      boundaryMap,
      hierarchy,
      localizationMap
    );
  } else {
    // Auto-generation flow: Use without boundary codes (need to add generated codes)
    boundaryDataForSheet = addBoundaryCodeToData(
      withBoundaryCode,
      withoutBoundaryCode,
      boundaryMap,
      hierarchy,
      localizationMap
    );
  }
  logger.info(
    "Initiated the localisation message creation for the uploaded boundary"
  );
  const frenchLocalizationMap = extractFrenchOrPortugeseLocalizationMap(boundaryDataForSheet, true, false, localizationMap);
  const portugeseLocalizationMap = extractFrenchOrPortugeseLocalizationMap(boundaryDataForSheet, false, true, localizationMap);
  await transformAndCreateLocalisation(frenchLocalizationMap, request, true, false);
  await transformAndCreateLocalisation(portugeseLocalizationMap, request, false, true);
  await transformAndCreateLocalisation(boundaryMap, request, false, false);
  const modifiedHierarchy = hierarchy.map((ele) =>
    `${hierarchyType}_${ele}`.toUpperCase()
  );
  var headers = [...modifiedHierarchy, config?.boundary?.boundaryCode];
  const data = prepareDataForExcel(
    boundaryDataForSheet,
    hierarchy,
    boundaryMap,
    localizationMap
  );
  if (type === "boundaryManagement") {
    headers = [
      ...headers,
      getLocalizedName("HCM_ADMIN_CONSOLE_FRENCH_LOCALIZATION_MESSAGE", localizationMap),
      getLocalizedName("HCM_ADMIN_CONSOLE_FRENCH_LOCALIZATION_MESSAGE", localizationMap),
      getLocalizedName("HCM_ADMIN_CONSOLE_LAT", localizationMap),
      getLocalizedName("HCM_ADMIN_CONSOLE_LONG", localizationMap)
    ];
    data.forEach((row: any[], index: string | number) => {
      if (latLongData.length > index) {
        row.push(latLongData[index][0], latLongData[index][1]);
      }
    });
  }
  const localizedHeaders = getLocalizedHeaders(headers, localizationMap);
  const boundarySheetData: any = await createExcelSheet(data, localizedHeaders);
  const workbook = getNewExcelWorkbook();
  const boundarySheet = workbook.addWorksheet(localizedBoundaryTab);
  addDataToSheet(request, boundarySheet, boundarySheetData, "93C47D", 40, true);
  const boundaryFileDetails: any = await createAndUploadFile(workbook, request);
  request.body.ResourceDetails.processedFileStoreId =
    boundaryFileDetails?.[0]?.fileStoreId;
};

function modifyChildParentMap(
  childParentMap: Map<any, any>,
  boundaryMap: Map<any, any>
): Map<string, string | null> {
  const modifiedMap: Map<string, string | null> = new Map();

  // Iterate over each entry in childParentMap
  childParentMap.forEach((value, key) => {
    // Get the modified key and value from boundaryMap
    const modifiedKey = findMapValue(boundaryMap, key) || null;
    const modifiedValue = value ? findMapValue(boundaryMap, value) : null;

    // Set the modified key-value pair in modifiedMap
    modifiedMap.set(modifiedKey, modifiedValue);
  });

  return modifiedMap;
}

function extractCodesFromBoundaryRelationshipResponse(boundaries: any[]): any {
  const codes = new Set();
  for (const boundary of boundaries) {
    codes.add(boundary.code); // Add code to the Set
    if (boundary.children && boundary.children.length > 0) {
      const childCodes = extractCodesFromBoundaryRelationshipResponse(
        boundary.children
      ); // Recursively get child codes
      childCodes.forEach((code: any) => codes.add(code)); // Add child codes to the Set
    }
  }
  return codes;
}
async function generateProcessedFileAndPersist(
  request: any,
  localizationMap?: { [key: string]: string }
) {

  updateActivityResourceId(request);
  request.body.ResourceDetails = {
    ...request?.body?.ResourceDetails,
    status:
      request.body.ResourceDetails.status != resourceDataStatuses.invalid
        ? resourceDataStatuses.completed
        : resourceDataStatuses.invalid,
    auditDetails: {
      ...request?.body?.ResourceDetails?.auditDetails,
      lastModifiedBy: request?.body?.RequestInfo?.userInfo?.uuid,
      lastModifiedTime: Date.now(),
    },
    additionalDetails: {
      ...request?.body?.ResourceDetails?.additionalDetails,
      sheetErrors: request?.body?.additionalDetailsErrors,
      source: null
    },
  };
  if (
    request?.body?.ResourceDetails?.status === resourceDataStatuses.completed 
  ) {
    // delete redis cache key with prefix boundaryRelatiionshipSearch
    await deleteRedisCacheKeysWithPrefix("boundaryRelationShipSearch");

    logger.info(
      "calling generate after boundary data uploaded under type boundary management"
    );
    const newRequestBody = {
      RequestInfo: request?.body?.RequestInfo,
    };
    const params = {
      type: "boundaryManagement",
      tenantId: request?.body?.ResourceDetails?.tenantId,
      forceUpdate: "true",
      hierarchyType: request?.body?.ResourceDetails?.hierarchyType,
      referenceId : request?.query?.referenceId ? request.query.referenceId : null,
    };
    const newRequestBoundary = replicateRequest(
      request,
      newRequestBody,
      params
    );
    setTimeout(async () => {
      // Code to be executed after 10 seconds
      logger.info("Timeout of 30 sec after boundary data creation");
      await callGenerate(
        newRequestBoundary,
        "boundaryManagement",
      );
    }, 30000);
  }
  request.body.ResourceDetails.processedFileStoreId = request?.body?.ResourceDetails?.processedFileStoreId || null;
  request.body.ResourceDetails.referenceId = request?.body?.ResourceDetails?.referenceId || null;
  const persistMessage: any = { ResourceDetails: request.body.ResourceDetails };
  if (request?.body?.ResourceDetails?.action == "create") {
    persistMessage.ResourceDetails.additionalDetails = {
      source:null, 
      fileName:
        request?.body?.ResourceDetails?.additionalDetails?.fileName || null,
    };
  }
  await produceModifiedMessages(
    persistMessage,
    config?.kafka?.KAFKA_UPDATE_PROCESSED_BOUNDARY_MANAGEMENT_TOPIC,
    request?.body?.ResourceDetails?.tenantId
  );
  logger.info(
    `ResourceDetails to persist : ${request.body.ResourceDetails.hierarchyType}`
  );
}

function updateActivityResourceId(request: any) {
  if (request?.body?.Activities && Array.isArray(request?.body?.Activities)) {
    for (const activity of request?.body?.Activities) {
      activity.resourceDetailsId = request?.body?.ResourceDetails?.id;
    }
  }
}


function prepareDataForExcel(
  boundaryDataForSheet: any[],
  hierarchy: any[],
  boundaryMap: any,
  localizationMap: any
) {
  const boundaryKey = getLocalizedName(config?.boundary?.boundaryCode, localizationMap);

  const data = boundaryDataForSheet.map((row: any[]) => {
    const rowMap = new Map<string, any>();
    row.forEach(obj => rowMap.set(obj.key, obj.value));

    // 1. Pick hierarchy values in order
    const hierarchyValues = hierarchy.map(level => rowMap.get(level) || "");

    // 2. Get boundary code value
    const boundaryCode = rowMap.get(boundaryKey) || "";

    // 3. Get remaining key-value pairs (excluding hierarchy + boundaryKey)
    const excludedKeys = new Set([...hierarchy, boundaryKey]);
    const remainingValues = row
      .filter(obj => !excludedKeys.has(obj.key))
      .map(obj => obj.value || "");

    // 4. Final row structure: hierarchy values + boundary code + remaining key-value pairs
    return [...hierarchyValues, boundaryCode, ...remainingValues];
  });

  return data;
}

function updateBoundaryDataForBoundaryManagement(
  request: any,
  boundaryData: any[],
  localizationMap: any
): { updatedData: any[]; latLongData: [number, number][] } {
  const latLongData: [number, number][] = [];
  const latKey = getLocalizedName("HCM_ADMIN_CONSOLE_LAT", localizationMap);
  const longKey = getLocalizedName("HCM_ADMIN_CONSOLE_LONG", localizationMap);

  boundaryData.forEach((row) => {
    // Check if the row contains both latitude and longitude keys
    if (latKey in row && longKey in row) {
      // Push latitude and longitude to the latLongData array
      latLongData.push([row[latKey], row[longKey]]);

      // Remove the latitude and longitude from the original row
      delete row[latKey];
      delete row[longKey];
    }
  });

  // Return both the updated boundary data and latLongData
  return {
    updatedData: boundaryData,
    latLongData,
  };
}

function addBoundaryCodeToData(
  withBoundaryCode: any[],
  withoutBoundaryCode: any[],
  boundaryMap: Map<any, any>,
  hierarchy: any,
  localizationMap: any
) {
  const boundaryKey = getLocalizedName(config?.boundary?.boundaryCode, localizationMap);

  // Part 1: extract boundary codes directly
  // const modifiedBoundaryDataWithBoundaryCode = withBoundaryCode.map((array) => {
  //   return array.map((obj: any) => {
  //     if (obj.key === boundaryKey) {
  //       return obj.value; // replace with value (just the boundary code)
  //     } else {
  //       return obj;
  //     }
  //   });
  // });

  // Part 2: for rows without boundary code
  const boundaryDataForWithoutBoundaryCode = withoutBoundaryCode.map((row: any[]) => {
    let boundaryName: string | undefined;

    for (let level of hierarchy) {
      const match = row.find(obj => obj.key === level && obj.value);
      if (match) {
        boundaryName = match; // keep updating as we go down hierarchy
      }
    }

    const boundaryCode = findMapValue(boundaryMap, boundaryName);
    const boundaryCodeObj = { key: boundaryKey, value: boundaryCode };
    return [...row, boundaryCodeObj]; // just append the boundary code at the end
  });


  const boundaryDataForSheet = [
    ...withBoundaryCode,
    ...boundaryDataForWithoutBoundaryCode,
  ];

  return boundaryDataForSheet;
}

function getChildParentMap(modifiedBoundaryData: any) {
  const childParentMap = new Map<
    { key: string; value: string },
    { key: string; value: string } | null
  >();
  const stringifiedMap = new Set<string>(); // To avoid deep _.isEqual() lookup
  modifiedBoundaryData.forEach((row: any[]) => {
    for (let j = row.length - 1; j >= 0; j--) {
      const child = row[j];
      const parent = j - 1 >= 0 ? row[j - 1] : null;
      const childIdentifier = { key: child.key, value: child.value };
      const parentIdentifier = parent ? { key: parent.key, value: parent.value } : null;
      const lookupKey = parentIdentifier
        ? `${child.key}|${child.value}__${parent.key}|${parent.value}`
        : `${child.key}|${child.value}__null`;
      if (!stringifiedMap.has(lookupKey)) {
        childParentMap.set(childIdentifier, parentIdentifier);
        stringifiedMap.add(lookupKey);
      }
    }
  });
  return childParentMap;
}

function getCodeMappingsOfExistingBoundaryCodes(withBoundaryCode: any[], localizationMap: any) {
  const countMap = new Map<{ key: string; value: string }, number>();
  const mappingMap = new Map<{ key: string; value: string }, string>();


  withBoundaryCode.forEach((row: any[]) => {
    const effectiveRow = [];
    for (const item of row) {
      if (item.key === getLocalizedName(config?.boundary?.boundaryCode, localizationMap)) {
        effectiveRow.push(item);
        break;

      }
      effectiveRow.push(item);
    }
    const len = effectiveRow.length;
    if (len >= 3) {
      let grandParentFound = false;
      const grandParent = effectiveRow[len - 3];
      if (findMapValue(mappingMap, grandParent)) {
        const countMapArray = Array.from(countMap.entries());
        for (const [key, value] of countMapArray) {
          if (_.isEqual(key, grandParent)) {
            countMap.set(key, value + 1);
            grandParentFound = true;
            break;
          }
        }
        if (grandParentFound == false) {
          countMap.set(grandParent, 1);
        }
      }
    }
    mappingMap.set(effectiveRow[len - 2], effectiveRow[len - 1].value);
  });
  return { mappingMap, countMap };
}

function updateBoundaryData(boundaryData: any[], hierarchy: any[]): any[] {
  const map: Map<string, string> = new Map();
  const count: Map<string, number> = new Map();
  boundaryData = boundaryData.map(row =>
    Object.fromEntries(
      Object.entries(row).map(([key, value]) =>
        [key, typeof value === "string" ? value.trim() : value]
      )
    )
  );

  boundaryData.forEach((row) => {
    const keys = Object.keys(row).filter((key) => hierarchy.includes(key));
    keys.forEach((key, index) => {
      if (index > 0) {
        const element = row[key];
        const previousKey = keys[index - 1];
        const previousElement = row[keys[index - 1]];
        const previousElementKey = `${previousKey}:${previousElement}`;
        const elementKey = `${key}:${element}`;

        if (!map.has(elementKey)) {
          map.set(elementKey, previousElementKey);
          count.set(elementKey, 1);
        } else {
          const currentCount = count.get(elementKey)!;
          if (map.get(elementKey) !== previousElementKey) {
            map.set(elementKey, previousElementKey);
            count.set(elementKey, currentCount + 1);
          }
          const uniqueCount = count.get(elementKey)!;
          const uniqueElement =
            uniqueCount > 1
              ? `${element}_${key.length > 3 ? key.slice(0, 3).toLowerCase() : key.toLowerCase()}_${(uniqueCount - 1).toString().padStart(2, "0")}`
              : `${element}`;
          row[key] = uniqueElement;
        }
      }
    });
  });
  return boundaryData;
}

function getLocalizedNameOnlyIfMessagePresent(
  expectedName: string,
  localizationMap?: { [key: string]: string }
) {
  if (!localizationMap || !(expectedName in localizationMap)) {
    return '';
  }
  const localizedName = localizationMap[expectedName];
  return localizedName;
}


export async function getLatLongMapForBoundaryCodes(request:any, boundaryCodeList: any[]) {
  const chunkSize = 20;
  const boundaryCodeChunks = [];
  let boundaryCodeLatLongMap: { [key: string]: number[] } = {}; // Map to hold lat/long data for boundary codes
  
  // Split the boundaryCodeList into chunks of 20
  for (let i = 0; i < boundaryCodeList.length; i += chunkSize) {
    boundaryCodeChunks.push(boundaryCodeList.slice(i, i + chunkSize));
  }
  
  // Process each chunk
  for (const chunk of boundaryCodeChunks) {
    const boundaryCodeString = chunk.join(", ");
  
    // Only proceed if there are valid boundary codes
    if (boundaryCodeList.length > 0 && boundaryCodeString) {
      logger.info(`Creating boundary entities for codes: ${boundaryCodeString}`);
  
      try {
        // Make the API request to fetch boundary entities
        const boundaryEntityResponse = await httpRequest(
          config.host.boundaryHost + config.paths.boundaryEntity,
          request.body,  // Passing the request body
          { tenantId: request?.query?.tenantId, codes: boundaryCodeString }  // Query params
        );
  
        // Process the boundary entities and extract lat/long for 'Point' geometries
        if (boundaryEntityResponse?.Boundary) {
          for (const boundary of boundaryEntityResponse.Boundary) {
            if (boundary?.geometry && boundary.geometry.type === "Point") {
              boundaryCodeLatLongMap[boundary.code] = boundary.geometry.coordinates;
            }
          }
        }
  
      } catch (error: any) {
        // Log error but do not stop the process for other chunks
        console.log(error);
        logger.error(`Failed to fetch boundary entities for codes: ${boundaryCodeString}, Error: ${error.message}`);
      }
  
    } else {
      // Log when the chunk is empty or invalid
      logger.debug(`Skipping empty or invalid chunk: ${boundaryCodeString}`);
    }
  }
  boundaryCodeLatLongMap['ADMIN_MO'] = [200,100];
  // Return or process the map further if needed
  return boundaryCodeLatLongMap;  
}

const buildGenerateRequest = (request: any) => {
    const newRequestBody = {
        RequestInfo: request?.body?.RequestInfo
    };

    const params = {
        tenantId: request?.query?.tenantId,
        forceUpdate: 'true',
        hierarchyType: request?.query?.hierarchyType,
        referenceId: request?.query?.referenceId
    };

    return replicateRequest(request, newRequestBody, params);
};

async function processDataSearchRequest(request: any) {
  const { SearchCriteria } = request.body;
  const query = buildWhereClauseForDataSearch(SearchCriteria);
  const queryResult = await executeQuery(query.query, query.values);
  request.body.ResourceDetails = genericResourceTransformer(queryResult?.rows);
}

function buildWhereClauseForDataSearch(SearchCriteria: any): {
  query: string;
  values: any[];
} {
  const { id, tenantId, status, hierarchyType ,referenceId} = SearchCriteria;
  let conditions = [];
  let values = [];

  // Check for id
  if (id && id.length > 0) {
    conditions.push(`id = ANY($${values.length + 1})`);
    values.push(id);
  }

  // Check for tenantId
  if (tenantId) {
    conditions.push(`tenantId = $${values.length + 1}`);
    values.push(tenantId);
  }

  // Check for status
  if (status) {
    conditions.push(`status = $${values.length + 1}`);
    values.push(status);
  }

  // Check for hierarchyType
  if (hierarchyType) {
    conditions.push(`hierarchyType = $${values.length + 1}`);
    values.push(hierarchyType);
  }
   if(referenceId){
    conditions.push(`referenceId = $${values.length + 1}`);
    values.push(referenceId);}

  // Build the WHERE clause
  const whereClause =
    conditions.length > 0 ? `WHERE ${conditions.join(" AND ")}` : "";

  // Return the query and values array
  const tableName = getTableName(config?.DB_CONFIG.DB_RESOURCE_DETAILS_TABLE_NAME, tenantId);
  return {
    query: `
            SELECT *
            FROM ${tableName}
            ${whereClause};`,
    values,
  };
}

export {getHeadersOfBoundarySheet ,getLocalizedName,getHierarchy,validateHeaders,boundaryBulkUpload
  ,extractCodesFromBoundaryRelationshipResponse ,getLocalizedNameOnlyIfMessagePresent ,buildGenerateRequest,processDataSearchRequest
};
;