import { getExcelWorkbookFromFileURL,getNewExcelWorkbook ,addDataToSheet} from "../utils/excelUtils";
import config from "../config";
import { httpRequest } from "./request";
import { logger } from "./logger";
import { throwError,getLocalizedHeaders,createHeaderToHierarchyMap,
  modifyBoundaryDataHeadersWithMap,modifyBoundaryData,findMapValue,extractFrenchOrPortugeseLocalizationMap}
 from "../utils/genericUtils";
import { searchBoundaryRelationshipDefinition  } from "../api/coreApis";
import { BoundaryModels } from "../models";
import { getSheetData ,getAutoGeneratedBoundaryCodesHandler,createBoundaryEntities
  ,createBoundaryRelationship,createExcelSheet,createAndUploadFile
} from "../api/genericApis";
import{validateBoundarySheetDataInCreateFlow} from "../validators/boundaryValidators";
import { transformAndCreateLocalisation } from "./transforms/localisationMessageConstructor";
import {handleResouceDetailsError} from "../api/boundaryApis";
const _ = require("lodash");



function getLocalizedName(
  expectedName: string,
  localizationMap?: { [key: string]: string }
) {
  if (!localizationMap || !(expectedName in localizationMap)) {
    return expectedName;
  }
  const localizedName = localizationMap[expectedName];
  return localizedName;
}
// Function to generate localisation module name based on hierarchy type
export const getBoundaryTabName = () => {
  // Construct Boundary tab name from the config
  return config?.boundary?.boundaryTab;
};

const getHeadersOfBoundarySheet = async (
  fileUrl: string,
  sheetName: string,
  getRow = false,
  localizationMap?: any
) => {
  const localizedBoundarySheetName = getLocalizedName(
    sheetName,
    localizationMap
  );
  const workbook: any = await getExcelWorkbookFromFileURL(
    fileUrl,
    localizedBoundarySheetName
  );

  const worksheet = workbook.getWorksheet(localizedBoundarySheetName);
  const columnsToValidate = worksheet
    .getRow(1)
    .values.map((header: any) =>
      header ? header.toString().trim() : undefined
    );

  // Filter out empty items and return the result
  return columnsToValidate.filter((header: any) => typeof header === "string");
};

const getHierarchy = async (
  tenantId: string,
  hierarchyType: string
) => {
  const BoundaryTypeHierarchySearchCriteria: BoundaryModels.BoundaryHierarchyDefinitionSearchCriteria =
  {
    BoundaryTypeHierarchySearchCriteria: {
      tenantId,
      hierarchyType,
    },
  };
  const response: BoundaryModels.BoundaryHierarchyDefinitionResponse =
    await searchBoundaryRelationshipDefinition(
      BoundaryTypeHierarchySearchCriteria
    );
  const boundaryList = response?.BoundaryHierarchy?.[0].boundaryHierarchy;
  return generateHierarchy(boundaryList);
};

function generateHierarchy(boundaries: any[]) {
  // Create an object to store boundary types and their parents
  const parentMap: any = {};

  // Populate the object with boundary types and their parents
  for (const boundary of boundaries) {
    parentMap[boundary.boundaryType] = boundary.parentBoundaryType;
  }

  // Traverse the hierarchy to generate the hierarchy list
  const hierarchyList = [];
  for (const boundaryType in parentMap) {
    if (Object.prototype.hasOwnProperty.call(parentMap, boundaryType)) {
      const parentBoundaryType = parentMap[boundaryType];
      if (parentBoundaryType === null) {
        // This boundary type has no parent, add it to the hierarchy list
        hierarchyList.push(boundaryType);
        // Traverse its children recursively
        traverseChildren(boundaryType, parentMap, hierarchyList);
      }
    }
  }
  return hierarchyList;
}
function traverseChildren(parent: any, parentMap: any, hierarchyList: any[]) {
  for (const boundaryType in parentMap) {
    if (Object.prototype.hasOwnProperty.call(parentMap, boundaryType)) {
      const parentBoundaryType = parentMap[boundaryType];
      if (parentBoundaryType === parent) {
        // This boundary type has the current parent, add it to the hierarchy list
        hierarchyList.push(boundaryType);
        // Traverse its children recursively
        traverseChildren(boundaryType, parentMap, hierarchyList);
      }
    }
  }
}

async function validateHeaders(hierarchy: any[], headersOfBoundarySheet: any, request: any, localizationMap?: any) {
    validateBoundarySheetHeaders(headersOfBoundarySheet, hierarchy, request, localizationMap);
}


function validateBoundarySheetHeaders(headersOfBoundarySheet: any[], hierarchy: any[], request: any, localizationMap?: any) {
    const localizedBoundaryCode = getLocalizedName(getBoundaryColumnName(), localizationMap)
    const boundaryCodeIndex = headersOfBoundarySheet.indexOf(localizedBoundaryCode);
    const keysBeforeBoundaryCode = boundaryCodeIndex === -1 ? headersOfBoundarySheet : headersOfBoundarySheet.slice(0, boundaryCodeIndex);
    if (keysBeforeBoundaryCode.some((key: any, index: any) => (key === undefined || key === null) || key !== hierarchy[index]) || keysBeforeBoundaryCode.length !== hierarchy.length) {
        const errorMessage = `"Boundary Sheet Headers are not the same as the hierarchy present for the given tenant and hierarchy type: ${request?.body?.ResourceDetails?.hierarchyType}"`;
        throwError("BOUNDARY", 400, "BOUNDARY_SHEET_HEADER_ERROR", errorMessage);
    }
}

export const getBoundaryColumnName = () => {
  // Construct Boundary column name from the config
  return config?.boundary?.boundaryCode;
};

async function boundaryBulkUpload(request: any, localizationMap?: any) {
  try {
    logger.info("Boundary Relationship Creation Starts");
    await autoGenerateBoundaryCodes(request, localizationMap);
    // await generateProcessedFileAndPersist(request);
  } catch (error: any) {
    console.log(error);
    await handleResouceDetailsError(request, error);
  }
}

const autoGenerateBoundaryCodes = async (
  request: any,
  localizationMap?: any
) => {
  const { hierarchyType, tenantId } = request?.body?.ResourceDetails || {};
  const hierarchy =
    (await getHierarchy(tenantId, hierarchyType)) || [];
  const headersOfBoundarySheet = hierarchy.map(
    (e) => `${hierarchyType.toUpperCase()}_${e.toUpperCase()}`
  );
  const localizedHeadersOfBoundarySheet = getLocalizedHeaders(
    headersOfBoundarySheet,
    localizationMap
  );
  const type = "boundaryManagement";
  const fileResponse = await httpRequest(
    config.host.filestore + config.paths.filestore + "/url",
    {},
    { tenantId, fileStoreIds: request?.body?.ResourceDetails?.fileStoreId },
    "get"
  );
  const localizedBoundaryTab = getLocalizedName(
    getBoundaryTabName(),
    localizationMap
  );
  var boundaryData = await getSheetData(
    fileResponse?.fileStoreIds?.[0]?.url,
    localizedBoundaryTab,
    false,
    undefined,
    localizationMap
  );
  var latLongData: any;
  if (type === "boundaryManagement") {
    validateBoundarySheetDataInCreateFlow(
      boundaryData,
      localizedHeadersOfBoundarySheet
    );
    const result = updateBoundaryDataForBoundaryManagement(
      request,
      boundaryData,
      localizationMap
    );
    latLongData = result.latLongData;
    boundaryData = result.updatedData;
  }
  const updatedBoundaryData = updateBoundaryData(boundaryData, localizedHeadersOfBoundarySheet);
  const headerToHierarchyMap = createHeaderToHierarchyMap(localizedHeadersOfBoundarySheet, hierarchy);
  const modifiedBoundaryData = modifyBoundaryDataHeadersWithMap(updatedBoundaryData, headerToHierarchyMap);
  const [withBoundaryCode, withoutBoundaryCode] = modifyBoundaryData(
    modifiedBoundaryData,
    localizationMap
  );
  const { mappingMap, countMap } =
    getCodeMappingsOfExistingBoundaryCodes(withBoundaryCode, localizationMap);
  const childParentMap = getChildParentMap([
    ...withBoundaryCode,
    ...withoutBoundaryCode,
  ]);
  const boundaryMap = await getAutoGeneratedBoundaryCodesHandler(
    withoutBoundaryCode,
    childParentMap,
    mappingMap,
    countMap,
    request,
    hierarchy
  );
  logger.info("Boundary Code Auto Generation Completed");
  await createBoundaryEntities(request, boundaryMap);
  logger.info(
    "waiting for 2 secs to persist the boundary entities before creating boundary relationship"
  );
  await new Promise((resolve) => setTimeout(resolve, 2000));
  const modifiedChildParentMap = modifyChildParentMap(
    childParentMap,
    boundaryMap
  );
  await createBoundaryRelationship(
    request,
    boundaryMap,
    modifiedChildParentMap
  );
  const boundaryDataForSheet = addBoundaryCodeToData(
    withBoundaryCode,
    withoutBoundaryCode,
    boundaryMap,
    hierarchy,
    localizationMap
  );
  logger.info(
    "Initiated the localisation message creation for the uploaded boundary"
  );
  const frenchLocalizationMap = extractFrenchOrPortugeseLocalizationMap(boundaryDataForSheet, true, false, localizationMap);
  const portugeseLocalizationMap = extractFrenchOrPortugeseLocalizationMap(boundaryDataForSheet, false, true, localizationMap);
  await transformAndCreateLocalisation(frenchLocalizationMap, request, true, false);
  await transformAndCreateLocalisation(portugeseLocalizationMap, request, false, true);
  await transformAndCreateLocalisation(boundaryMap, request, false, false);
  const modifiedHierarchy = hierarchy.map((ele) =>
    `${hierarchyType}_${ele}`.toUpperCase()
  );
  var headers = [...modifiedHierarchy, config?.boundary?.boundaryCode];
  const data = prepareDataForExcel(
    boundaryDataForSheet,
    hierarchy,
    boundaryMap,
    localizationMap
  );
  if (type === "boundaryManagement") {
    headers = [
      ...headers,
      getLocalizedName("HCM_ADMIN_CONSOLE_FRENCH_LOCALIZATION_MESSAGE", localizationMap),
      getLocalizedName("HCM_ADMIN_CONSOLE_FRENCH_LOCALIZATION_MESSAGE", localizationMap),
      getLocalizedName("HCM_ADMIN_CONSOLE_LAT", localizationMap),
      getLocalizedName("HCM_ADMIN_CONSOLE_LONG", localizationMap)
    ];
    data.forEach((row: any[], index: string | number) => {
      if (latLongData.length > index) {
        row.push(latLongData[index][0], latLongData[index][1]);
      }
    });
  }
  const localizedHeaders = getLocalizedHeaders(headers, localizationMap);
  const boundarySheetData: any = await createExcelSheet(data, localizedHeaders);
  const workbook = getNewExcelWorkbook();
  const boundarySheet = workbook.addWorksheet(localizedBoundaryTab);
  addDataToSheet(request, boundarySheet, boundarySheetData, "93C47D", 40, true);
  const boundaryFileDetails: any = await createAndUploadFile(workbook, request);
  request.body.ResourceDetails.processedFileStoreId =
    boundaryFileDetails?.[0]?.fileStoreId;
};

function modifyChildParentMap(
  childParentMap: Map<any, any>,
  boundaryMap: Map<any, any>
): Map<string, string | null> {
  const modifiedMap: Map<string, string | null> = new Map();

  // Iterate over each entry in childParentMap
  childParentMap.forEach((value, key) => {
    // Get the modified key and value from boundaryMap
    const modifiedKey = findMapValue(boundaryMap, key) || null;
    const modifiedValue = value ? findMapValue(boundaryMap, value) : null;

    // Set the modified key-value pair in modifiedMap
    modifiedMap.set(modifiedKey, modifiedValue);
  });

  return modifiedMap;
}

function extractCodesFromBoundaryRelationshipResponse(boundaries: any[]): any {
  const codes = new Set();
  for (const boundary of boundaries) {
    codes.add(boundary.code); // Add code to the Set
    if (boundary.children && boundary.children.length > 0) {
      const childCodes = extractCodesFromBoundaryRelationshipResponse(
        boundary.children
      ); // Recursively get child codes
      childCodes.forEach((code: any) => codes.add(code)); // Add child codes to the Set
    }
  }
  return codes;
}

function prepareDataForExcel(
  boundaryDataForSheet: any[],
  hierarchy: any[],
  boundaryMap: any,
  localizationMap: any
) {
  const boundaryKey = getLocalizedName(config?.boundary?.boundaryCode, localizationMap);

  const data = boundaryDataForSheet.map((row: any[]) => {
    const rowMap = new Map<string, any>();
    row.forEach(obj => rowMap.set(obj.key, obj.value));

    // 1. Pick hierarchy values in order
    const hierarchyValues = hierarchy.map(level => rowMap.get(level) || "");

    // 2. Get boundary code value
    const boundaryCode = rowMap.get(boundaryKey) || "";

    // 3. Get remaining key-value pairs (excluding hierarchy + boundaryKey)
    const excludedKeys = new Set([...hierarchy, boundaryKey]);
    const remainingValues = row
      .filter(obj => !excludedKeys.has(obj.key))
      .map(obj => obj.value || "");

    // 4. Final row structure: hierarchy values + boundary code + remaining key-value pairs
    return [...hierarchyValues, boundaryCode, ...remainingValues];
  });

  return data;
}

function updateBoundaryDataForBoundaryManagement(
  request: any,
  boundaryData: any[],
  localizationMap: any
): { updatedData: any[]; latLongData: [number, number][] } {
  const latLongData: [number, number][] = [];
  const latKey = getLocalizedName("HCM_ADMIN_CONSOLE_LAT", localizationMap);
  const longKey = getLocalizedName("HCM_ADMIN_CONSOLE_LONG", localizationMap);

  boundaryData.forEach((row) => {
    // Check if the row contains both latitude and longitude keys
    if (latKey in row && longKey in row) {
      // Push latitude and longitude to the latLongData array
      latLongData.push([row[latKey], row[longKey]]);

      // Remove the latitude and longitude from the original row
      delete row[latKey];
      delete row[longKey];
    }
  });

  // Return both the updated boundary data and latLongData
  return {
    updatedData: boundaryData,
    latLongData,
  };
}

function addBoundaryCodeToData(
  withBoundaryCode: any[],
  withoutBoundaryCode: any[],
  boundaryMap: Map<any, any>,
  hierarchy: any,
  localizationMap: any
) {
  const boundaryKey = getLocalizedName(config?.boundary?.boundaryCode, localizationMap);

  // Part 1: extract boundary codes directly
  // const modifiedBoundaryDataWithBoundaryCode = withBoundaryCode.map((array) => {
  //   return array.map((obj: any) => {
  //     if (obj.key === boundaryKey) {
  //       return obj.value; // replace with value (just the boundary code)
  //     } else {
  //       return obj;
  //     }
  //   });
  // });

  // Part 2: for rows without boundary code
  const boundaryDataForWithoutBoundaryCode = withoutBoundaryCode.map((row: any[]) => {
    let boundaryName: string | undefined;

    for (let level of hierarchy) {
      const match = row.find(obj => obj.key === level && obj.value);
      if (match) {
        boundaryName = match; // keep updating as we go down hierarchy
      }
    }

    const boundaryCode = findMapValue(boundaryMap, boundaryName);
    const boundaryCodeObj = { key: boundaryKey, value: boundaryCode };
    return [...row, boundaryCodeObj]; // just append the boundary code at the end
  });


  const boundaryDataForSheet = [
    ...withBoundaryCode,
    ...boundaryDataForWithoutBoundaryCode,
  ];

  return boundaryDataForSheet;
}

function getChildParentMap(modifiedBoundaryData: any) {
  const childParentMap = new Map<
    { key: string; value: string },
    { key: string; value: string } | null
  >();
  const stringifiedMap = new Set<string>(); // To avoid deep _.isEqual() lookup
  modifiedBoundaryData.forEach((row: any[]) => {
    for (let j = row.length - 1; j >= 0; j--) {
      const child = row[j];
      const parent = j - 1 >= 0 ? row[j - 1] : null;
      const childIdentifier = { key: child.key, value: child.value };
      const parentIdentifier = parent ? { key: parent.key, value: parent.value } : null;
      const lookupKey = parentIdentifier
        ? `${child.key}|${child.value}__${parent.key}|${parent.value}`
        : `${child.key}|${child.value}__null`;
      if (!stringifiedMap.has(lookupKey)) {
        childParentMap.set(childIdentifier, parentIdentifier);
        stringifiedMap.add(lookupKey);
      }
    }
  });
  return childParentMap;
}

function getCodeMappingsOfExistingBoundaryCodes(withBoundaryCode: any[], localizationMap: any) {
  const countMap = new Map<{ key: string; value: string }, number>();
  const mappingMap = new Map<{ key: string; value: string }, string>();


  withBoundaryCode.forEach((row: any[]) => {
    const effectiveRow = [];
    for (const item of row) {
      if (item.key === getLocalizedName(config?.boundary?.boundaryCode, localizationMap)) {
        effectiveRow.push(item);
        break;

      }
      effectiveRow.push(item);
    }
    const len = effectiveRow.length;
    if (len >= 3) {
      let grandParentFound = false;
      const grandParent = effectiveRow[len - 3];
      if (findMapValue(mappingMap, grandParent)) {
        const countMapArray = Array.from(countMap.entries());
        for (const [key, value] of countMapArray) {
          if (_.isEqual(key, grandParent)) {
            countMap.set(key, value + 1);
            grandParentFound = true;
            break;
          }
        }
        if (grandParentFound == false) {
          countMap.set(grandParent, 1);
        }
      }
    }
    mappingMap.set(effectiveRow[len - 2], effectiveRow[len - 1].value);
  });
  return { mappingMap, countMap };
}

function updateBoundaryData(boundaryData: any[], hierarchy: any[]): any[] {
  const map: Map<string, string> = new Map();
  const count: Map<string, number> = new Map();
  boundaryData = boundaryData.map(row =>
    Object.fromEntries(
      Object.entries(row).map(([key, value]) =>
        [key, typeof value === "string" ? value.trim() : value]
      )
    )
  );

  boundaryData.forEach((row) => {
    const keys = Object.keys(row).filter((key) => hierarchy.includes(key));
    keys.forEach((key, index) => {
      if (index > 0) {
        const element = row[key];
        const previousKey = keys[index - 1];
        const previousElement = row[keys[index - 1]];
        const previousElementKey = `${previousKey}:${previousElement}`;
        const elementKey = `${key}:${element}`;

        if (!map.has(elementKey)) {
          map.set(elementKey, previousElementKey);
          count.set(elementKey, 1);
        } else {
          const currentCount = count.get(elementKey)!;
          if (map.get(elementKey) !== previousElementKey) {
            map.set(elementKey, previousElementKey);
            count.set(elementKey, currentCount + 1);
          }
          const uniqueCount = count.get(elementKey)!;
          const uniqueElement =
            uniqueCount > 1
              ? `${element}_${key.length > 3 ? key.slice(0, 3).toLowerCase() : key.toLowerCase()}_${(uniqueCount - 1).toString().padStart(2, "0")}`
              : `${element}`;
          row[key] = uniqueElement;
        }
      }
    });
  });
  return boundaryData;
}


export {getHeadersOfBoundarySheet ,getLocalizedName,getHierarchy,validateHeaders,boundaryBulkUpload
  ,extractCodesFromBoundaryRelationshipResponse
};
;