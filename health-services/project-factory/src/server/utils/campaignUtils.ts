
import { defaultheader, httpRequest } from "./request";
import config from "../config/index";
import { v4 as uuidv4 } from 'uuid';
import { produceModifiedMessages } from "../kafka/Producer";
import { confirmProjectParentCreation, createProjectCampaignResourcData, getCampaignSearchResponse, getHierarchy, handleResouceDetailsError, projectCreate, projectUpdateForTargets } from "../api/campaignApis";
import { getCampaignNumber, createAndUploadFile, createExcelSheet, getAutoGeneratedBoundaryCodesHandler, createBoundaryEntities, getMDMSV1Data, getTargetSheetDataAfterCode, callMdmsTypeSchema, getSheetDataFromWorksheet, getTargetWorkbook, createAndUploadJsonFile, createBoundaryRelationship, getSheetData } from "../api/genericApis";
import { getFormattedStringForDebug, logger } from "./logger";
import createAndSearch from "../config/createAndSearch";
import { addDataToSheet, createBoundaryDataMainSheet, createFacilityAndBoundaryFile, createReadMeSheet, findMapValue, getBoundaryRelationshipData, getConfigurableColumnHeadersFromSchemaForTargetSheet, getLocalizedHeaders, getLocalizedMessagesHandler, getMdmsDataBasedOnCampaignType, modifyBoundaryData, replicateRequest, throwError } from "./genericUtils";
import { enrichProjectDetailsFromCampaignDetails } from "./transforms/projectTypeUtils";
import { executeQuery } from "./db";
import { campaignDetailsTransformer, genericResourceTransformer } from "./transforms/searchResponseConstructor";
import { transformAndCreateLocalisation } from "./transforms/localisationMessageConstructor";
import { campaignStatuses, headingMapping, processTrackStatuses, processTrackTypes, resourceDataStatuses } from "../config/constants";
import { getBoundaryColumnName, getBoundaryTabName } from "./boundaryUtils";
import { searchProjectTypeCampaignService, updateProjectTypeCampaignService } from "../service/campaignManageService";
import { validateBoundaryOfResouces, validateBoundarySheetDataInCreateFlow } from "../validators/campaignValidators";
import { getExcelWorkbookFromFileURL, getNewExcelWorkbook, lockTargetFields, updateFontNameToRoboto } from "./excelUtils";
import { areBoundariesSame, callGenerate, callGenerateIfBoundariesOrCampaignTypeDiffer } from "./generateUtils";
import { createProcessTracks, persistTrack } from "./processTrackUtils";
import { generateDynamicTargetHeaders, isDynamicTargetTemplateForProjectType, updateTargetColumnsIfDeliveryConditionsDifferForSMC } from "./targetUtils";
import { callGenerateWhenChildCampaigngetsCreated, fetchProjectsWithBoundaryCodeAndName, fetchProjectsWithParentRootProjectId, getBoundariesFromCampaignSearchResponse, getBoundaryProjectMappingFromParentCampaign, getColumnIndexByHeader, hideColumnsOfProcessedFile, modifyNewSheetData, unhideColumnsOfProcessedFile } from "./onGoingCampaignUpdateUtils";
import { changeCreateDataForMicroplan, lockSheet } from "./microplanUtils";
const _ = require('lodash');
import { createDataService, searchDataService } from "../service/dataManageService";
import { searchMDMSDataViaV2Api } from "../api/coreApis";
import { deleteRedisCacheKeysWithPrefix } from "./redisUtils";




function updateRange(range: any, worksheet: any) {
    let maxColumnIndex = 0;

    // Iterate through each row to find the last column with data
    for (let row = range.s.r; row <= range.e.r; row++) {
        const rowCells = worksheet.getRow(row + 1); // ExcelJS rows are 1-based
        rowCells.eachCell((cell: any, colNumber: number) => {
            if (cell.value !== undefined && colNumber > maxColumnIndex) {
                maxColumnIndex = colNumber;
            }
        });
    }

    // Update the end column of the range with the maximum column index found
    range.e.c = maxColumnIndex;
}

function findAndChangeColumns(worksheet: any, columns: any) {
    const firstRow = worksheet.getRow(1);
    firstRow.eachCell((cell: any, colNumber: number) => {
        if (cell.value === '#status#') {
            columns.statusColumn = cell.address.replace(/\d+/g, '');
            // Set the cell color to green
            cell.fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'CCCC00' }
            };
            // Delete status column cells in subsequent rows
            worksheet.eachRow((row: any, rowIndex: number) => {
                if (rowIndex > 1) {
                    const statusCell = row.getCell(colNumber);
                    statusCell.value = undefined;
                }
            });
        }
        if (cell.value === '#errorDetails#') {
            columns.errorDetailsColumn = cell.address.replace(/\d+/g, '');
            // Set the cell color to green
            cell.fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'CCCC00' }
            };
            // Delete error details column cells in subsequent rows
            worksheet.eachRow((row: any, rowIndex: number) => {
                if (rowIndex > 1) {
                    const errorDetailsCell = row.getCell(colNumber);
                    errorDetailsCell.value = undefined;
                }
            });
        }
    });
}

function makeColumns(worksheet: any, range: any, columns: any) {
    // If the status column doesn't exist, calculate the next available column
    if (!columns?.statusColumn) {
        const emptyColumnIndex = range.e.c;
        columns.statusColumn = String.fromCharCode(65 + (emptyColumnIndex + 1));
        const statusCell = worksheet.getCell(`${columns.statusColumn}1`);
        statusCell.value = '#status#';
        statusCell.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'CCCC00' }
        };
        statusCell.font = { bold: true };
        worksheet.getColumn(columns.statusColumn).width = 40;
    }

    // Calculate errorDetails column one column to the right of status column
    if (!columns?.errorDetailsColumn) {
        columns.errorDetailsColumn = String.fromCharCode(columns?.statusColumn.charCodeAt(0) + 1);
        const errorDetailsCell = worksheet.getCell(`${columns.errorDetailsColumn}1`);
        errorDetailsCell.value = '#errorDetails#';
        errorDetailsCell.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'CCCC00' }
        };
        errorDetailsCell.font = { bold: true };
        worksheet.getColumn(columns.errorDetailsColumn).width = 40;
    }
}


function findColumns(worksheet: any) {
    const range = {
        s: { r: 0, c: 0 },
        e: { r: worksheet.rowCount - 1, c: worksheet.columnCount - 1 }
    };

    // Check if the status column already exists in the first row
    var columns = {}

    findAndChangeColumns(worksheet, columns);

    makeColumns(worksheet, range, columns);

    updateRange(range, worksheet);

    return columns;
}

function enrichErrors(errorData: any, worksheet: any, statusColumn: any, errorDetailsColumn: any, additionalDetailsErrors: any, createAndSearchConfig: any, localizationMap?: { [key: string]: string }) {
    if (errorData) {
        errorData.forEach((error: any) => {
            const rowIndex = error.rowNumber; // ExcelJS rows are 1-based
            const statusCell = worksheet.getCell(`${statusColumn}${rowIndex}`);
            const errorDetailsCell = worksheet.getCell(`${errorDetailsColumn}${rowIndex}`);
            statusCell.value = error.status;
            errorDetailsCell.value = error.errorDetails;

            if ((error?.status) && !(error?.status === "CREATED" || error?.status === "VALID")) {
                additionalDetailsErrors.push(error);
            }
        });
        if (errorData.some((error: any) => error?.status === "CREATED")) {
            const uniqueIdentifierFirstRowCell = `${createAndSearchConfig?.uniqueIdentifierColumn}1`;
            const columnName = getLocalizedName(createAndSearchConfig?.uniqueIdentifierColumnName, localizationMap);
            const uniqueIdentifierCell = worksheet.getCell(uniqueIdentifierFirstRowCell);
            uniqueIdentifierCell.value = columnName;

            // Set the cell color to green
            uniqueIdentifierCell.fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'ff9248' } // Green color
            };
            uniqueIdentifierCell.font = { bold: true };
            // Hide the unique identifier column
            worksheet.getColumn(createAndSearchConfig?.uniqueIdentifierColumn).hidden = true;
        }
        errorData.forEach((error: any) => {
            const rowIndex = error.rowNumber;
            if (error.isUniqueIdentifier) {
                const uniqueIdentifierCell = worksheet.getCell(`${createAndSearchConfig.uniqueIdentifierColumn}${rowIndex}`);
                uniqueIdentifierCell.value = error.uniqueIdentifier;
                if (createAndSearchConfig?.activeColumn) {
                    const activeCell = worksheet.getCell(`${createAndSearchConfig.activeColumn}${rowIndex}`);
                    activeCell.value = "Active";
                }
            }
        });
    }
}

function enrichActiveAndUUidColumn(worksheet: any, createAndSearchConfig: any, request: any) {
    if (createAndSearchConfig?.activeColumn && request?.body?.dataToCreate && request?.body?.dataToCreate?.length > 0 && request?.body?.ResourceDetails?.type == "user") {
        const dataToCreate = request.body.dataToCreate;
        for (const data of dataToCreate) {
            const rowNumber = data['!row#number!'];
            const activeCell = worksheet.getCell(`${createAndSearchConfig?.activeColumn}${rowNumber}`);
            const uniqueIdentifierCell = worksheet.getCell(`${createAndSearchConfig?.uniqueIdentifierColumn}${rowNumber}`);
            activeCell.value = "Active";
            uniqueIdentifierCell.value = data['userServiceUuid'];
        }
    }
}

function deterMineLastColumnAndEnrichUserDetails(
    worksheet: any,
    errorDetailsColumn: number,
    userNameAndPassword: { rowNumber: number, userName: string, password: string }[] | undefined,
    request: any,
    createAndSearchConfig: { uniqueIdentifierColumn?: number }
): string {
    // Determine the last column
    let lastColumn: any = errorDetailsColumn;
    if (createAndSearchConfig?.uniqueIdentifierColumn !== undefined) {
        lastColumn = createAndSearchConfig?.uniqueIdentifierColumn > errorDetailsColumn ?
            createAndSearchConfig?.uniqueIdentifierColumn :
            errorDetailsColumn;
    }

    // Default columns
    let usernameColumn = "J";
    let passwordColumn = "K";

    // Update columns if the request indicates a different source
    if (request?.body?.ResourceDetails?.additionalDetails?.source == "microplan") {
        usernameColumn = "F";
        passwordColumn = "G";
    }

    // Populate username and password columns if data is provided
    if (userNameAndPassword) {
        // Set headers with formatting
        const setCellHeader = (cell: string) => {
            worksheet.getCell(cell).value = cell === usernameColumn + "1" ? "UserName" : "Password";
            worksheet.getCell(cell).fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'ff9248' } // Green color
            };
            worksheet.getCell(cell).font = { bold: true };
            const columnLetter = cell.replace(/\d+$/, '');
            worksheet.getColumn(columnLetter).width = 40;
        };

        setCellHeader(usernameColumn + "1");
        setCellHeader(passwordColumn + "1");

        // Set values
        userNameAndPassword.forEach(data => {
            const rowIndex = data.rowNumber;
            worksheet.getCell(`${usernameColumn}${rowIndex}`).value = data.userName;
            worksheet.getCell(`${passwordColumn}${rowIndex}`).value = data.password;
        });

        // Update lastColumn based on the password column
        lastColumn = passwordColumn;
    }

    return lastColumn;
}


function adjustRef(worksheet: any, lastColumn: any) {
    const range = getSheetDataFromWorksheet(worksheet).filter((row: any) => row).length; // Get the number of used rows
    worksheet.views = [
        { state: 'frozen', ySplit: 1, topLeftCell: 'A2', activeCell: 'A2' }
    ];
    worksheet.autoFilter = {
        from: {
            row: 1,
            column: 1
        },
        to: {
            row: range,
            column: worksheet.getColumn(lastColumn).number
        }
    };
}

function processErrorData(request: any, createAndSearchConfig: any, workbook: any, sheetName: any, localizationMap?: { [key: string]: string }) {
    const worksheet = workbook.getWorksheet(sheetName);
    var errorData = request.body.sheetErrorDetails;
    const userNameAndPassword = request.body.userNameAndPassword;
    const columns: any = findColumns(worksheet);
    const statusColumn = columns.statusColumn;
    const errorDetailsColumn = columns.errorDetailsColumn;
    const additionalDetailsErrors: any[] = [];
    errorData = mergeErrors(errorData);
    enrichErrors(errorData, worksheet, statusColumn, errorDetailsColumn, additionalDetailsErrors, createAndSearchConfig, localizationMap);
    enrichActiveAndUUidColumn(worksheet, createAndSearchConfig, request);

    request.body.additionalDetailsErrors = request?.body?.additionalDetailsErrors ? request?.body?.additionalDetailsErrors.concat(additionalDetailsErrors) : additionalDetailsErrors;

    // Determine the last column to set the worksheet ref
    const lastColumn = deterMineLastColumnAndEnrichUserDetails(worksheet, errorDetailsColumn, userNameAndPassword, request, createAndSearchConfig);

    // Adjust the worksheet ref to include the last column
    adjustRef(worksheet, lastColumn);
    updateFontNameToRoboto(worksheet)

    workbook.xlsx.writeBuffer();
}

function mergeErrors(errorData: any) {
    const errorMap: any = {};

    errorData.forEach((item: any) => {
        const { rowNumber, sheetName, status, errorDetails, ...rest } = item;

        // If the rowNumber already exists, merge the errorDetails
        if (errorMap[rowNumber]) {
            errorMap[rowNumber].errorDetails += "; " + errorDetails;
        } else {
            // If not, add a new entry
            errorMap[rowNumber] = { rowNumber, sheetName, status, errorDetails, ...rest };
        }
    });

    // Convert the errorMap back into an array
    return Object.values(errorMap);
}



function processErrorDataForEachSheets(request: any, createAndSearchConfig: any, workbook: any, sheetName: any) {
    const desiredSheet = workbook.getWorksheet(sheetName);
    const columns: any = findColumns(desiredSheet);
    const statusColumn = columns.statusColumn;
    const errorDetailsColumn = columns.errorDetailsColumn;
    const userNameAndPassword = request?.body?.userNameAndPassword;


    var errorData = request.body.sheetErrorDetails.filter((error: any) => error.sheetName === sheetName);
    const additionalDetailsErrors: any = [];
    errorData = mergeErrors(errorData);
    if (errorData) {
        errorData.forEach((error: any) => {
            const rowIndex = error.rowNumber;
            if (error.isUniqueIdentifier) {
                const uniqueIdentifierCell = createAndSearchConfig.uniqueIdentifierColumn + (rowIndex);
                desiredSheet.getCell(uniqueIdentifierCell).value = error.uniqueIdentifier;
            }

            const statusCell = statusColumn + (rowIndex);
            const errorDetailsCell = errorDetailsColumn + (rowIndex);
            desiredSheet.getCell(statusCell).value = error.status;
            desiredSheet.getCell(errorDetailsCell).value = error.errorDetails;

            if (!(error.status === "CREATED" || error.status === "VALID")) {
                additionalDetailsErrors.push(error);
            }
        });
    }
    if (userNameAndPassword) {
        var newUserNameAndPassword: any = []
        for (const data of userNameAndPassword) {
            const rowArray = data.rowNumber
            for (let i = 0; i < rowArray.length; i++) {
                if (rowArray[i].sheetName == sheetName) {
                    newUserNameAndPassword.push({ ...data, rowNumber: rowArray[i].row })
                }
            }
        }
    }
    deterMineLastColumnAndEnrichUserDetails(desiredSheet, errorDetailsColumn, newUserNameAndPassword, request, createAndSearchConfig);
    request.body.additionalDetailsErrors = request?.body?.additionalDetailsErrors ? request?.body?.additionalDetailsErrors.concat(additionalDetailsErrors) : additionalDetailsErrors;
    updateFontNameToRoboto(desiredSheet)
    workbook.worksheets[sheetName] = desiredSheet;
}

async function updateStatusFile(request: any, localizationMap?: { [key: string]: string }) {
    const fileStoreId = request?.body?.ResourceDetails?.fileStoreId;
    const tenantId = request?.body?.ResourceDetails?.tenantId;
    const createAndSearchConfig = createAndSearch[request?.body?.ResourceDetails?.type];
    const fileResponse = await httpRequest(config.host.filestore + config.paths.filestore + "/url", {}, { tenantId: tenantId, fileStoreIds: fileStoreId }, "get");
    const isLockSheetNeeded = request?.body?.ResourceDetails?.additionalDetails?.source == 'microplan' ? true : false

    if (!fileResponse?.fileStoreIds?.[0]?.url) {
        throwError("FILE", 500, "INVALID_FILE");
    }
    const fileUrl = fileResponse?.fileStoreIds?.[0]?.url;
    const sheetName = createAndSearchConfig?.parseArrayConfig?.sheetName;
    const localizedSheetName = getLocalizedName(sheetName, localizationMap);
    const workbook: any = await getExcelWorkbookFromFileURL(fileUrl, localizedSheetName);
    const worksheet: any = workbook.getWorksheet(localizedSheetName);
    if (request?.body?.ResourceDetails?.type == 'user') {
        const columnsToUnhide = ["G", "H", "J", "K"];
        unhideColumnsOfProcessedFile(worksheet, columnsToUnhide);
    }
    processErrorData(request, createAndSearchConfig, workbook, localizedSheetName, localizationMap);

    // Set column widths
    const columnWidths = Array(12).fill({ width: 30 });
    columnWidths.forEach((colWidth, index) => {
        if (worksheet.getColumn(index + 1)) {
            worksheet.getColumn(index + 1).width = colWidth.width;
        }
    });
    if (isLockSheetNeeded) lockSheet(request, workbook);
    const responseData = await createAndUploadFile(workbook, request);

    logger.info('File updated successfully:' + JSON.stringify(responseData));
    if (responseData?.[0]?.fileStoreId) {
        request.body.ResourceDetails.processedFileStoreId = responseData?.[0]?.fileStoreId;
    } else {
        throwError("FILE", 500, "STATUS_FILE_CREATION_ERROR");
    }
}
async function updateStatusFileForEachSheets(request: any, localizationMap?: { [key: string]: string }) {
    const fileStoreId = request?.body?.ResourceDetails?.fileStoreId;
    const tenantId = request?.body?.ResourceDetails?.tenantId;
    const createAndSearchConfig = createAndSearch[request?.body?.ResourceDetails?.type];
    const fileResponse = await httpRequest(config.host.filestore + config.paths.filestore + "/url", {}, { tenantId: tenantId, fileStoreIds: fileStoreId }, "get");
    const isLockSheetNeeded = request?.body?.ResourceDetails?.additionalDetails?.source == 'microplan' ? true : false

    if (!fileResponse?.fileStoreIds?.[0]?.url) {
        throwError("FILE", 500, "INVALID_FILE");
    }

    const fileUrl = fileResponse?.fileStoreIds?.[0]?.url;

    const workbook: any = await getExcelWorkbookFromFileURL(fileUrl, "");

    const sheetNames = workbook.worksheets.map((worksheet: any) => worksheet.name);
    const localizedSheetNames = getLocalizedHeaders(sheetNames, localizationMap);

    const sheetErrorDetails = request?.body?.sheetErrorDetails;
    if (sheetErrorDetails && sheetErrorDetails?.length > 0) {
        const firstError = sheetErrorDetails[0];
        if (Array.isArray(firstError?.rowNumber)) {
            var newSheetErrorDetails: any = []
            for (const error of sheetErrorDetails) {
                for (let i = 0; i < error.rowNumber.length; i++) {
                    newSheetErrorDetails.push({ ...error, rowNumber: error.rowNumber[i]?.row, sheetName: error.rowNumber[i]?.sheetName })
                }
            }
            request.body.sheetErrorDetails = newSheetErrorDetails;
        }
    }

    localizedSheetNames.forEach((sheetName: any) => {
        if (sheetName !== getLocalizedName(config?.boundary?.boundaryTab, localizationMap) && sheetName !== getLocalizedName(config.values.readMeTab, localizationMap) && sheetName !== getLocalizedName("USER_MICROPLAN_SHEET_ROLES", localizationMap)) {
            processErrorDataForEachSheets(request, createAndSearchConfig, workbook, sheetName);
        }
    });
    if (isLockSheetNeeded) lockSheet(request, workbook);
    const responseData = await createAndUploadFile(workbook, request);
    logger.info('File updated successfully:' + JSON.stringify(responseData));
    if (responseData?.[0]?.fileStoreId) {
        request.body.ResourceDetails.processedFileStoreId = responseData?.[0]?.fileStoreId;
    } else {
        throwError("FILE", 500, "STATUS_FILE_CREATION_ERROR");
    }
}


function convertToType(dataToSet: any, type: any) {
    switch (type) {
        case "string":
            return String(dataToSet);
        case "number":
            return Number(dataToSet);
        case "boolean":
            // Convert to boolean assuming any truthy value should be true and falsy should be false
            return Boolean(dataToSet);
        // Add more cases if needed for other types
        default:
            // If type is not recognized, keep dataToSet as it is
            return dataToSet;
    }
}

function setTenantId(
    resultantElement: any,
    requestBody: any,
    createAndSearchConfig: any
) {
    if (createAndSearchConfig?.parseArrayConfig?.tenantId) {
        const tenantId = _.get(requestBody, createAndSearchConfig?.parseArrayConfig?.tenantId?.getValueViaPath);
        _.set(resultantElement, createAndSearchConfig?.parseArrayConfig?.tenantId?.resultantPath, tenantId);
    }

}


async function processData(request: any, dataFromSheet: any[], createAndSearchConfig: any, localizationMap?: { [key: string]: string }) {
    const parseLogic = createAndSearchConfig?.parseArrayConfig?.parseLogic;
    const requiresToSearchFromSheet = createAndSearchConfig?.requiresToSearchFromSheet;
    const isSourceMicroplan = request?.body?.ResourceDetails?.additionalDetails?.source == "microplan";
    var createData = [], searchData = [];
    for (const data of dataFromSheet) {
        const resultantElement: any = {};
        for (const element of parseLogic) {
            if (element?.resultantPath) {
                const localizedSheetColumnName = getLocalizedName(element.sheetColumnName, localizationMap);
                let dataToSet = _.get(data, localizedSheetColumnName);
                if (element.conversionCondition) {
                    dataToSet = element.conversionCondition[dataToSet];
                }
                if (element.type) {
                    dataToSet = convertToType(dataToSet, element.type);
                }
                _.set(resultantElement, element.resultantPath, dataToSet);
            }
        }
        resultantElement["!row#number!"] = data["!row#number!"];
        var addToCreate = true;
        if (requiresToSearchFromSheet) {
            for (const key of requiresToSearchFromSheet) {
                const localizedSheetColumnName = getLocalizedName(key.sheetColumnName, localizationMap);
                if (data[localizedSheetColumnName]) {
                    if (isSourceMicroplan) {
                        changeCreateDataForMicroplan(request, resultantElement, data, localizationMap);
                    }
                    searchData.push(resultantElement)
                    addToCreate = false;
                    break;
                }
            }
        }
        if (addToCreate) {
            if (isSourceMicroplan) {
                changeCreateDataForMicroplan(request, resultantElement, data, localizationMap);
            }
            createData.push(resultantElement)
        }
    }
    return { searchData, createData };
}

function setTenantIdAndSegregate(processedData: any, createAndSearchConfig: any, requestBody: any) {
    for (const resultantElement of processedData.createData) {
        setTenantId(resultantElement, requestBody, createAndSearchConfig);
    }
    for (const resultantElement of processedData.searchData) {
        setTenantId(resultantElement, requestBody, createAndSearchConfig);
    }
    return processedData;
}

// Original function divided into two parts
async function convertToTypeData(request: any, dataFromSheet: any[], createAndSearchConfig: any, requestBody: any, localizationMap?: { [key: string]: string }) {
    const processedData = await processData(request, dataFromSheet, createAndSearchConfig, localizationMap);
    return setTenantIdAndSegregate(processedData, createAndSearchConfig, requestBody);
}

function updateActivityResourceId(request: any) {
    if (request?.body?.Activities && Array.isArray(request?.body?.Activities)) {
        for (const activity of request?.body?.Activities) {
            activity.resourceDetailsId = request?.body?.ResourceDetails?.id
        }
    }
}

async function generateProcessedFileAndPersist(request: any, localizationMap?: { [key: string]: string }) {
    if (request.body.ResourceDetails.type == 'boundaryWithTarget' || (request?.body?.ResourceDetails?.additionalDetails?.source == "microplan" && request.body.ResourceDetails.type == 'user')) {
        await updateStatusFileForEachSheets(request, localizationMap);
    } else {
        if (request.body.ResourceDetails.type !== "boundary" && request.body.ResourceDetails.type !== "boundaryManagement") {
            await updateStatusFile(request, localizationMap);
        }
    }
    updateActivityResourceId(request);
    request.body.ResourceDetails = {
        ...request?.body?.ResourceDetails,
        status: request.body.ResourceDetails.status != resourceDataStatuses.invalid ? resourceDataStatuses.completed : resourceDataStatuses.invalid,
        auditDetails: {
            ...request?.body?.ResourceDetails?.auditDetails,
            lastModifiedBy: request?.body?.RequestInfo?.userInfo?.uuid,
            lastModifiedTime: Date.now()
        },
        additionalDetails: { ...request?.body?.ResourceDetails?.additionalDetails, sheetErrors: request?.body?.additionalDetailsErrors, source: (request?.body?.ResourceDetails?.additionalDetails?.source == "microplan") ? "microplan" : null }
    };
    if (request?.body?.ResourceDetails?.status === resourceDataStatuses.completed && request?.body?.ResourceDetails?.type === 'boundaryManagement') {

        // delete redis cache key with prefix boundaryRelatiionshipSearch
        await deleteRedisCacheKeysWithPrefix("boundaryRelationShipSearch");

        logger.info("calling generate after boundary data uploaded under type boundary management")
        const newRequestBody = {
            RequestInfo: request?.body?.RequestInfo
        };
        const params = {
            type: request?.body?.ResourceDetails?.type,
            tenantId: request?.body?.ResourceDetails?.tenantId,
            forceUpdate: 'true',
            hierarchyType: request?.body?.ResourceDetails?.hierarchyType,
            campaignId: "default"
        };
        const newRequestBoundary = replicateRequest(request, newRequestBody, params);
        setTimeout(async () => {
            // Code to be executed after 10 seconds
            logger.info("Timeout of 10 sec after boundary data creation");
            await callGenerate(newRequestBoundary, request?.body?.ResourceDetails?.type);

        }, 10000);
    }
    const persistMessage: any = { ResourceDetails: request.body.ResourceDetails }
    if (request?.body?.ResourceDetails?.action == "create") {
        persistMessage.ResourceDetails.additionalDetails = {
            source: (request?.body?.ResourceDetails?.additionalDetails?.source == "microplan") ? "microplan" : null,
            fileName: request?.body?.ResourceDetails?.additionalDetails?.fileName || null
        }
    }
    await produceModifiedMessages(persistMessage, config?.kafka?.KAFKA_UPDATE_RESOURCE_DETAILS_TOPIC);
    logger.info(`ResourceDetails to persist : ${request.body.ResourceDetails.type}`);
    if (request?.body?.Activities && Array.isArray(request?.body?.Activities) && request?.body?.Activities.length > 0) {
        logger.info("Activities to persist : ")
        logger.debug(getFormattedStringForDebug(request?.body?.Activities));
        logger.info(`Waiting for 2 seconds`);
        await new Promise(resolve => setTimeout(resolve, 2000));
        const activities = request?.body?.Activities;
        for (let i = 0; i < activities.length; i += 10) {
            const chunk = activities.slice(i, Math.min(i + 10, activities.length));
            const activityObject: any = { Activities: chunk };
            await produceModifiedMessages(activityObject, config.kafka.KAFKA_CREATE_RESOURCE_ACTIVITY_TOPIC);
        }
    }
}



function getRootBoundaryCode(boundaries: any[] = []) {
    for (const boundary of boundaries) {
        if (boundary.isRoot) {
            return boundary.code;
        }
    }
    return "";
}

function enrichRootProjectId(requestBody: any) {
    var rootBoundary;
    for (const boundary of requestBody?.boundariesCombined) {
        if (boundary?.isRoot) {
            rootBoundary = boundary?.code
            break;
        }
    }
    if (rootBoundary) {
        requestBody.CampaignDetails.projectId = requestBody?.boundaryProjectMapping?.[rootBoundary]?.projectId || null
    }
    requestBody.CampaignDetails.projectId = requestBody.CampaignDetails.projectId || null
}

async function enrichAndPersistCampaignWithError(requestBody: any, error: any) {
    if (requestBody?.parentCampaign) {
        await makeParentInactiveOrActive(requestBody, true)
    }
    requestBody.CampaignDetails = requestBody?.CampaignDetails || {}
    const action = requestBody?.CampaignDetails?.action;
    requestBody.CampaignDetails.campaignNumber = requestBody?.CampaignDetails?.campaignNumber || null
    requestBody.CampaignDetails.campaignDetails = requestBody?.CampaignDetails?.campaignDetails || { deliveryRules: requestBody?.CampaignDetails?.deliveryRules, resources: requestBody?.CampaignDetails?.resources || [], boundaries: requestBody?.CampaignDetails?.boundaries || [] };
    requestBody.CampaignDetails.status = campaignStatuses?.failed;
    // requestBody.CampaignDetails.isActive = false;
    requestBody.CampaignDetails.boundaryCode = getRootBoundaryCode(requestBody?.CampaignDetails?.boundaries) || null
    requestBody.CampaignDetails.projectType = requestBody?.CampaignDetails?.projectType || null;
    requestBody.CampaignDetails.hierarchyType = requestBody?.CampaignDetails?.hierarchyType || null;
    requestBody.CampaignDetails.additionalDetails = requestBody?.CampaignDetails?.additionalDetails || {};
    requestBody.CampaignDetails.startDate = requestBody?.CampaignDetails?.startDate || null
    requestBody.CampaignDetails.endDate = requestBody?.CampaignDetails?.endDate || null
    requestBody.CampaignDetails.auditDetails = {
        createdBy: requestBody?.RequestInfo?.userInfo?.uuid,
        createdTime: Date.now(),
        lastModifiedBy: requestBody?.RequestInfo?.userInfo?.uuid,
        lastModifiedTime: Date.now(),
    }
    if (action == "create" && !requestBody?.CampaignDetails?.projectId) {
        enrichRootProjectId(requestBody);
    }
    else if (!requestBody?.CampaignDetails?.projectId) {
        requestBody.CampaignDetails.projectId = null
    }
    requestBody.CampaignDetails.additionalDetails = {
        ...requestBody?.CampaignDetails?.additionalDetails,
        error: String((error?.message + (error?.description ? ` : ${error?.description}` : '')) || error)
    }
    const topic = config?.kafka?.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC
    // wait for 2 seconds
    logger.info(`Waiting for 2 seconds to persist errors`);
    await new Promise(resolve => setTimeout(resolve, 2000));
    const produceMessage: any = { CampaignDetails: requestBody.CampaignDetails }
    await produceModifiedMessages(produceMessage, topic);
    await persistTrack(requestBody?.CampaignDetails?.id, processTrackTypes.error, processTrackStatuses.failed, { error: String((error?.message + (error?.description ? ` : ${error?.description}` : '')) || error) });
    delete requestBody.CampaignDetails.campaignDetails
}

async function enrichAndPersistCampaignForCreate(request: any, firstPersist: boolean = false) {
    const action = request?.body?.CampaignDetails?.action;
    if (firstPersist) {
        if (!request?.body?.parentCampaign) {
            request.body.CampaignDetails.campaignNumber = await getCampaignNumber(request.body, "CMP-[cy:yyyy-MM-dd]-[SEQ_EG_CMP_ID]", "campaign.number", request?.body?.CampaignDetails?.tenantId);
        }
        else {
            request.body.CampaignDetails.campaignNumber = request.body.parentCampaign?.campaignNumber;
            request.body.CampaignDetails.campaignName = request.body.parentCampaign?.campaignName;
        }
    }
    request.body.CampaignDetails.campaignDetails = { deliveryRules: request?.body?.CampaignDetails?.deliveryRules || [], resources: request?.body?.CampaignDetails?.resources || [], boundaries: request?.body?.CampaignDetails?.boundaries || [] };
    request.body.CampaignDetails.status = action == "create" ? campaignStatuses.started : campaignStatuses.drafted;
    request.body.CampaignDetails.boundaryCode = getRootBoundaryCode(request.body.CampaignDetails.boundaries)
    request.body.CampaignDetails.projectType = request?.body?.CampaignDetails?.projectType || null;
    request.body.CampaignDetails.hierarchyType = request?.body?.CampaignDetails?.hierarchyType || null;
    request.body.CampaignDetails.additionalDetails = request?.body?.CampaignDetails?.additionalDetails || {};
    request.body.CampaignDetails.startDate = request?.body?.CampaignDetails?.startDate || null
    request.body.CampaignDetails.endDate = request?.body?.CampaignDetails?.endDate || null
    request.body.CampaignDetails.auditDetails = {
        createdBy: request?.body?.RequestInfo?.userInfo?.uuid,
        createdTime: Date.now(),
        lastModifiedBy: request?.body?.RequestInfo?.userInfo?.uuid,
        lastModifiedTime: Date.now(),
    }
    if (action == "create" && !request?.body?.CampaignDetails?.projectId && !firstPersist) {
        enrichRootProjectId(request.body);
    }
    else {
        request.body.CampaignDetails.projectId = null
    }
    const topic = firstPersist ? config?.kafka?.KAFKA_SAVE_PROJECT_CAMPAIGN_DETAILS_TOPIC : config?.kafka?.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC
    delete request.body.CampaignDetails.codesTargetMapping
    const produceMessage: any = {
        CampaignDetails: request?.body?.CampaignDetails
    };
    await produceModifiedMessages(produceMessage, topic);
    delete request.body.CampaignDetails.campaignDetails
}

function enrichInnerCampaignDetails(request: any, updatedInnerCampaignDetails: any) {
    updatedInnerCampaignDetails.resources = request?.body?.CampaignDetails?.resources || []
    updatedInnerCampaignDetails.deliveryRules = request?.body?.CampaignDetails?.deliveryRules || []
    updatedInnerCampaignDetails.boundaries = request?.body?.CampaignDetails?.boundaries || []
}


async function enrichAndPersistCampaignForUpdate(request: any, firstPersist: boolean = false) {
    const action = request?.body?.CampaignDetails?.action;
    const boundaries = request?.body?.boundariesCombined
    const existingCampaignDetails = request?.body?.ExistingCampaignDetails;
    callGenerateIfBoundariesOrCampaignTypeDiffer(request);
    if (existingCampaignDetails) {
        if (areBoundariesSame(existingCampaignDetails?.boundaries, boundaries)) {
            updateTargetColumnsIfDeliveryConditionsDifferForSMC(request);
        }
    }
    const ExistingCampaignDetails = request?.body?.ExistingCampaignDetails;
    var updatedInnerCampaignDetails = {}
    enrichInnerCampaignDetails(request, updatedInnerCampaignDetails)
    request.body.CampaignDetails.campaignNumber = ExistingCampaignDetails?.campaignNumber
    request.body.CampaignDetails.campaignDetails = updatedInnerCampaignDetails
    request.body.CampaignDetails.status = action == "changeDates" ? request.body.CampaignDetails.status : (action == "create" ? campaignStatuses.started : campaignStatuses.drafted);
    const boundaryCode = !(request?.body?.CampaignDetails?.projectId) ? getRootBoundaryCode(request.body.CampaignDetails.boundaries) : (request?.body?.CampaignDetails?.boundaryCode || ExistingCampaignDetails?.boundaryCode)
    request.body.CampaignDetails.boundaryCode = boundaryCode
    request.body.CampaignDetails.startDate = request?.body?.CampaignDetails?.startDate || ExistingCampaignDetails?.startDate || null
    request.body.CampaignDetails.endDate = request?.body?.CampaignDetails?.endDate || ExistingCampaignDetails?.endDate || null
    request.body.CampaignDetails.projectType = request?.body?.CampaignDetails?.projectType ? request?.body?.CampaignDetails?.projectType : ExistingCampaignDetails?.projectType
    request.body.CampaignDetails.hierarchyType = request?.body?.CampaignDetails?.hierarchyType ? request?.body?.CampaignDetails?.hierarchyType : ExistingCampaignDetails?.hierarchyType
    request.body.CampaignDetails.additionalDetails = request?.body?.CampaignDetails?.additionalDetails ? request?.body?.CampaignDetails?.additionalDetails : ExistingCampaignDetails?.additionalDetails
    request.body.CampaignDetails.auditDetails = {
        createdBy: ExistingCampaignDetails?.createdBy,
        createdTime: ExistingCampaignDetails?.createdTime,
        lastModifiedBy: request?.body?.RequestInfo?.userInfo?.uuid,
        lastModifiedTime: Date.now(),
    }
    if (action == "create" && !request?.body?.CampaignDetails?.projectId) {
        enrichRootProjectId(request.body);
    }
    else {
        request.body.CampaignDetails.projectId = request?.body?.CampaignDetails?.projectId || ExistingCampaignDetails?.projectId || null
    }
    delete request.body.CampaignDetails.codesTargetMapping
    const producerMessage: any = {
        CampaignDetails: request?.body?.CampaignDetails
    }
    await produceModifiedMessages(producerMessage, config?.kafka?.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC);
    delete request.body.ExistingCampaignDetails
    delete request.body.CampaignDetails.campaignDetails
}

async function makeParentInactiveOrActive(requestBody: any, active: boolean) {
    let parentCampaign = requestBody?.parentCampaign
    parentCampaign.isActive = active
    parentCampaign.campaignDetails = { deliveryRules: parentCampaign?.deliveryRules || [], resources: parentCampaign?.resources || [], boundaries: parentCampaign?.boundaries || [] };
    parentCampaign.auditDetails.lastModifiedTime = Date.now()
    parentCampaign.auditDetails.lastModifiedBy = requestBody?.RequestInfo?.userInfo?.uuid
    const produceMessage: any = {
        CampaignDetails: parentCampaign
    }
    await produceModifiedMessages(produceMessage, config?.kafka?.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC);
}

function getCreateResourceIds(resources: any[]) {
    return resources
        .filter((resource: any) => typeof resource.createResourceId === 'string' && resource.createResourceId.trim() !== '')
        .map((resource: any) => {
            const resourceId = resource.createResourceId;
            return resourceId;
        });
}

async function persistForCampaignProjectMapping(request: any, createResourceDetailsIds: any, localizationMap?: any) {
    if (createResourceDetailsIds && request?.body?.CampaignDetails?.projectId) {
        var requestBody: any = {
            RequestInfo: request?.body?.RequestInfo,
            Campaign: {}
        }
        requestBody.Campaign.id = request?.body?.CampaignDetails?.id
        requestBody.Campaign.newlyCreatedBoundaryProjectMap = request?.body?.newlyCreatedBoundaryProjectMap
        requestBody.Campaign.hierarchyType = request?.body?.CampaignDetails?.hierarchyType
        requestBody.Campaign.tenantId = request?.body?.CampaignDetails?.tenantId
        requestBody.Campaign.campaignName = request?.body?.CampaignDetails?.campaignName
        requestBody.Campaign.boundaryCode = request?.body?.CampaignDetails?.boundaryCode
        requestBody.Campaign.startDate = request?.body?.CampaignDetails?.startDate
        requestBody.Campaign.endDate = request?.body?.CampaignDetails?.endDate
        requestBody.Campaign.projectType = request?.body?.CampaignDetails?.projectType
        requestBody.Campaign.additionalDetails = request?.body?.CampaignDetails?.additionalDetails
        requestBody.Campaign.deliveryRules = request?.body?.CampaignDetails?.deliveryRules
        requestBody.Campaign.rootProjectId = request?.body?.CampaignDetails?.projectId
        requestBody.Campaign.resourceDetailsIds = createResourceDetailsIds
        requestBody.CampaignDetails = request?.body?.CampaignDetails
        requestBody.parentCampaign = request?.body?.parentCampaign;
        var updatedInnerCampaignDetails = {}
        enrichInnerCampaignDetails(request, updatedInnerCampaignDetails)
        requestBody.CampaignDetails = request?.body?.CampaignDetails
        requestBody.CampaignDetails.campaignDetails = updatedInnerCampaignDetails
        // requestBody.localizationMap = localizationMap
        logger.info("Persisting CampaignProjectMapping...");
        logger.debug(`CampaignProjectMapping: ${getFormattedStringForDebug(requestBody)}`);
        await produceModifiedMessages(requestBody, config?.kafka?.KAFKA_START_CAMPAIGN_MAPPING_TOPIC);
    }
}

function removeBoundariesFromRequest(request: any) {
    const boundaries = request?.body?.CampaignDetails?.boundaries;
    if (boundaries && Array.isArray(boundaries) && boundaries?.length > 0) {
        request.body.CampaignDetails.boundaries = boundaries?.filter((boundary: any) => !boundary?.insertedAfter)
    }
}

async function enrichAndPersistProjectCampaignForFirst(request: any, actionInUrl: any, firstPersist: boolean = false, localizationMap?: any) {
    removeBoundariesFromRequest(request);
    if (actionInUrl == "create") {
        await enrichAndPersistCampaignForCreate(request, firstPersist)
    }
    else if (actionInUrl == "update") {
        await enrichAndPersistCampaignForUpdate(request, firstPersist)
    }
    if (request?.body?.parentCampaign?.isActive) {
        await makeParentInactiveOrActive(request?.body, false)
    }
    if (request?.body?.CampaignDetails?.action == "create") {
        await createProcessTracks(request.body.CampaignDetails.id)
    }
}


async function enrichAndPersistProjectCampaignRequest(request: any, actionInUrl: any, firstPersist: boolean = false, localizationMap?: any) {
    var createResourceDetailsIds: any[] = []
    if (request?.body?.CampaignDetails?.resources && Array.isArray(request?.body?.CampaignDetails?.resources) && request?.body?.CampaignDetails?.resources?.length > 0 && request?.body?.CampaignDetails?.action == "create") {
        createResourceDetailsIds = getCreateResourceIds(request?.body?.CampaignDetails?.resources);
    }
    // removeBoundariesFromRequest(request);
    if (actionInUrl == "create") {
        await enrichAndPersistCampaignForCreate(request, firstPersist)
    }
    else if (actionInUrl == "update") {
        await enrichAndPersistCampaignForUpdate(request, firstPersist)
    }
    if (request?.body?.CampaignDetails?.action == "create") {
        await persistForCampaignProjectMapping(request, createResourceDetailsIds, localizationMap);
    }
}

function getChildParentMap(modifiedBoundaryData: any) {
    const childParentMap: Map<{ key: string, value: string }, { key: string, value: string } | null> = new Map();

    modifiedBoundaryData.forEach((row: any) => {
        for (let j = row.length - 1; j >= 0; j--) {
            const child = row[j];
            const parent = j - 1 >= 0 ? row[j - 1] : null;
            const childIdentifier = { key: child.key, value: child.value }; // Unique identifier for the child
            const parentIdentifier = parent ? { key: parent.key, value: parent.value } : null; // Unique identifier for the parent, set to null if parent doesn't exist


            // Check if the mapping already exists in the childParentMap
            const existingMapping = Array.from(childParentMap.entries()).find(([existingChild, existingParent]) =>
                _.isEqual(existingChild, childIdentifier) && _.isEqual(existingParent, parentIdentifier)
            );

            // If the mapping doesn't exist, add it to the childParentMap
            if (!existingMapping) {
                childParentMap.set(childIdentifier, parentIdentifier);
            }
        }
    });
    return childParentMap;
}






function getCodeMappingsOfExistingBoundaryCodes(withBoundaryCode: any[]) {
    const countMap = new Map<{ key: string, value: string }, number>();
    const mappingMap = new Map<{ key: string, value: string }, string>();

    withBoundaryCode.forEach((row: any[]) => {
        const len = row.length;
        if (len >= 3) {
            let grandParentFound = false;
            const grandParent = row[len - 3];
            if (findMapValue(mappingMap, grandParent)) {
                const countMapArray = Array.from(countMap.entries());
                for (const [key, value] of countMapArray) {
                    if (_.isEqual(key, grandParent)) {
                        countMap.set(key, value + 1);
                        grandParentFound = true;
                        break;
                    }
                }
                if (grandParentFound == false) {
                    countMap.set(grandParent, 1);
                }
            }
        }
        mappingMap.set(row[len - 2], row[len - 1].value);
    });
    return { mappingMap, countMap };
}


function addBoundaryCodeToData(withBoundaryCode: any[], withoutBoundaryCode: any[], boundaryMap: Map<any, any>) {
    const boundaryDataWithBoundaryCode = withBoundaryCode;
    const modifiedBoundaryDataWithBoundaryCode = boundaryDataWithBoundaryCode.map((array) => {
        return array.map((obj: any) => {
            if (obj.key === 'Boundary Code') {
                return obj.value;
            } else {
                return obj;
            }
        });
    });

    const boundaryDataForWithoutBoundaryCode = withoutBoundaryCode.map((row: any[]) => {
        const boundaryName = row[row.length - 1]; // Get the last element of the row
        const boundaryCode = findMapValue(boundaryMap, boundaryName); // Fetch corresponding boundary code from map
        return [...row, boundaryCode]; // Append boundary code to the row and return updated row
    });
    const boundaryDataForSheet = [...modifiedBoundaryDataWithBoundaryCode, ...boundaryDataForWithoutBoundaryCode];
    return boundaryDataForSheet;
}

function prepareDataForExcel(boundaryDataForSheet: any, hierarchy: any[], boundaryMap: any) {
    const data = boundaryDataForSheet.map((boundary: any[]) => {
        const boundaryCode = boundary.pop();
        const boundaryValues = boundary.map(obj => obj.value);
        const rowData = boundaryValues.concat(Array(Math.max(0, hierarchy.length - boundary.length)).fill(''));
        const boundaryCodeIndex = hierarchy.length;
        rowData[boundaryCodeIndex] = boundaryCode;
        return rowData;
    });
    return data;
}
function extractCodesFromBoundaryRelationshipResponse(boundaries: any[]): any {
    const codes = new Set();
    for (const boundary of boundaries) {
        codes.add(boundary.code); // Add code to the Set
        if (boundary.children && boundary.children.length > 0) {
            const childCodes = extractCodesFromBoundaryRelationshipResponse(boundary.children); // Recursively get child codes
            childCodes.forEach((code: any) => codes.add(code)); // Add child codes to the Set
        }
    }
    return codes;
}


async function getTotalCount(request: any) {
    const CampaignDetails = request.body.CampaignDetails;
    const { tenantId, pagination, ids, ...searchFields } = CampaignDetails;
    let conditions = [];
    let values = [tenantId];
    let index = 2;
    const campaignsIncludeDates = searchFields?.campaignsIncludeDates

    for (const field in searchFields) {
        if (searchFields[field] !== undefined && field != 'campaignsIncludeDates') {
            if (field === 'startDate') {
                const startDateSign = campaignsIncludeDates ? '<=' : '>=';
                conditions.push(`startDate ${startDateSign} $${index}`);
                values.push(searchFields[field]);
                index++;
            } else if (field === 'endDate') {
                const endDateSign = campaignsIncludeDates ? '>=' : '<=';
                conditions.push(`endDate ${endDateSign} $${index}`);
                values.push(searchFields[field]);
                index++;
            } else if (field === 'campaignName') {
                conditions.push(`${field} ILIKE '%' || $${index} || '%'`);
                values.push(searchFields[field]);
                index++;
            } else if (field != 'status') {
                conditions.push(`${field} = $${index}`);
                values.push(searchFields[field]);
                index++;
            }
        }
    }

    let query = `
        SELECT count(*)
        FROM ${config?.DB_CONFIG.DB_CAMPAIGN_DETAILS_TABLE_NAME}
        WHERE tenantId = $1
    `;

    if (ids && ids.length > 0) {
        const idParams = ids.map((id: any, i: any) => `$${index + i}`);
        query += ` AND id IN (${idParams.join(', ')})`;
        values.push(...ids);
        index = index + ids.length;
    }
    else {
        // If no IDs are provided, filter by isActive = true
        query += ` AND isActive = true`;
    }
    var status = searchFields?.status;
    if (status) {
        if (typeof status === 'string') {
            status = [status]; // Convert string to array
        }
        const statusParams = status.map((param: any, i: any) => `$${index + i}`); // Increment index for each parameter
        query += ` AND status IN (${statusParams.join(', ')})`;
        values.push(...status);
    }

    if (conditions.length > 0) {
        query += ` AND ${conditions.join(' AND ')}`;
    }
    const queryResult = await executeQuery(query, values);
    const totalCount = parseInt(queryResult.rows[0].count, 10);
    request.body.totalCount = totalCount;
}




async function searchProjectCampaignResourcData(request: any) {
    const CampaignDetails = request.body.CampaignDetails;
    const { tenantId, pagination, ids, ...searchFields } = CampaignDetails;
    const queryData = buildSearchQuery(tenantId, pagination, ids, searchFields);
    await getTotalCount(request)
    const responseData: any[] = await executeSearchQuery(queryData.query, queryData.values);
    // TODO @ashish check the below code looks like duplicate
    for (const data of responseData) {
        data.resources = data?.campaignDetails?.resources
        data.boundaries = data?.campaignDetails?.boundaries
        data.deliveryRules = data?.campaignDetails?.deliveryRules;
        delete data.campaignDetails;
        data.auditDetails = {
            createdBy: data?.createdBy,
            lastModifiedBy: data?.lastModifiedBy,
            createdTime: data?.createdTime,
            lastModifiedTime: data?.lastModifiedTime
        }
        delete data.createdBy;
        delete data.lastModifiedBy;
        delete data.createdTime;
        delete data.lastModifiedTime;
    }
    request.body.CampaignDetails = responseData;
}

function buildSearchQuery(tenantId: string, pagination: any, ids: string[], searchFields: any): { query: string, values: any[] } {
    let conditions = [];
    let values = [tenantId];
    let index = 2;
    const campaignsIncludeDates = searchFields?.campaignsIncludeDates

    for (const field in searchFields) {
        if (searchFields[field] !== undefined && field != 'campaignsIncludeDates') {
            if (field === 'startDate') {
                const startDateSign = campaignsIncludeDates ? '<=' : '>=';
                conditions.push(`startDate ${startDateSign} $${index}`);
                values.push(searchFields[field]);
                index++;
            } else if (field === 'endDate') {
                const endDateSign = campaignsIncludeDates ? '>=' : '<=';
                conditions.push(`endDate ${endDateSign} $${index}`);
                values.push(searchFields[field]);
                index++;
            } else if (field === 'campaignName') {
                conditions.push(`${field} ILIKE '%' || $${index} || '%'`);
                values.push(searchFields[field]);
                index++;
            } else if (field != 'status') {
                conditions.push(`${field} = $${index}`);
                values.push(searchFields[field]);
                index++;
            }
        }
    }

    let query = `
        SELECT *
        FROM ${config?.DB_CONFIG.DB_CAMPAIGN_DETAILS_TABLE_NAME}
        WHERE tenantId = $1
    `;

    if (ids && ids.length > 0) {
        const idParams = ids.map((id: any, i: any) => `$${index + i}`);
        query += ` AND id IN (${idParams.join(', ')})`;
        values.push(...ids);
        index = index + ids.length;
    } else {
        // If no IDs are provided, filter by isActive = true
        query += ` AND isActive = true`;
    }

    var status = searchFields?.status;
    if (status) {
        if (typeof status === 'string') {
            status = [status]; // Convert string to array
        }
        const statusParams = status.map((param: any, i: any) => `$${index + i}`); // Increment index for each parameter
        query += ` AND status IN (${statusParams.join(', ')})`;
        values.push(...status);
    }

    if (conditions.length > 0) {
        query += ` AND ${conditions.join(' AND ')}`;
    }

    if (pagination) {
        query += '\n';

        if (pagination.sortBy) {
            query += `ORDER BY ${pagination.sortBy}`;
            if (pagination.sortOrder) {
                query += ` ${pagination.sortOrder.toUpperCase()}`;
            }
            query += '\n';
        }

        if (pagination.limit !== undefined) {
            query += `LIMIT ${pagination.limit}`;
            if (pagination.offset !== undefined) {
                query += ` OFFSET ${pagination.offset}`;
            }
            query += '\n';
        }
    }

    return { query, values };
}



async function executeSearchQuery(query: string, values: any[]) {
    const queryResult = await executeQuery(query, values);
    return campaignDetailsTransformer(queryResult?.rows);
}

async function processDataSearchRequest(request: any) {
    const { SearchCriteria } = request.body;
    const query = buildWhereClauseForDataSearch(SearchCriteria);
    const queryResult = await executeQuery(query.query, query.values);
    request.body.ResourceDetails = genericResourceTransformer(queryResult?.rows);;
}


function buildWhereClauseForDataSearch(SearchCriteria: any): { query: string; values: any[] } {
    const { id, tenantId, type, status, hierarchyType } = SearchCriteria;
    let conditions = [];
    let values = [];

    // Check for id
    if (id && id.length > 0) {
        conditions.push(`id = ANY($${values.length + 1})`);
        values.push(id);
    }

    // Check for tenantId
    if (tenantId) {
        conditions.push(`tenantId = $${values.length + 1}`);
        values.push(tenantId);
    }

    // Check for type
    if (type) {
        conditions.push(`type = $${values.length + 1}`);
        values.push(type);
    }

    // Check for status
    if (status) {
        conditions.push(`status = $${values.length + 1}`);
        values.push(status);
    }

    // Check for hierarchyType
    if (hierarchyType) {
        conditions.push(`hierarchyType = $${values.length + 1}`);
        values.push(hierarchyType);
    }

    // Build the WHERE clause
    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

    // Return the query and values array
    return {
        query: `
            SELECT *
            FROM ${config?.DB_CONFIG.DB_RESOURCE_DETAILS_TABLE_NAME}
            ${whereClause};`,
        values
    };
}


function mapBoundariesParent(boundaryResponse: any, request: any, parent: any) {
    if (!boundaryResponse) return;

    request.body.boundaryProjectMapping[boundaryResponse.code] = {
        parent: parent || null,
        projectId: null
    }
    if (boundaryResponse?.children && Array.isArray(boundaryResponse?.children) && boundaryResponse?.children?.length > 0) {
        for (const child of boundaryResponse.children) {
            mapBoundariesParent(child, request, boundaryResponse.code);
        }
    }
}

function mapTargets(boundaryResponses: any, codesTargetMapping: any) {
    if (!boundaryResponses || !codesTargetMapping) return;

    for (const boundaryResponse of boundaryResponses) {
        const mapBoundary = (boundary: any) => {
            if (!boundary.children || boundary.children.length === 0) {
                const targetValue = codesTargetMapping[boundary.code];
                return targetValue ? targetValue : 0;
            }

            let totalTargetValue = 0;
            for (const child of boundary.children) {
                const childTargetValue = mapBoundary(child);
                totalTargetValue += childTargetValue;
            }
            codesTargetMapping[boundary.code] = totalTargetValue;
            return totalTargetValue;
        };
        mapBoundary(boundaryResponse);
    }
}


async function processBoundary(boundaryResponse: any, boundaries: any, includeAllChildren: any, boundaryCodes: any, boundaryChildren: any) {
    if (!boundaryResponse) return;
    if (!boundaryCodes.has(boundaryResponse.code)) {
        boundaries.push({ code: boundaryResponse?.code, type: boundaryResponse?.boundaryType, insertedAfter: true });
        boundaryCodes.add(boundaryResponse?.code);
    }
    if (includeAllChildren && boundaryResponse?.children && Array.isArray(boundaryResponse?.children) && boundaryResponse?.children?.length > 0) {
        for (const child of boundaryResponse.children) {
            processBoundary(child, boundaries, true, boundaryCodes, boundaryChildren);
        }
    }
    else if (boundaryResponse?.children && Array.isArray(boundaryResponse?.children) && boundaryResponse?.children?.length > 0) {
        for (const child of boundaryResponse.children) {
            if (boundaryCodes.has(child.code) && boundaryChildren[child.code]) {
                processBoundary(child, boundaries, true, boundaryCodes, boundaryChildren);
            }
            else if (boundaryCodes.has(child.code)) {
                processBoundary(child, boundaries, false, boundaryCodes, boundaryChildren);
            }
        }
    }
}

async function addBoundaries(request: any, boundaryResponse: any, boundaryChildren: any) {
    var boundaries = request?.body?.boundariesCombined
    var boundaryCodes = new Set(boundaries.map((boundary: any) => boundary.code));
    await processBoundary(boundaryResponse, boundaries, boundaryChildren[boundaryResponse?.code], boundaryCodes, boundaryChildren);
    request.body.boundariesCombined = boundaries
}

async function addBoundariesForData(request: any, CampaignDetails: any) {
    // var { boundaries } = CampaignDetails;
    var boundaries = await getBoundariesFromCampaignSearchResponse(request, CampaignDetails);
    const rootBoundary = getRootBoundaryCode(boundaries)
    if (rootBoundary) {
        const params = {
            tenantId: request?.body?.ResourceDetails?.tenantId,
            codes: rootBoundary,
            hierarchyType: request?.body?.ResourceDetails?.hierarchyType,
            includeChildren: true
        }
        const header = {
            ...defaultheader,
            cachekey: `boundaryRelationShipSearch${params?.hierarchyType}${params?.tenantId}${params.codes || ''}${params?.includeChildren || ''}`,
        }
        const boundaryResponse = await httpRequest(config.host.boundaryHost + config.paths.boundaryRelationship, request.body, params, undefined, undefined, header);
        if (boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0]) {
            var boundaryChildren = boundaries.reduce((acc: any, boundary: any) => {
                acc[boundary.code] = boundary?.includeAllChildren;
                return acc;
            }, {});
            var boundaryCodes = new Set(boundaries.map((boundary: any) => boundary.code));
            await processBoundary(boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0], boundaries, boundaryChildren[boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0]?.code], boundaryCodes, boundaryChildren);
            CampaignDetails.boundaries = boundaries
        }
        else {
            throwError("COMMON", 500, "INTERNAL_SERVER_ERROR", "Some internal server error occured during boundary validation.");
        }
    }
    else {
        throwError("COMMON", 500, "INTERNAL_SERVER_ERROR", "There is no root boundary for this campaign.");
    }
}

function reorderBoundariesWithParentFirst(reorderedBoundaries: any[], boundaryProjectMapping: any) {
    // Function to get the index of a boundary in the original boundaries array
    function getIndex(code: any, boundaries: any[]) {
        return reorderedBoundaries.findIndex((boundary: any) => boundary.code === code);
    }
    // Reorder boundaries so that parents come first
    for (let i = 0; i < 2 * (reorderedBoundaries?.length); i++) {
        for (const boundary of reorderedBoundaries) {
            const parentCode = boundaryProjectMapping[boundary.code]?.parent;
            if (parentCode) {
                const parentIndex = getIndex(parentCode, reorderedBoundaries);
                const boundaryIndex = getIndex(boundary.code, reorderedBoundaries);

                if (parentIndex !== -1 && boundaryIndex !== -1 && parentIndex > boundaryIndex) {
                    reorderedBoundaries.splice(parentIndex + 1, 0, reorderedBoundaries.splice(boundaryIndex, 1)[0]);
                    break;
                }
            }
        }
    }
}

async function reorderBoundariesOfDataAndValidate(request: any, localizationMap?: any) {
    if (request?.body?.ResourceDetails?.campaignId) {
        const searchBody = {
            RequestInfo: request?.body?.RequestInfo,
            CampaignDetails: {
                ids: [request?.body?.ResourceDetails?.campaignId],
                tenantId: request?.body?.ResourceDetails?.tenantId
            }
        }
        const req: any = replicateRequest(request, searchBody)
        const response = await searchProjectTypeCampaignService(req)
        if (response?.CampaignDetails?.[0]) {
            const CampaignDetails = response?.CampaignDetails?.[0]
            await addBoundariesForData(request, CampaignDetails)
            logger.debug("Boundaries after addition " + getFormattedStringForDebug(CampaignDetails?.boundaries));
            await validateBoundaryOfResouces(CampaignDetails, request, localizationMap)
        }
        else {
            throwError("CAMPAIGN", 400, "CAMPAIGN_NOT_FOUND", "Campaign not found while Validating sheet boundaries");
        }
    }
}

async function reorderBoundaries(request: any, localizationMap?: any) {
    // var { boundaries } = request?.body?.CampaignDetails;
    var boundaries = request?.body?.boundariesCombined
    const rootBoundary = getRootBoundaryCode(boundaries)
    request.body.boundaryProjectMapping = {}
    if (rootBoundary) {
        const params = {
            tenantId: request?.body?.CampaignDetails?.tenantId,
            codes: rootBoundary,
            hierarchyType: request?.body?.CampaignDetails?.hierarchyType,
            includeChildren: true
        }
        const header = {
            ...defaultheader,
            cachekey: `boundaryRelationShipSearch${params?.hierarchyType}${params?.tenantId}${params.codes || ''}${params?.includeChildren || ''}`,
        }
        const boundaryResponse = await httpRequest(config.host.boundaryHost + config.paths.boundaryRelationship, request.body, params, undefined, undefined, header);
        if (boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0]) {
            const codesTargetMapping = await getCodesTarget(request, localizationMap)
            if (codesTargetMapping) {
                mapTargets(boundaryResponse?.TenantBoundary?.[0]?.boundary, codesTargetMapping)
                request.body.CampaignDetails.codesTargetMapping = codesTargetMapping
                logger.debug("codesTargetMapping mapping :: " + getFormattedStringForDebug(codesTargetMapping));
            }
            mapBoundariesParent(boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0], request, null)
            var boundaryChildren = boundaries.reduce((acc: any, boundary: any) => {
                acc[boundary.code] = boundary?.includeAllChildren;
                return acc;
            }, {});
            await addBoundaries(request, boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0], boundaryChildren)
        }
        else {
            throwError("COMMON", 500, "INTERNAL_SERVER_ERROR", "Some internal server error occured during boundary validation.");
        }
    }
    else {
        throwError("COMMON", 500, "INTERNAL_SERVER_ERROR", "There is no root boundary for this campaign.");
    }
    logger.info("Boundaries for campaign creation in received")
    logger.debug("Boundaries after addition " + getFormattedStringForDebug(request?.body?.boundariesCombined));
    reorderBoundariesWithParentFirst(request?.body?.boundariesCombined, request?.body?.boundaryProjectMapping)
    logger.info("Reordered the Boundaries for mapping");
    logger.debug("Reordered Boundaries " + getFormattedStringForDebug(request?.body?.boundariesCombined));
}

function convertToProjectsArray(Projects: any, currentArray: any = []) {
    for (const project of Projects) {
        const descendants = project?.descendants
        delete project?.descendants
        currentArray.push(project);
        if (descendants && Array.isArray(descendants) && descendants?.length > 0) {
            convertToProjectsArray(descendants, currentArray)
        }
    }
    return currentArray;
}

async function getRelatedProjects(request: any) {
    const { projectId, tenantId } = request?.body?.CampaignDetails;
    const projectSearchBody = {
        RequestInfo: request?.body?.RequestInfo,
        Projects: [
            {
                id: projectId,
                tenantId: tenantId
            }
        ]
    }
    const projectSearchParams = {
        tenantId: tenantId,
        offset: 0,
        limit: 1,
        includeDescendants: true
    }
    logger.info("Project search params " + JSON.stringify(projectSearchParams))
    const projectSearchResponse = await httpRequest(config?.host?.projectHost + config?.paths?.projectSearch, projectSearchBody, projectSearchParams);
    if (projectSearchResponse?.Project && Array.isArray(projectSearchResponse?.Project) && projectSearchResponse?.Project?.length > 0) {
        return convertToProjectsArray(projectSearchResponse?.Project)
    }
    else {
        throwError("PROJECT", 500, "PROJECT_SEARCH_ERROR")
        return []
    }
}

async function updateProjectDates(request: any, actionInUrl: any) {
    const { startDate, endDate, projectId } = request?.body?.CampaignDetails
    if ((startDate || endDate) && projectId && actionInUrl == "update") {
        const projects = await getRelatedProjects(request);
        for (const project of projects) {
            project.startDate = startDate || project.startDate;
            project.endDate = endDate || project.endDate;
            delete project?.address;
        }
        logger.info("Projects related to current Campaign : " + JSON.stringify(projects));
        const projectUpdateBody = {
            RequestInfo: request?.body?.RequestInfo,
            Projects: projects
        }
        const projectUpdateResponse = await httpRequest(config?.host?.projectHost + config?.paths?.projectUpdate, projectUpdateBody);
        if (projectUpdateResponse?.Project && Array.isArray(projectUpdateResponse?.Project) && projectUpdateResponse?.Project?.length == projects?.length) {
            logger.info("Project dates updated successfully")
        }
        else {
            throwError("PROJECT", 500, "PROJECT_UPDATE_ERROR")
        }
    }
}

async function getCodesTarget(request: any, localizationMap?: any) {
    let boundaryCodesWhoseTargetsHasToBeUpdated: any = [];
    const { tenantId, resources } = request?.body?.CampaignDetails;
    const boundaryWithTargetResource = resources?.filter((resource: any) => resource?.type == "boundaryWithTarget");
    if (boundaryWithTargetResource && boundaryWithTargetResource.length > 0) {
        const fileId = boundaryWithTargetResource[0]?.filestoreId
        const fileResponse = await httpRequest(config.host.filestore + config.paths.filestore + "/url", {}, { tenantId: tenantId, fileStoreIds: fileId }, "get");
        if (!fileResponse?.fileStoreIds?.[0]?.url) {
            throwError("FILE", 500, "DOWNLOAD_URL_NOT_FOUND");
        }
        const codeColumnName = getLocalizedName(createAndSearch?.boundaryWithTarget?.boundaryValidation?.column, localizationMap)
        const targetData = await getTargetSheetDataAfterCode(request, fileResponse?.fileStoreIds?.[0]?.url, true, true, codeColumnName);
        const boundaryTargetMapping: any = {};
        // Iterate through each key in targetData
        for (const key in targetData) {
            // Iterate through each entry in the array under the current key
            targetData[key].forEach(entry => {
                // Check if the entry has both "Boundary Code" and "Target at the Selected Boundary level"
                if (entry[codeColumnName] !== undefined && entry['Target at the Selected Boundary level'] !== undefined) {
                    // Add the mapping to the boundaryTargetMapping object
                    boundaryTargetMapping[entry[codeColumnName]] = entry['Target at the Selected Boundary level'];
                    if (entry['Parent Target at the Selected Boundary level'] !== 0 &&
                        entry['Parent Target at the Selected Boundary level'] !== entry['Target at the Selected Boundary level']) {
                        boundaryCodesWhoseTargetsHasToBeUpdated.push(entry[codeColumnName]);
                    }
                }
            });
        }
        logger.info("Boundary target mapping count" + Object.keys(boundaryTargetMapping)?.length);
        request.body.boundaryCodesWhoseTargetsHasToBeUpdated = boundaryCodesWhoseTargetsHasToBeUpdated;
        return boundaryTargetMapping;
    } else return null;
}

async function createProject(request: any, actionUrl: any, localizationMap?: any) {
    await persistTrack(request.body.CampaignDetails.id, processTrackTypes.targetAndDeliveryRulesCreation, processTrackStatuses.inprogress);
    try {
        logger.info("Create Projects started for the given Campaign")
        var { tenantId, projectType, projectId } = request?.body?.CampaignDetails;
        var boundaries = request?.body?.boundariesCombined;
        if (boundaries && projectType && !projectId) {
            const projectTypeResponse = await getMDMSV1Data({}, 'HCM-PROJECT-TYPES', "projectTypes", tenantId);
            var Projects: any = enrichProjectDetailsFromCampaignDetails(request?.body?.CampaignDetails, projectTypeResponse?.filter((types: any) => types?.code == projectType)?.[0]);
            const projectCreateBody = {
                RequestInfo: request?.body?.RequestInfo,
                Projects
            }
            await reorderBoundaries(request, localizationMap)
            let boundariesAlreadyWithProjects: any;
            if (request?.body?.parentCampaign) {
                // make search to project with root project id 
                const projectSearchResponse = await fetchProjectsWithParentRootProjectId(request)
                boundariesAlreadyWithProjects = getBoundaryProjectMappingFromParentCampaign(request, projectSearchResponse?.Project?.[0])
            }

            const boundaryCodesWhoseTargetsHasToBeUpdated = request?.body?.boundaryCodesWhoseTargetsHasToBeUpdated;
            if (boundaryCodesWhoseTargetsHasToBeUpdated) {
                for (const boundary of boundaryCodesWhoseTargetsHasToBeUpdated) {
                    if (boundariesAlreadyWithProjects && boundariesAlreadyWithProjects.size > 0 && boundariesAlreadyWithProjects.has(boundary)) {
                        const projectSearchResponse = await fetchProjectsWithBoundaryCodeAndName(boundary, tenantId, request?.body?.CampaignDetails?.campaignName, request?.body?.RequestInfo);
                        const projectToUpdate = projectSearchResponse?.Project?.[0];
                        if (projectToUpdate) {
                            const filteredTargets = projectToUpdate.targets.filter((e: any) => e.beneficiaryType == request?.body?.CampaignDetails?.additionalDetails?.beneficiaryType);
                            if (filteredTargets.length == 0) {
                                projectToUpdate.targets = [
                                    {
                                        beneficiaryType: request?.body?.CampaignDetails?.additionalDetails?.beneficiaryType,
                                        totalNo: request?.body?.CampaignDetails?.codesTargetMapping[boundary],
                                        targetNo: request?.body?.CampaignDetails?.codesTargetMapping[boundary]
                                    }
                                ]
                            } else {
                                const targetobj = filteredTargets[0];
                                targetobj.totalNo = request?.body?.CampaignDetails?.codesTargetMapping[boundary],
                                    targetobj.targetNo = request?.body?.CampaignDetails?.codesTargetMapping[boundary]
                                projectToUpdate.targets = [targetobj];
                            }
                            const projectUpdateBody = {
                                RequestInfo: request?.body?.RequestInfo,
                                Projects: [projectToUpdate]
                            };

                            await projectUpdateForTargets(projectUpdateBody, request, boundary);
                        }
                    }
                }
            }
            delete request.body.boundaryCodesWhoseTargetsHasToBeUpdated;
            for (const boundary of boundaries) {
                const boundaryCode = boundary?.code;
                // Only proceed if the boundary code is not already mapped to an existing project
                if (!boundariesAlreadyWithProjects || (boundariesAlreadyWithProjects.size > 0 && !boundariesAlreadyWithProjects.has(boundaryCode))) {
                    // Set the address for the project
                    Projects[0].address = {
                        tenantId: tenantId,
                        boundary: boundaryCode,
                        boundaryType: boundary?.type
                    };

                    // Handle parent project assignment if present in boundaryProjectMapping
                    const parent = request?.body?.boundaryProjectMapping?.[boundaryCode]?.parent;
                    const parentProjectId = request?.body?.boundaryProjectMapping?.[parent]?.projectId;

                    if (parent && parentProjectId) {
                        await confirmProjectParentCreation(request, parentProjectId);
                        Projects[0].parent = parentProjectId;
                    } else {
                        Projects[0].parent = null;
                    }

                    // Set the reference ID and project targets
                    Projects[0].referenceID = request?.body?.CampaignDetails?.id;
                    Projects[0].department = request?.body?.CampaignDetails?.campaignName,
                        Projects[0].targets = [
                            {
                                beneficiaryType: request?.body?.CampaignDetails?.additionalDetails?.beneficiaryType,
                                totalNo: request?.body?.CampaignDetails?.codesTargetMapping[boundaryCode],
                                targetNo: request?.body?.CampaignDetails?.codesTargetMapping[boundaryCode]
                            }
                        ];
                    await projectCreate(projectCreateBody, request);
                }
            }
        }
    } catch (error: any) {
        console.log(error)
        await persistTrack(request?.body?.CampaignDetails?.id, processTrackTypes.targetAndDeliveryRulesCreation, processTrackStatuses.failed, { error: String((error?.message + (error?.description ? ` : ${error?.description}` : '')) || error) });
        throw new Error(error)
    }
    await persistTrack(request?.body?.CampaignDetails?.id, processTrackTypes.targetAndDeliveryRulesCreation, processTrackStatuses.completed);
}


async function processAfterPersist(request: any, actionInUrl: any) {
    try {
        const localizationMap = await getLocalizedMessagesHandler(request, request?.body?.CampaignDetails?.tenantId);
        if (request?.body?.CampaignDetails?.action == "create") {
            await persistTrack(request.body.CampaignDetails.id, processTrackTypes.validation, processTrackStatuses.completed);
            await createProjectCampaignResourcData(request);
            await createProject(request, actionInUrl, localizationMap)
            await enrichAndPersistProjectCampaignRequest(request, actionInUrl, false, localizationMap)
        }
        else {
            await updateProjectDates(request, actionInUrl);
            await enrichAndPersistProjectCampaignRequest(request, actionInUrl, false, localizationMap)
        }
    } catch (error: any) {
        console.log(error)
        logger.error(error)
        await enrichAndPersistCampaignWithError(request?.body, error)
    }
}

async function processBasedOnAction(request: any, actionInUrl: any) {
    if (actionInUrl == "create") {
        request.body.CampaignDetails.id = uuidv4()
    }
    await enrichAndPersistProjectCampaignForFirst(request, actionInUrl, true)
    if (actionInUrl == "create" && request.body?.parentCampaign && request?.body?.CampaignDetails?.action === 'draft') {
        callGenerateWhenChildCampaigngetsCreated(request);
    }
    processAfterPersist(request, actionInUrl)
}


async function getLocalizedHierarchy(request: any, localizationMap: any) {
    var hierarchy = await getHierarchy(request, request?.query?.tenantId, request?.query?.hierarchyType);
    var modifiedHierarchy = hierarchy.map((ele) =>
        `${request?.query?.hierarchyType}_${ele}`.toUpperCase()
    );
    var resultHierarchy = getLocalizedHeaders(
        modifiedHierarchy,
        localizationMap
    );
    return resultHierarchy;
}


async function appendSheetsToWorkbook(request: any, boundaryData: any[], differentTabsBasedOnLevel: any, localizationMap?: any, fileUrl?: any) {
    try {
        logger.info("Received Boundary data for generating  different tabs based on configured boundary level");
        const hierarchy: any[] = await getLocalizedHierarchy(request, localizationMap);
        const workbook = getNewExcelWorkbook();
        const type = request?.query?.type;
        const headingInSheet = headingMapping?.[type];
        const localisedHeading = getLocalizedName(headingInSheet, localizationMap);
        await createReadMeSheet(request, workbook, localisedHeading, localizationMap);
        const [mainSheetData, uniqueDistrictsForMainSheet, districtLevelRowBoundaryCodeMap] = createBoundaryDataMainSheet(request, boundaryData, differentTabsBasedOnLevel, hierarchy, localizationMap)
        const responseFromCampaignSearch = await getCampaignSearchResponse(request);
        const campaignObject = responseFromCampaignSearch?.CampaignDetails?.[0];
        // const isSourceMicroplan = checkIfSourceIsMicroplan(campaignObject);
        const mainSheet = workbook.addWorksheet(getLocalizedName(getBoundaryTabName(), localizationMap));
        const columnWidths = Array(12).fill(30);
        mainSheet.columns = columnWidths.map(width => ({ width }));
        // mainSheetData.forEach(row => mainSheet.addRow(row));
        addDataToSheet(request, mainSheet, mainSheetData, 'F3842D', 30, false, true);
        mainSheet.state = 'hidden';
        logger.info("appending different districts tab in the sheet started")
        await appendDistricts(request, workbook, uniqueDistrictsForMainSheet, differentTabsBasedOnLevel, boundaryData, localizationMap, districtLevelRowBoundaryCodeMap, hierarchy, campaignObject, fileUrl);
        logger.info("Sheet with different tabs generated successfully");
        return workbook;
    } catch (error) {
        console.log(error);
        throw Error("An error occurred while creating tabs based on district:");
    }
}


async function appendDistricts(request: any, workbook: any, uniqueDistrictsForMainSheet: any, differentTabsBasedOnLevel: any, boundaryData: any, localizationMap: any, districtLevelRowBoundaryCodeMap: any, hierarchy: any, campaignObject: any, fileUrl?: any) {
    const configurableColumnHeadersFromSchemaForTargetSheet = await getConfigurableColumnHeadersFromSchemaForTargetSheet(request, hierarchy, boundaryData, differentTabsBasedOnLevel, campaignObject, localizationMap);
    let sheetNamesOfProcessedFile: any;
    if (fileUrl) {
        const processedWorkbook = await getTargetWorkbook(fileUrl, localizationMap);
        sheetNamesOfProcessedFile = processedWorkbook.worksheets.map((sheet: any) => sheet.name);
    }
    for (const uniqueData of uniqueDistrictsForMainSheet) {
        const uniqueDataFromLevelForDifferentTabs = uniqueData.slice(uniqueData.lastIndexOf('#') + 1);
        logger.info(`generating the boundary data for ${uniqueDataFromLevelForDifferentTabs} - ${differentTabsBasedOnLevel}`)
        const districtDataFiltered = boundaryData.filter((boundary: any) => boundary[differentTabsBasedOnLevel] === uniqueDataFromLevelForDifferentTabs && boundary[hierarchy[hierarchy.length - 1]]);
        const modifiedFilteredData = modifyFilteredData(districtDataFiltered, districtLevelRowBoundaryCodeMap.get(uniqueData), localizationMap);
        if (modifiedFilteredData?.[0]) {
            const newSheetData = [configurableColumnHeadersFromSchemaForTargetSheet];
            for (const data of modifiedFilteredData) {
                var rowData: any[] = [];
                for (const header of configurableColumnHeadersFromSchemaForTargetSheet) {
                    rowData.push(data[header] || '');
                }
                newSheetData.push(rowData);
            }

            await createNewSheet(request, workbook, newSheetData, uniqueData, localizationMap, districtLevelRowBoundaryCodeMap, configurableColumnHeadersFromSchemaForTargetSheet, campaignObject, sheetNamesOfProcessedFile, fileUrl);
            logger.info(`${uniqueDataFromLevelForDifferentTabs} - ${differentTabsBasedOnLevel} boundary data generation completed`)
        }
    }
}

async function createNewSheet(request: any, workbook: any, newSheetData: any, uniqueData: any, localizationMap: any, districtLevelRowBoundaryCodeMap: any, localizedHeaders: any, campaignObject: any, sheetNamesOfProcessedFile: any, fileUrl?: any) {
    const newSheet = workbook.addWorksheet(getLocalizedName(districtLevelRowBoundaryCodeMap.get(uniqueData), localizationMap));
    let modifiedNewSheetData: any = newSheetData;
    const oldTargetColumnsToHide: any[] = [];
    if (fileUrl) {
        let processedDistrictSheetData: any;
        if (sheetNamesOfProcessedFile.includes(getLocalizedName(districtLevelRowBoundaryCodeMap.get(uniqueData), localizationMap))) {
            processedDistrictSheetData = await getSheetData(fileUrl, getLocalizedName(districtLevelRowBoundaryCodeMap.get(uniqueData), localizationMap),
                false, undefined, localizationMap);
        }
        modifiedNewSheetData = modifyNewSheetData(processedDistrictSheetData, newSheetData, localizedHeaders, oldTargetColumnsToHide, localizationMap)
    }
    addDataToSheet(request, newSheet, modifiedNewSheetData, 'F3842D', 40);
    if (oldTargetColumnsToHide && oldTargetColumnsToHide.length > 0) {
        const columnIndexesToBeHidden: any[] = [];
        oldTargetColumnsToHide.forEach((column: any) => {
            const localizedColumn = getLocalizedName(column, localizationMap);
            const columnIndex = getColumnIndexByHeader(newSheet, localizedColumn);
            columnIndexesToBeHidden.push(columnIndex);
        });
        hideColumnsOfProcessedFile(newSheet, columnIndexesToBeHidden);
    }
    let columnsNotToBeFreezed: any;
    const boundaryCodeColumnIndex = localizedHeaders.findIndex((header: any) => header === getLocalizedName(config?.boundary?.boundaryCode, localizationMap));
    if (isDynamicTargetTemplateForProjectType(campaignObject?.projectType) && campaignObject.deliveryRules && campaignObject.deliveryRules.length > 0) {
        columnsNotToBeFreezed = localizedHeaders.slice(boundaryCodeColumnIndex + 1);
    }
    else {
        const mdmsResponse = await getMdmsDataBasedOnCampaignType(request, localizationMap)
        columnsNotToBeFreezed = mdmsResponse?.columnsNotToBeFreezed;
    }
    const localizedColumnsNotToBeFreezed = getLocalizedHeaders(columnsNotToBeFreezed, localizationMap);
    lockTargetFields(newSheet, localizedColumnsNotToBeFreezed, boundaryCodeColumnIndex);
}





function modifyFilteredData(districtDataFiltered: any, targetBoundaryCode: any, localizationMap?: any): any {

    // Step 2: Slice the boundary code up to the last underscore
    const slicedBoundaryCode = targetBoundaryCode.slice(0, targetBoundaryCode.lastIndexOf('_') + 1);

    // Step 3: Filter the rows that contain the sliced boundary code
    const modifiedFilteredData = districtDataFiltered.filter((row: any, index: any) => {
        // Extract the boundary code from the current row
        const localizedBoundaryCode = getLocalizedName(getBoundaryColumnName(), localizationMap);
        const boundaryCode = row[localizedBoundaryCode];
        // Check if the boundary code starts with the sliced boundary code
        return boundaryCode.startsWith(slicedBoundaryCode);
    });
    // Step 4: Return the modified filtered data
    return modifiedFilteredData;
}

async function generateFilteredBoundaryData(request: any, FiltersFromCampaignId: any) {
    const rootBoundary: any = (FiltersFromCampaignId?.Filters?.boundaries).filter((boundary: any) => boundary.isRoot);
    const params = {
        ...request?.query,
        includeChildren: true,
        codes: rootBoundary?.[0]?.code
    };
    const boundaryDataFromRootOnwards = await getBoundaryRelationshipData(request, params);
    logger.info(`filtering the boundaries`);
    const filteredBoundaryList = filterBoundaries(boundaryDataFromRootOnwards, FiltersFromCampaignId?.Filters)
    logger.info(`filtered the boundaries based on given criteria`)
    return filteredBoundaryList;
}

function filterBoundaries(boundaryData: any[], filters: any): any {
    function filterRecursive(boundary: any): any {
        const boundaryFilters = filters && filters.boundaries; // Accessing boundaries array from filters object
        const filter = boundaryFilters?.find((f: any) => f.code === boundary.code && f.boundaryType === boundary.boundaryType);

        if (!filter) {
            return {
                ...boundary,
                children: boundary.children.map(filterRecursive)
            };
        }

        if (!boundary.children.length) {
            if (!filter.includeAllChildren) {
                // throwError("COMMON", 400, "VALIDATION_ERROR", "Boundary cannot have includeAllChildren filter false if it does not have any children");
                logger.error("Boundary cannot have includeAllChildren filter false if it does not have any children");
            }
            // If boundary has no children and includeAllChildren is true, return as is
            return {
                ...boundary,
                children: []
            };
        }

        if (filter.includeAllChildren) {
            // If includeAllChildren is true, return boundary with all children
            return {
                ...boundary,
                children: boundary.children.map(filterRecursive)
            };
        }

        const filteredChildren: any[] = [];
        boundary.children.forEach((child: any) => {
            const matchingFilter = boundaryFilters.find((f: any) => f.code === child.code && f.boundaryType === child.boundaryType);
            if (matchingFilter) {
                filteredChildren.push(filterRecursive(child));
            }
        });
        return {
            ...boundary,
            children: filteredChildren
        };
    }
    const filteredData = boundaryData.map(filterRecursive);
    return filteredData;
}


function generateHierarchy(boundaries: any[]) {
    // Create an object to store boundary types and their parents
    const parentMap: any = {};

    // Populate the object with boundary types and their parents
    for (const boundary of boundaries) {
        parentMap[boundary.boundaryType] = boundary.parentBoundaryType;
    }

    // Traverse the hierarchy to generate the hierarchy list
    const hierarchyList = [];
    for (const boundaryType in parentMap) {
        if (Object.prototype.hasOwnProperty.call(parentMap, boundaryType)) {
            const parentBoundaryType = parentMap[boundaryType];
            if (parentBoundaryType === null) {
                // This boundary type has no parent, add it to the hierarchy list
                hierarchyList.push(boundaryType);
                // Traverse its children recursively
                traverseChildren(boundaryType, parentMap, hierarchyList);
            }
        }
    }
    return hierarchyList;
}

function traverseChildren(parent: any, parentMap: any, hierarchyList: any[]) {
    for (const boundaryType in parentMap) {
        if (Object.prototype.hasOwnProperty.call(parentMap, boundaryType)) {
            const parentBoundaryType = parentMap[boundaryType];
            if (parentBoundaryType === parent) {
                // This boundary type has the current parent, add it to the hierarchy list
                hierarchyList.push(boundaryType);
                // Traverse its children recursively
                traverseChildren(boundaryType, parentMap, hierarchyList);
            }
        }
    }
}

function createBoundaryMap(boundaries: any[], boundaryMap: Map<string, string>): void {
    for (const boundary of boundaries) {
        boundaryMap.set(boundary.code, boundary.boundaryType);
        if (boundary.children.length > 0) {
            createBoundaryMap(boundary.children, boundaryMap);
        }
    }
}

async function boundaryGeometryManagement(request: any, localizationMap: any) {
    try {
        logger.info("Boundary Relationship Creation Starts For Geometry Data");
        await autoGenerateBoundaryCodesForGeoJson(request, localizationMap);
    } catch (error: any) {
        console.log(error)
        await handleResouceDetailsError(request, error)
    }
}

async function boundaryBulkUpload(request: any, localizationMap?: any) {
    try {
        logger.info("Boundary Relationship Creation Starts");
        await autoGenerateBoundaryCodes(request, localizationMap);
        await generateProcessedFileAndPersist(request);
    }
    catch (error: any) {
        console.log(error)
        await handleResouceDetailsError(request, error)
    }
}

function updateBoundaryDataForBoundaryManagement(
    request: any,
    boundaryData: any[],
    localizationMap: any
): { updatedData: any[], latLongData: [number, number][] } {
    const latLongData: [number, number][] = [];
    const latKey = getLocalizedName("HCM_ADMIN_CONSOLE_LAT", localizationMap);
    const longKey = getLocalizedName("HCM_ADMIN_CONSOLE_LONG", localizationMap);

    boundaryData.forEach((row) => {
        // Check if the row contains both latitude and longitude keys
        if (latKey in row && longKey in row) {
            // Push latitude and longitude to the latLongData array
            latLongData.push([row[latKey], row[longKey]]);

            // Remove the latitude and longitude from the original row
            delete row[latKey];
            delete row[longKey];
        }
    });

    // Return both the updated boundary data and latLongData
    return {
        updatedData: boundaryData,
        latLongData
    };
}

async function autoGenerateBoundaryCodesForGeoJson(request: any, localizationMap?: any) {
    const { hierarchyType, tenantId } = request?.body?.ResourceDetails || {};
    // const type = request?.body?.ResourceDetails?.type;
    const fileResponse = await httpRequest(config.host.filestore + config.paths.filestore + "/url", {}, { tenantId, fileStoreIds: request?.body?.ResourceDetails?.fileStoreId }, "get");
    var boundaryData = await getDataFromGeoJson(fileResponse?.fileStoreIds?.[0]?.url);
    const hierarchy = await getHierarchy(request, tenantId, hierarchyType) || [];
    const dataFromGeoJson = getGeoJsonData(boundaryData, hierarchy);
    const childParentMap = getChildParentMap(dataFromGeoJson);
    const countMap = new Map<{ key: string, value: string }, number>();
    const mappingMap = new Map<{ key: string, value: string }, string>();
    const boundaryMap = await getAutoGeneratedBoundaryCodesHandler(dataFromGeoJson, childParentMap, mappingMap, countMap, request);
    logger.info("Boundary Code Auto Generation Completed");
    await createBoundaryEntities(request, boundaryMap);
    logger.info("waiting for 2 secs to persist the boundary entities before creating boundary relationship")
    await new Promise(resolve => setTimeout(resolve, 2000));
    const modifiedChildParentMap = modifyChildParentMap(childParentMap, boundaryMap);
    await createBoundaryRelationship(request, boundaryMap, modifiedChildParentMap);
    const boundaryGeoJsonAfterProcessing = addBoundaryCodeToGeoJsonData(boundaryData, hierarchy, boundaryMap);
    logger.info("Initiated the localisation message creation for the uploaded boundary");
    transformAndCreateLocalisation(boundaryMap, request);
    const boundaryFileDetails: any = await createAndUploadJsonFile(boundaryGeoJsonAfterProcessing, request);
    await updateAndPersistResourceDetails(request, boundaryFileDetails, boundaryData?.name);
    logger.info("Boundary Relationship Creation Completed");
}

async function updateAndPersistResourceDetails(request: any, boundaryFileDetails: any, name: any) {
    const fileStoreId = boundaryFileDetails[0]?.fileStoreId;
    const getLatestResourceDetails = await getResourceDetails(request);

    if (getLatestResourceDetails == null) {
        request.body.ResourceDetails = {
            ...request?.body?.ResourceDetails,
            processedFileStoreId: fileStoreId,
            status: request.body.ResourceDetails.status != resourceDataStatuses.invalid ? resourceDataStatuses.completed : resourceDataStatuses.invalid,
            auditDetails: {
                ...request?.body?.ResourceDetails?.auditDetails,
                lastModifiedBy: request?.body?.RequestInfo?.userInfo?.uuid,
                lastModifiedTime: Date.now()
            },
            additionalDetails: { ...request?.body?.ResourceDetails?.additionalDetails, sheetErrors: request?.body?.additionalDetailsErrors, source: (request?.body?.ResourceDetails?.additionalDetails?.source == "microplan") ? "microplan" : null, [name]: [fileStoreId] } || {}
        };
    } else {
        request.body.ResourceDetails = {
            ...getLatestResourceDetails,
            processedFileStoreId: fileStoreId,
            status: getLatestResourceDetails.status != resourceDataStatuses.invalid ? resourceDataStatuses.completed : resourceDataStatuses.invalid,
            auditDetails: {
                ...getLatestResourceDetails.auditDetails,
                lastModifiedBy: request?.body?.RequestInfo?.userInfo?.uuid,
                lastModifiedTime: Date.now()
            },
            additionalDetails: { ...getLatestResourceDetails.additionalDetails, sheetErrors: request?.body?.additionalDetailsErrors, source: (getLatestResourceDetails.additionalDetails?.source == "microplan") ? "microplan" : null } || {}
        };
        let additionalDetails = request?.body?.ResourceDetails?.additionalDetails;
        if (additionalDetails && additionalDetails[name]) {
            additionalDetails[name].push(fileStoreId);
        } else {
            additionalDetails = { ...additionalDetails, [name]: [fileStoreId] };
        }
        request.body.ResourceDetails.additionalDetails = additionalDetails;
    }

    const persistMessage: any = { ResourceDetails: request.body.ResourceDetails }
    await produceModifiedMessages(persistMessage, config?.kafka?.KAFKA_UPDATE_RESOURCE_DETAILS_TOPIC);
    logger.info(`ResourceDetails to persist : ${request.body.ResourceDetails.type}`);
}

async function getResourceDetails(request: any) {
    const { tenantId, type, hierarchyType } = request?.body?.ResourceDetails || request?.query;
    const resourceDetails = request?.body?.ResourceDetails;

    request.body.SearchCriteria = request.body.SearchCriteria || {};

    request.body.SearchCriteria = {
        tenantId: tenantId,
        type: type,
        hierarchyType: hierarchyType,
        status: resourceDataStatuses.completed
    };

    const response = await searchDataService(request);
    request.body.ResourceDetails = resourceDetails;
    if (response.length > 0) {
        response.sort((a: any, b: any) => b.auditDetails.lastModifiedTime - a.auditDetails.lastModifiedTime);
        return response[0];
    } else {
        return null;
    }
}
const addBoundaryCodeToGeoJsonData = (boundaryData: any, hiearchy: any, boundaryMap: Map<any, any>) => {
    // const objectMap = boundaryMap.forEach((value, key) => {return { key: key.value, value: value });
    // Create the updatedBoundaryMap using a Map
    const updatedBoundaryMap = new Map();
    boundaryMap.forEach((value, key) => {
        const newKey = key.key + '_' + key.value; // Concatenate key and value
        updatedBoundaryMap.set(newKey, value); // Set in the updated map
    });

    // Iterate through the boundary data
    boundaryData.features.forEach((feature: any) => {
        // Extract the properties object from the feature
        const properties = feature.properties;

        // Iterate through the hierarchy
        hiearchy.forEach((h: string) => {
            // Build the field name
            const field = h.toLowerCase() + '_name';

            // Check if the field exists in the properties object
            if (properties[field]) {
                const boundaryName = h + '_' + properties[field];
                // Assign the boundary code to the properties object
                properties[config.boundary.boundaryCode] = updatedBoundaryMap.get(boundaryName); // Use .get() to access the Map
            }
        });
    });

    return boundaryData;

}
const getGeoJsonData = (boundaryData: any, hiearchy: any) => {
    var data: any = [];
    boundaryData.features?.forEach((feature: any) => {
        const properties = feature.properties;
        var row: any = [];
        hiearchy.forEach((h: string) => {
            const field = h.toLowerCase() + '_name';
            if (properties[field]) {
                const d = {
                    key: h,
                    value: properties[field]
                };
                row.push(d);
            }
        });
        data.push(row);
    })
    return data;
}

const getDataFromGeoJson = async (url: string) => {
    // Define headers for HTTP request
    const headers = {
        "Content-Type": "application/json",
        Accept: "application/json",
    };
    logger.info("loading for the file based on fileurl");
    // Make HTTP request to retrieve Excel file as arraybuffer
    const responseFile = await httpRequest(
        url,
        null,
        {},
        "get",
        "json",
        headers
    );
    logger.info("received the file response");
    return responseFile;
}

const autoGenerateBoundaryCodes = async (request: any, localizationMap?: any) => {
    const { hierarchyType, tenantId } = request?.body?.ResourceDetails || {};
    const hierarchy = await getHierarchy(request, tenantId, hierarchyType) || [];
    const headersOfBoundarySheet = hierarchy.map(e => `${hierarchyType.toUpperCase()}_${e.toUpperCase()}`);
    const localizedHeadersOfBoundarySheet = getLocalizedHeaders(headersOfBoundarySheet, localizationMap);
    const type = request?.body?.ResourceDetails?.type;
    const fileResponse = await httpRequest(config.host.filestore + config.paths.filestore + "/url", {}, { tenantId, fileStoreIds: request?.body?.ResourceDetails?.fileStoreId }, "get");
    const localizedBoundaryTab = getLocalizedName(getBoundaryTabName(), localizationMap);
    var boundaryData = await getSheetData(fileResponse?.fileStoreIds?.[0]?.url, localizedBoundaryTab, false, undefined, localizationMap);
    var latLongData: any;
    if (type === "boundaryManagement") {
        validateBoundarySheetDataInCreateFlow(boundaryData, localizedHeadersOfBoundarySheet);
        const result = await updateBoundaryDataForBoundaryManagement(request, boundaryData, localizationMap);
        latLongData = result.latLongData;
        boundaryData = result.updatedData;
    }
    const updatedBoundaryData = updateBoundaryData(boundaryData, hierarchy);
    const modifiedBoundaryData = modifyBoundaryDataHeaders(updatedBoundaryData, hierarchy, localizationMap);
    const [withBoundaryCode, withoutBoundaryCode] = modifyBoundaryData(modifiedBoundaryData, localizationMap);
    const { mappingMap, countMap } = getCodeMappingsOfExistingBoundaryCodes(withBoundaryCode);
    const childParentMap = getChildParentMap([...withBoundaryCode, ...withoutBoundaryCode]);
    const boundaryMap = await getAutoGeneratedBoundaryCodesHandler(withoutBoundaryCode, childParentMap, mappingMap, countMap, request);
    logger.info("Boundary Code Auto Generation Completed");
    await createBoundaryEntities(request, boundaryMap);
    logger.info("waiting for 2 secs to persist the boundary entities before creating boundary relationship")
    await new Promise(resolve => setTimeout(resolve, 2000));
    const modifiedChildParentMap = modifyChildParentMap(childParentMap, boundaryMap);
    await createBoundaryRelationship(request, boundaryMap, modifiedChildParentMap);
    const boundaryDataForSheet = addBoundaryCodeToData(withBoundaryCode, withoutBoundaryCode, boundaryMap);
    logger.info("Initiated the localisation message creation for the uploaded boundary");
    transformAndCreateLocalisation(boundaryMap, request);
    const modifiedHierarchy = hierarchy.map(ele => `${hierarchyType}_${ele}`.toUpperCase())
    var headers = [...modifiedHierarchy, config?.boundary?.boundaryCode];
    const data = prepareDataForExcel(boundaryDataForSheet, hierarchy, boundaryMap);
    if (type === "boundaryManagement") {
        headers = [...headers, getLocalizedName("HCM_ADMIN_CONSOLE_LAT", localizationMap), getLocalizedName("HCM_ADMIN_CONSOLE_LONG", localizationMap)];
        data.forEach((row: any[], index: string | number) => {
            if (latLongData.length > index) {
                row.push(latLongData[index][0], latLongData[index][1]);
            }
        });
    }
    const localizedHeaders = getLocalizedHeaders(headers, localizationMap);
    const boundarySheetData: any = await createExcelSheet(data, localizedHeaders);
    const workbook = getNewExcelWorkbook();
    const boundarySheet = workbook.addWorksheet(localizedBoundaryTab);
    addDataToSheet(request, boundarySheet, boundarySheetData, '93C47D', 40, true);
    const boundaryFileDetails: any = await createAndUploadFile(workbook, request);
    request.body.ResourceDetails.processedFileStoreId = boundaryFileDetails?.[0]?.fileStoreId;
}



function updateBoundaryData(boundaryData: any[], hierarchy: any[]): any[] {
    const map: Map<string, string> = new Map();
    const count: Map<string, number> = new Map();

    boundaryData.forEach((row) => {
        const keys = Object.keys(row).filter((key) => hierarchy.includes(key));
        keys.forEach((key, index) => {
            if (index > 0) {
                const element = row[key];
                const previousKey = keys[index - 1];
                const previousElement = row[keys[index - 1]];
                const previousElementKey = `${previousKey}:${previousElement}`;
                const elementKey = `${key}:${element}`;

                if (!map.has(elementKey)) {
                    map.set(elementKey, previousElementKey);
                    count.set(elementKey, 1);
                } else {
                    const currentCount = count.get(elementKey)!;
                    if (map.get(elementKey) !== previousElementKey) {
                        map.set(elementKey, previousElementKey);
                        count.set(elementKey, currentCount + 1);
                    }
                    const uniqueCount = count.get(elementKey)!;
                    const uniqueElement = (uniqueCount > 1) ? `${element}-${(uniqueCount - 1).toString().padStart(2, '0')}` : `${element}`;
                    row[key] = uniqueElement;
                }
            }
        });
    });
    return boundaryData;
}

function modifyBoundaryDataHeaders(boundaryData: any[], hierarchy: any[], localizationMap?: any) {
    const updatedData = boundaryData.map((obj: any) => {
        const updatedObj: { [key: string]: string | undefined } = {}; // Updated object with modified keys

        let hierarchyIndex = 0; // Track the index of the hierarchy array

        for (const key in obj) {
            if (key != getLocalizedName(config?.boundary?.boundaryCode, localizationMap)) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    const hierarchyKey = hierarchy[hierarchyIndex]; // Get the key from the hierarchy array
                    updatedObj[hierarchyKey] = obj[key]; // Map the key to the updated object
                    hierarchyIndex++; // Move to the next key in the hierarchy array
                }
            }
            else {
                updatedObj[key] = obj[key];
            }
        }


        return updatedObj;
    });
    return updatedData;
}

function modifyChildParentMap(childParentMap: Map<any, any>, boundaryMap: Map<any, any>): Map<string, string | null> {
    const modifiedMap: Map<string, string | null> = new Map();

    // Iterate over each entry in childParentMap
    childParentMap.forEach((value, key) => {
        // Get the modified key and value from boundaryMap
        const modifiedKey = findMapValue(boundaryMap, key) || null;
        const modifiedValue = value ? findMapValue(boundaryMap, value) : null;

        // Set the modified key-value pair in modifiedMap
        modifiedMap.set(modifiedKey, modifiedValue);
    });

    return modifiedMap;
}


async function convertSheetToDifferentTabs(request: any, boundaryData: any, differentTabsBasedOnLevel: any, localizationMap?: any, fileUrl?: any) {
    // create different tabs on the level of hierarchy we want to 
    const updatedWorkbook = await appendSheetsToWorkbook(request, boundaryData, differentTabsBasedOnLevel, localizationMap, fileUrl);
    // upload the excel and generate file store id
    const boundaryDetails = await createAndUploadFile(updatedWorkbook, request);
    return boundaryDetails;
}

async function getBoundaryDataAfterGeneration(result: any, request: any, localizationMap?: any) {
    const fileStoreId = result[0].fileStoreId;
    const fileResponse = await httpRequest(config.host.filestore + config.paths.filestore + "/url", {}, { tenantId: request?.query?.tenantId, fileStoreIds: fileStoreId }, "get");
    if (!fileResponse?.fileStoreIds?.[0]?.url) {
        throwError("FILE", 400, "INVALID_FILE");
    }
    const boundaryData = await getSheetData(fileResponse?.fileStoreIds?.[0]?.url, getBoundaryTabName(), false, undefined, localizationMap);
    return boundaryData;
}

function getLocalizedName(expectedName: string, localizationMap?: { [key: string]: string }) {
    if (!localizationMap || !(expectedName in localizationMap)) {
        return expectedName;
    }
    const localizedName = localizationMap[expectedName];
    return localizedName;
}

async function getTargetBoundariesRelatedToCampaignId(request: any, localizationMap?: any) {
    let CampaignDetails: any;
    if (request?.body?.ResourceDetails?.campaignId) {
        const searchBody = {
            RequestInfo: request?.body?.RequestInfo,
            CampaignDetails: {
                ids: [request?.body?.ResourceDetails?.campaignId],
                tenantId: request?.body?.ResourceDetails?.tenantId
            }
        }
        const req: any = replicateRequest(request, searchBody)
        const response = await searchProjectTypeCampaignService(req)
        if (response?.CampaignDetails?.[0]) {
            CampaignDetails = response?.CampaignDetails?.[0]
            await addBoundariesForData(request, CampaignDetails)
        }
        else {
            throwError("CAMPAIGN", 400, "CAMPAIGN_NOT_FOUND", "Campaign not found while Validating sheet boundaries");
        }
    }
    return CampaignDetails?.boundaries;
}


async function getFiltersFromCampaignSearchResponse(request: any, responseFromCampaignSearch: any) {
    const boundaries = await getBoundariesFromCampaignSearchResponse(request, responseFromCampaignSearch?.CampaignDetails?.[0]);
    const boundariesModified = boundaries?.map((ele: any) => ({ ...ele, boundaryType: ele?.type }));
    if (!boundariesModified) {
        logger.info(`no boundaries found so considering the complete hierarchy`);
        return { Filters: null };
    }
    logger.info(`boundaries found for filtering`);
    return { Filters: { boundaries: boundariesModified } }
};



const getConfigurableColumnHeadersBasedOnCampaignType = async (request: any, localizationMap?: any) => {
    try {
        const responseFromCampaignSearch = await getCampaignSearchResponse(request);
        const campaignObject = responseFromCampaignSearch?.CampaignDetails?.[0];
        let campaignType = campaignObject?.projectType;
        const isSourceMicroplan = checkIfSourceIsMicroplan(campaignObject);
        campaignType = (isSourceMicroplan) ? `${config?.prefixForMicroplanCampaigns}-${campaignType}` : campaignType;
        const isUpdate = request?.body?.parentCampaignObject ? true : false;
        const mdmsResponse = await callMdmsTypeSchema(request, request?.query?.tenantId || request?.body?.ResourceDetails?.tenantId, isUpdate, request?.query?.type || request?.body?.ResourceDetails?.type, campaignType)
        if (!mdmsResponse || mdmsResponse?.columns.length === 0) {
            logger.error(`Campaign Type ${campaignType} has not any columns configured in schema`)
            throwError("COMMON", 400, "SCHEMA_ERROR", `Campaign Type ${campaignType} has not any columns configured in schema`);
        }
        // Extract columns from the response
        const columnsForGivenCampaignId = mdmsResponse?.columns;

        // Get localized headers based on the column names
        const headerColumnsAfterHierarchy = getLocalizedHeaders(columnsForGivenCampaignId, localizationMap);
        if (!headerColumnsAfterHierarchy.includes(getLocalizedName(config.boundary.boundaryCode, localizationMap))) {
            logger.error(`Column Headers of generated Boundary Template does not have ${getLocalizedName(config.boundary.boundaryCode, localizationMap)} column`)
            throwError("COMMON", 400, "VALIDATION_ERROR", `Column Headers of generated Boundary Template does not have ${getLocalizedName(config.boundary.boundaryCode, localizationMap)} column`)
        }
        return headerColumnsAfterHierarchy;
    } catch (error: any) {
        console.log(error)
        throwError("FILE", 400, "FETCHING_COLUMN_ERROR", "Error fetching column Headers From Schema (either boundary code column not found or given  Campaign Type not found in schema) Check logs")
    }

}


async function getFinalValidHeadersForTargetSheetAsPerCampaignType(request: any, hierarchy: any[], differentTabsBasedOnLevel: any, localizationMap?: any) {
    const modifiedHierarchy = hierarchy.map(ele => `${request?.body?.ResourceDetails?.hierarchyType}_${ele}`.toUpperCase());
    const localizedHierarchy = getLocalizedHeaders(modifiedHierarchy, localizationMap);
    const index = localizedHierarchy.indexOf(getLocalizedName(differentTabsBasedOnLevel, localizationMap));
    const responseFromCampaignSearch = await getCampaignSearchResponse(request);
    const campaignObject = responseFromCampaignSearch?.CampaignDetails?.[0];
    const isSourceMicroplan = checkIfSourceIsMicroplan(campaignObject);
    var expectedHeadersForTargetSheetUptoHierarchy: any;
    if (isSourceMicroplan) {
        expectedHeadersForTargetSheetUptoHierarchy = localizedHierarchy;
    }
    else {
        expectedHeadersForTargetSheetUptoHierarchy = index !== -1 ? localizedHierarchy.slice(index) : throwError("COMMON", 400, "VALIDATION_ERROR", `${getLocalizedName(config?.boundary?.generateDifferentTabsOnBasisOf, localizationMap)} level not present in the hierarchy`);
    }
    const columnFromSchemaOfTargetTemplate = await generateDynamicTargetHeaders(request, campaignObject, localizationMap);
    const localizedcolumnFromSchemaOfTargetTemplate = getLocalizedHeaders(columnFromSchemaOfTargetTemplate, localizationMap);
    let updatedLocalizedcolumnFromSchemaOfTargetTemplate = localizedcolumnFromSchemaOfTargetTemplate;
    if (request?.body?.parentCampaignObject) {
        updatedLocalizedcolumnFromSchemaOfTargetTemplate = localizedcolumnFromSchemaOfTargetTemplate.map((item: any) => `${item}(OLD)`).concat(localizedcolumnFromSchemaOfTargetTemplate);
    }
    const expectedHeadersForTargetSheet = [...expectedHeadersForTargetSheetUptoHierarchy, getLocalizedName(config?.boundary?.boundaryCode, localizationMap), ...updatedLocalizedcolumnFromSchemaOfTargetTemplate];
    return expectedHeadersForTargetSheet;
}

async function getDifferentTabGeneratedBasedOnConfig(request: any, boundaryDataGeneratedBeforeDifferentTabSeparation: any, localizationMap?: any, fileUrl?: any) {
    var boundaryDataGeneratedAfterDifferentTabSeparation: any = boundaryDataGeneratedBeforeDifferentTabSeparation;
    const boundaryData = await getBoundaryDataAfterGeneration(boundaryDataGeneratedBeforeDifferentTabSeparation, request, localizationMap);
    let differentTabsBasedOnLevel = await getBoundaryOnWhichWeSplit(request, request?.query?.tenantId);
    differentTabsBasedOnLevel = getLocalizedName(`${request?.query?.hierarchyType}_${differentTabsBasedOnLevel}`.toUpperCase(), localizationMap);
    logger.info(`Boundaries are seperated based on hierarchy type ${differentTabsBasedOnLevel}`)
    const isKeyOfThatTypePresent = boundaryData.some((data: any) => data.hasOwnProperty(differentTabsBasedOnLevel));
    const boundaryTypeOnWhichWeSplit = boundaryData.filter((data: any) => data[differentTabsBasedOnLevel]);
    if (isKeyOfThatTypePresent && boundaryTypeOnWhichWeSplit.length >= parseInt(config?.boundary?.numberOfBoundaryDataOnWhichWeSplit)) {
        logger.info(`sinces the conditions are matched boundaries are getting splitted into different tabs`)
        boundaryDataGeneratedAfterDifferentTabSeparation = await convertSheetToDifferentTabs(request, boundaryData, differentTabsBasedOnLevel, localizationMap, fileUrl);
    }
    return boundaryDataGeneratedAfterDifferentTabSeparation;
}

async function getBoundaryOnWhichWeSplit(request: any, tenantId: any) {
    const responseFromCampaignSearch = await getCampaignSearchResponse(request);
    const MdmsCriteria: any = {
        tenantId: tenantId,
        schemaCode: `${config.values.moduleName}.${config.masterNameForSplitBoundariesOn}`,
        filters: { hierarchy: responseFromCampaignSearch?.CampaignDetails?.[0].hierarchyType }
    }
    const mdmsResponse: any = await searchMDMSDataViaV2Api(MdmsCriteria);
    return mdmsResponse?.mdms?.[0]?.data?.splitBoundariesOn;
}



function checkIfSourceIsMicroplan(objectWithAdditionalDetails: any): boolean {
    return objectWithAdditionalDetails?.additionalDetails?.source === 'microplan';
}

function createIdRequests(employees: any[]): any[] {
    if (employees && Array.isArray(employees) && employees.length > 0) {
        const { tenantId } = employees[0]; // Assuming all employees have the same tenantId
        return Array.from({ length: employees.length }, () => ({
            tenantId: tenantId,
            idName: config?.values?.idgen?.idNameForUserNameGeneration,
            idFormat: config?.values?.idgen?.formatForUserName
        }));
    }
    else {
        return [];
    }
}

async function createUniqueUserNameViaIdGen(request: any) {
    const idgenurl = config?.host?.idGenHost + config?.paths?.idGen;
    try {
        // Make HTTP request to ID generation service
        const result = await httpRequest(
            idgenurl,
            request?.body,
            undefined,
            undefined,
            undefined,
            undefined
        );

        // Return null if ID generation fails
        return result;
    } catch (error: any) {
        // Log the error
        logger.error(`Error during ID generation: ${error.message}`);

        // Throw a custom error
        throwError("ID_GENERATION", 500, "ID_GENERATION_FAILED", `Error occurred while generating ID: ${error.message}`);
    }
}

async function processFetchMicroPlan(request: any) {
    logger.info("Started processing fetch microplan");
    const { tenantId } = request.body.MicroplanDetails;
    const facilitySheetId = request.body.planConfig.files.find((file: { templateIdentifier: string; }) => file.templateIdentifier === "Facilities")?.filestoreId;
    const fileResponse = await httpRequest(config.host.filestore + config.paths.filestore + "/url", {}, { tenantId, fileStoreIds: facilitySheetId }, "get");
    const localizationMap = await getLocalizedMessagesHandler(request, tenantId);
    const localizedFacilityTab = getLocalizedName(config?.facility?.facilityTab, localizationMap);
    const boundaryTab = getLocalizedName(config?.boundary?.boundaryTab, localizationMap);
    const processedFacilitySheetData = await getSheetDataMP(fileResponse.fileStoreIds[0].url, localizedFacilityTab, false, undefined, localizationMap);
    const processedBoundaryData = await getSheetDataMP(fileResponse.fileStoreIds[0].url, boundaryTab, false, undefined, localizationMap);
    const planFacilityMap = getPlanFacilityMap(request?.body?.PlanFacility);
    const filterFacilitySheet = filterFacilityData(processedFacilitySheetData);
    const filledFacilitySheetData = fillFacilitySheetData(filterFacilitySheet, planFacilityMap);
    const schema = await callMdmsTypeSchema(request, tenantId, true, "facility", "all");
    request.query.type = "facilityWithBoundary";
    request.query.tenantId = tenantId;
    await createFacilityAndBoundaryFile(filledFacilitySheetData, processedBoundaryData, request, localizationMap, fileResponse.fileStoreIds[0].url, schema);
    const resourceDetails = await validateFacilitySheet(request);
    await updateCampaignDetails(request, resourceDetails?.id);
}

async function updateCampaignDetails(request: any, resourceDetailsId: any) {
    const { resources } = request.body.CampaignDetails || {};
    const { fileDetails } = request.body;

    if (Array.isArray(resources) && Array.isArray(fileDetails) && fileDetails[0]?.fileStoreId) {
         let facilityFound = false;

    resources.forEach((resource: any) => {
        if (resource.type === 'facility') {
            resource.filestoreId = fileDetails[0].fileStoreId;
            resource.resourceId = resourceDetailsId;
            facilityFound = true;
        }
    });

    if (!facilityFound) {
        // Append a new object if no 'facility' resource was found
        resources.push({
            type: 'facility',
            filename: 'Facility Template (29).xlsx',
            filestoreId: fileDetails[0].fileStoreId,
            resourceId: resourceDetailsId
        });
    }
    } else {
        console.error("Invalid structure in CampaignDetails or fileDetails. Ensure both are non-empty arrays.");
    }
    // Get the current date
    const currentDate = new Date();

    // Set to the next day
    const nextDay = new Date(currentDate);
    nextDay.setDate(currentDate.getDate() + 1);

    const newEndDate = new Date(currentDate);
    newEndDate.setDate(currentDate.getDate() + 3);

    // Convert to epoch time in milliseconds
    const nextDayEpoch = nextDay.getTime();
    const newEndDateEpoch = newEndDate.getTime();
    request.body.CampaignDetails.startDate = nextDayEpoch;
    request.body.CampaignDetails.endDate = newEndDateEpoch;
    await updateProjectTypeCampaignService(request);

}

function filterFacilityData(sheet: any) {
    const headers = ["Facility Code", "Facility Name", "Facility Type", "Facility Status", "Capacity (Units: Bales for Bednets/ SPAQ Blister for SMC)", "Boundary Code (Mandatory)", "Facility Usage"];
    let data = [headers];
    sheet.forEach((element: any, index: any) => {
        if (index > 0 && element[0] !== null) {
            const arr = [element[0], element[1], element[2], element[3], element[4], null, element[5]];
            data.push(arr);
        }
    });
    return data;
}

function getPlanFacilityMap(planFacility: any) {
    const planFacilityMap = new Map();
    planFacility.forEach((facility: any) => {
        planFacilityMap.set(facility.facilityId, facility.serviceBoundaries.join(','));
    });
    return planFacilityMap;
}

function fillFacilitySheetData(modifiedProcessedFacilitySheetData: any, planFacilityMap: Map<any, any>) {
    modifiedProcessedFacilitySheetData.forEach((facility: any, index: any) => {
        const facilityKey = facility[0];
        if (planFacilityMap.has(facilityKey) && planFacilityMap.get(facilityKey) !== '') {
            facility[5] = planFacilityMap.get(facilityKey);
        } else if (index > 0) {
            facility[6] = 'Inactive';
        }
    });
    return modifiedProcessedFacilitySheetData;
}


const getSheetDataMP = async (
    fileUrl: string,
    sheetName: string,
    getRow = false,
    createAndSearchConfig?: any,
    localizationMap?: { [key: string]: string }
) => {
    // Retrieve workbook using the getExcelWorkbookFromFileURL function
    const localizedSheetName = getLocalizedName(sheetName, localizationMap);
    const workbook: any = await getExcelWorkbookFromFileURL(fileUrl, localizedSheetName);

    const worksheet: any = workbook.getWorksheet(localizedSheetName);

    // If parsing array configuration is provided, validate first row of each column
    // validateFirstRowColumn(createAndSearchConfig, worksheet, localizationMap);

    // Collect sheet data by iterating through rows and cells
    const sheetData = getSheetDataFromWorksheet(worksheet);
    return sheetData;
};


async function validateFacilitySheet(request: any) {
    const { tenantId } = request.body.MicroplanDetails;
    request.body.ResourceDetails = {
        tenantId: tenantId,
        type: "facility",
        fileStoreId: request.body.fileDetails[0].fileStoreId,
        action: "validate",
        campaignId: request.body.MicroplanDetails.campaignId,
        hierarchyType: request.body.CampaignDetails.hierarchyType,
        additionalDetails: {}
    };
    const resourceDetails = await createDataService(request);
    return resourceDetails;
}



export {
    generateProcessedFileAndPersist,
    convertToTypeData,
    getChildParentMap,
    addBoundaryCodeToData,
    prepareDataForExcel,
    extractCodesFromBoundaryRelationshipResponse,
    searchProjectCampaignResourcData,
    processDataSearchRequest,
    getCodeMappingsOfExistingBoundaryCodes,
    processBasedOnAction,
    appendSheetsToWorkbook,
    generateFilteredBoundaryData,
    generateHierarchy,
    createBoundaryMap,
    autoGenerateBoundaryCodes,
    convertSheetToDifferentTabs,
    getBoundaryDataAfterGeneration,
    boundaryBulkUpload,
    enrichAndPersistCampaignWithError,
    getLocalizedName,
    reorderBoundaries,
    reorderBoundariesOfDataAndValidate,
    getTargetBoundariesRelatedToCampaignId,
    getFiltersFromCampaignSearchResponse,
    getConfigurableColumnHeadersBasedOnCampaignType,
    getFinalValidHeadersForTargetSheetAsPerCampaignType,
    getDifferentTabGeneratedBasedOnConfig,
    checkIfSourceIsMicroplan,
    getBoundaryOnWhichWeSplit,
    createIdRequests,
    createUniqueUserNameViaIdGen,
    getRootBoundaryCode,
    boundaryGeometryManagement,
    getResourceDetails,
    enrichInnerCampaignDetails,
    processFetchMicroPlan
}




