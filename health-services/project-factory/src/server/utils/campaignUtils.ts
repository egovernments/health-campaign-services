import { defaultheader, httpRequest } from "./request";
import config from "../config/index";
import { v4 as uuidv4 } from "uuid";
import { produceModifiedMessages } from "../kafka/Producer";
import {
  getCampaignSearchResponse,
  getHierarchy,
  handleResouceDetailsError
} from "../api/campaignApis";
import {
  getCampaignNumber,
  createAndUploadFile,
  createExcelSheet,
  getAutoGeneratedBoundaryCodesHandler,
  createBoundaryEntities,
  getTargetSheetDataAfterCode,
  callMdmsTypeSchema,
  getSheetDataFromWorksheet,
  getTargetWorkbook,
  createAndUploadJsonFile,
  createBoundaryRelationship,
  getSheetData,
  searchMDMS
} from "../api/genericApis";
import { getFormattedStringForDebug, logger } from "./logger";
import createAndSearch from "../config/createAndSearch";
import {
  addDataToSheet,
  createBoundaryDataMainSheet,
  createReadMeSheet,
  findMapValue,
  getConfigurableColumnHeadersFromSchemaForTargetSheet,
  getLocalizedHeaders,
  getLocalizedMessagesHandler,
  getMdmsDataBasedOnCampaignType,
  modifyBoundaryData,
  replicateRequest,
  throwError,
} from "./genericUtils";
import { executeQuery } from "./db";
import {
  campaignDetailsTransformer,
  genericResourceTransformer,
} from "./transforms/searchResponseConstructor";
import { transformAndCreateLocalisation } from "./transforms/localisationMessageConstructor";
import {
  campaignProcessStatus,
  campaignStatuses,
  headingMapping,
  processNamesConstantsInOrder,
  processTrackStatuses,
  processTrackTypes,
  resourceDataStatuses,
  usageColumnStatus,
} from "../config/constants";
import { getBoundaryTabName } from "./boundaryUtils";
import {
  searchProjectTypeCampaignService,
  updateProjectTypeCampaignService,
} from "../service/campaignManageService";
import {
  validateBoundaryOfResouces,
  validateBoundarySheetDataInCreateFlow,
} from "../validators/campaignValidators";
import {
  getColumnIndexByHeader,
  getExcelWorkbookFromFileURL,
  getNewExcelWorkbook,
  lockTargetFields,
  updateFontNameToRoboto,
} from "./excelUtils";
import {
  areBoundariesSame,
  callGenerate,
  callGenerateIfBoundariesOrCampaignTypeDiffer,
} from "./generateUtils";
import { checkIfProcessIsCompleted, checkifProcessIsFailed, createProcessTracks, markProcessStatus, persistProcessStatuses, persistTrack } from "./processTrackUtils";
import {
  generateDynamicTargetHeaders,
  isDynamicTargetTemplateForProjectType,
  updateTargetColumnsIfDeliveryConditionsDifferForSMC,
} from "./targetUtils";
import {
  callGenerateWhenChildCampaigngetsCreated,
  getBoundariesFromCampaignSearchResponse,
  hideColumnsOfProcessedFile,
  modifyNewSheetData,
  processResources,
  unhideColumnsOfProcessedFile,
} from "./onGoingCampaignUpdateUtils";
import { changeCreateDataForMicroplan, lockSheet } from "./microplanUtils";
const _ = require("lodash");
import { searchDataService } from "../service/dataManageService";
import { defaultRequestInfo, searchMDMSDataViaV2Api } from "../api/coreApis";
import { deleteRedisCacheKeysWithPrefix } from "./redisUtils";
import {
  fetchFacilityData,
  fetchTargetData,
  fetchUserData,
} from "./microplanIntergration";
import { getBoundaryRelationshipData } from "../api/boundaryApis";
import { enrichRootProjectId, persistCreateResourceIdForBoundaryWithTarget, processSubProjectCreationFromConsumer } from "./projectCampaignUtils";
import { processCampaignMappings, processEmployeeCreation, processFacilityCreation, processProjectCreation } from "../service/mainProcessService";
import {  createCampaignEmployees, persistCreateResourceIdForUser, processSubEmployeeCreationFromConsumer } from "./campaignEmployeesUtils";
import { createCampaignFacilities, persistCreateResourceIdForFacility, processSubFacilityCreationFromConsumer } from "./campaignFacilitiesUtils";
import { createCampaignMappings, processSubMappingFromConsumer } from "./campaignMappingProcessUtils";

function updateRange(range: any, worksheet: any) {
  let maxColumnIndex = 0;

  // Iterate through each row to find the last column with data
  for (let row = range.s.r; row <= range.e.r; row++) {
    const rowCells = worksheet.getRow(row + 1); // ExcelJS rows are 1-based
    rowCells.eachCell((cell: any, colNumber: number) => {
      if (cell.value !== undefined && colNumber > maxColumnIndex) {
        maxColumnIndex = colNumber;
      }
    });
  }

  // Update the end column of the range with the maximum column index found
  range.e.c = maxColumnIndex;
}

function findAndChangeColumns(worksheet: any, columns: any) {
  const firstRow = worksheet.getRow(1);
  firstRow.eachCell((cell: any, colNumber: number) => {
    if (cell.value === "#status#") {
      columns.statusColumn = cell.address.replace(/\d+/g, "");
      // Set the cell color to green
      cell.fill = {
        type: "pattern",
        pattern: "solid",
        fgColor: { argb: "CCCC00" },
      };
      // Delete status column cells in subsequent rows
      worksheet.eachRow((row: any, rowIndex: number) => {
        if (rowIndex > 1) {
          const statusCell = row.getCell(colNumber);
          statusCell.value = undefined;
        }
      });
    }
    if (cell.value === "#errorDetails#") {
      columns.errorDetailsColumn = cell.address.replace(/\d+/g, "");
      // Set the cell color to green
      cell.fill = {
        type: "pattern",
        pattern: "solid",
        fgColor: { argb: "CCCC00" },
      };
      // Delete error details column cells in subsequent rows
      worksheet.eachRow((row: any, rowIndex: number) => {
        if (rowIndex > 1) {
          const errorDetailsCell = row.getCell(colNumber);
          errorDetailsCell.value = undefined;
        }
      });
    }
  });
}

function makeColumns(worksheet: any, range: any, columns: any) {
  // If the status column doesn't exist, calculate the next available column
  if (!columns?.statusColumn) {
    const emptyColumnIndex = range.e.c;
    columns.statusColumn = String.fromCharCode(65 + (emptyColumnIndex + 1));
    const statusCell = worksheet.getCell(`${columns.statusColumn}1`);
    statusCell.value = "#status#";
    statusCell.fill = {
      type: "pattern",
      pattern: "solid",
      fgColor: { argb: "CCCC00" },
    };
    statusCell.font = { bold: true };
    worksheet.getColumn(columns.statusColumn).width = 40;
  }

  // Calculate errorDetails column one column to the right of status column
  if (!columns?.errorDetailsColumn) {
    columns.errorDetailsColumn = String.fromCharCode(
      columns?.statusColumn.charCodeAt(0) + 1
    );
    const errorDetailsCell = worksheet.getCell(
      `${columns.errorDetailsColumn}1`
    );
    errorDetailsCell.value = "#errorDetails#";
    errorDetailsCell.fill = {
      type: "pattern",
      pattern: "solid",
      fgColor: { argb: "CCCC00" },
    };
    errorDetailsCell.font = { bold: true };
    worksheet.getColumn(columns.errorDetailsColumn).width = 40;
  }
}

function findColumns(worksheet: any) {
  const range = {
    s: { r: 0, c: 0 },
    e: { r: worksheet.rowCount - 1, c: worksheet.columnCount - 1 },
  };

  // Check if the status column already exists in the first row
  var columns = {};

  findAndChangeColumns(worksheet, columns);

  makeColumns(worksheet, range, columns);

  updateRange(range, worksheet);

  return columns;
}

function enrichErrors(
  errorData: any,
  worksheet: any,
  statusColumn: any,
  errorDetailsColumn: any,
  additionalDetailsErrors: any,
  createAndSearchConfig: any,
  localizationMap?: { [key: string]: string }
) {
  if (errorData) {
    errorData.forEach((error: any) => {
      const rowIndex = error.rowNumber; // ExcelJS rows are 1-based
      const statusCell = worksheet.getCell(`${statusColumn}${rowIndex}`);
      const errorDetailsCell = worksheet.getCell(
        `${errorDetailsColumn}${rowIndex}`
      );
      statusCell.value = error.status;
      errorDetailsCell.value = error.errorDetails;

      if (
        error?.status &&
        !(error?.status === "CREATED" || error?.status === "VALID")
      ) {
        additionalDetailsErrors.push(error);
      }
    });
    if (errorData.some((error: any) => error?.status === "CREATED")) {
      const uniqueIdentifierFirstRowCell = `${createAndSearchConfig?.uniqueIdentifierColumn}1`;
      const columnName = getLocalizedName(
        createAndSearchConfig?.uniqueIdentifierColumnName,
        localizationMap
      );
      const uniqueIdentifierCell = worksheet.getCell(
        uniqueIdentifierFirstRowCell
      );
      uniqueIdentifierCell.value = columnName;

      // Set the cell color to green
      uniqueIdentifierCell.fill = {
        type: "pattern",
        pattern: "solid",
        fgColor: { argb: "ff9248" }, // Green color
      };
      uniqueIdentifierCell.font = { bold: true };
      // Hide the unique identifier column
      worksheet.getColumn(
        createAndSearchConfig?.uniqueIdentifierColumn
      ).hidden = true;
    }
    errorData.forEach((error: any) => {
      const rowIndex = error.rowNumber;
      if (error.isUniqueIdentifier) {
        const uniqueIdentifierCell = worksheet.getCell(
          `${createAndSearchConfig.uniqueIdentifierColumn}${rowIndex}`
        );
        uniqueIdentifierCell.value = error.uniqueIdentifier;
        if (createAndSearchConfig?.activeColumn) {
          const activeCell = worksheet.getCell(
            `${createAndSearchConfig.activeColumn}${rowIndex}`
          );
          activeCell.value = usageColumnStatus.active;
        }
      }
    });
  }
}

function enrichActiveAndUUidColumn(
  worksheet: any,
  createAndSearchConfig: any,
  request: any
) {
  if (
    createAndSearchConfig?.activeColumn &&
    request?.body?.dataToCreate &&
    request?.body?.dataToCreate?.length > 0 &&
    request?.body?.ResourceDetails?.type == "user"
  ) {
    const dataToCreate = request.body.dataToCreate;
    for (const data of dataToCreate) {
      const rowNumber = data["!row#number!"];
      const activeCell = worksheet.getCell(
        `${createAndSearchConfig?.activeColumn}${rowNumber}`
      );
      const uniqueIdentifierCell = worksheet.getCell(
        `${createAndSearchConfig?.uniqueIdentifierColumn}${rowNumber}`
      );
      activeCell.value = usageColumnStatus.active;
      uniqueIdentifierCell.value = data["userServiceUuid"] || data?.user?.["userServiceUuid"];
    }
  }
}

function deterMineLastColumnAndEnrichUserDetails(
  worksheet: any,
  errorDetailsColumn: number,
  userNameAndPassword:
    | { rowNumber: number; userName: string; password: string }[]
    | undefined,
  request: any,
  createAndSearchConfig: { uniqueIdentifierColumn?: number }
): string {
  // Determine the last column
  let lastColumn: any = errorDetailsColumn;
  if (createAndSearchConfig?.uniqueIdentifierColumn !== undefined) {
    lastColumn =
      createAndSearchConfig?.uniqueIdentifierColumn > errorDetailsColumn
        ? createAndSearchConfig?.uniqueIdentifierColumn
        : errorDetailsColumn;
  }

  // Default columns
  let usernameColumn = "J";
  let passwordColumn = "K";

  // Update columns if the request indicates a different source
  if (
    request?.body?.ResourceDetails?.additionalDetails?.source == "microplan"
  ) {
    usernameColumn = "F";
    passwordColumn = "G";
  }

  // Populate username and password columns if data is provided
  if (userNameAndPassword) {
    // Set headers with formatting
    const setCellHeader = (cell: string) => {
      worksheet.getCell(cell).value =
        cell === usernameColumn + "1" ? "UserName" : "Password";
      worksheet.getCell(cell).fill = {
        type: "pattern",
        pattern: "solid",
        fgColor: { argb: "ff9248" }, // Green color
      };
      worksheet.getCell(cell).font = { bold: true };
      const columnLetter = cell.replace(/\d+$/, "");
      worksheet.getColumn(columnLetter).width = 40;
    };

    setCellHeader(usernameColumn + "1");
    setCellHeader(passwordColumn + "1");

    // Set values
    userNameAndPassword.forEach((data) => {
      const rowIndex = data.rowNumber;
      worksheet.getCell(`${usernameColumn}${rowIndex}`).value = data.userName;
      worksheet.getCell(`${passwordColumn}${rowIndex}`).value = data.password;
    });

    // Update lastColumn based on the password column
    lastColumn = passwordColumn;
  }

  return lastColumn;
}

function adjustRef(worksheet: any, lastColumn: any) {
  const range = getSheetDataFromWorksheet(worksheet).filter(
    (row: any) => row
  ).length; // Get the number of used rows
  worksheet.views = [
    { state: "frozen", ySplit: 1, topLeftCell: "A2", activeCell: "A2" },
  ];
  worksheet.autoFilter = {
    from: {
      row: 1,
      column: 1,
    },
    to: {
      row: range,
      column: worksheet.getColumn(lastColumn).number,
    },
  };
}

function processErrorData(
  request: any,
  createAndSearchConfig: any,
  workbook: any,
  sheetName: any,
  localizationMap?: { [key: string]: string }
) {
  const worksheet = workbook.getWorksheet(sheetName);
  var errorData = request.body.sheetErrorDetails;
  const userNameAndPassword = request.body.userNameAndPassword;
  const columns: any = findColumns(worksheet);
  const statusColumn = columns.statusColumn;
  const errorDetailsColumn = columns.errorDetailsColumn;
  const additionalDetailsErrors: any[] = [];
  errorData = mergeErrors(errorData);
  enrichErrors(
    errorData,
    worksheet,
    statusColumn,
    errorDetailsColumn,
    additionalDetailsErrors,
    createAndSearchConfig,
    localizationMap
  );
  enrichActiveAndUUidColumn(worksheet, createAndSearchConfig, request);

  request.body.additionalDetailsErrors = request?.body?.additionalDetailsErrors
    ? request?.body?.additionalDetailsErrors.concat(additionalDetailsErrors)
    : additionalDetailsErrors;

  // Determine the last column to set the worksheet ref
  const lastColumn = deterMineLastColumnAndEnrichUserDetails(
    worksheet,
    errorDetailsColumn,
    userNameAndPassword,
    request,
    createAndSearchConfig
  );

  // Adjust the worksheet ref to include the last column
  adjustRef(worksheet, lastColumn);
  updateFontNameToRoboto(worksheet);

  workbook.xlsx.writeBuffer();
}

function mergeErrors(errorData: any) {
  const errorMap: any = {};

  errorData.forEach((item: any) => {
    const { rowNumber, sheetName, status, errorDetails, ...rest } = item;

    // If the rowNumber already exists, merge the errorDetails
    if (errorMap[rowNumber]) {
      errorMap[rowNumber].errorDetails += "; " + errorDetails;
    } else {
      // If not, add a new entry
      errorMap[rowNumber] = {
        rowNumber,
        sheetName,
        status,
        errorDetails,
        ...rest,
      };
    }
  });

  // Convert the errorMap back into an array
  return Object.values(errorMap);
}

function processErrorDataForEachSheets(
  request: any,
  createAndSearchConfig: any,
  workbook: any,
  sheetName: any
) {
  const desiredSheet = workbook.getWorksheet(sheetName);
  const columns: any = findColumns(desiredSheet);
  const statusColumn = columns.statusColumn;
  const errorDetailsColumn = columns.errorDetailsColumn;
  const userNameAndPassword = request?.body?.userNameAndPassword;

  var errorData = request.body.sheetErrorDetails.filter(
    (error: any) => error.sheetName === sheetName
  );
  const additionalDetailsErrors: any = [];
  errorData = mergeErrors(errorData);
  if (errorData) {
    errorData.forEach((error: any) => {
      const rowIndex = error.rowNumber;
      if (error.isUniqueIdentifier) {
        const uniqueIdentifierCell =
          createAndSearchConfig.uniqueIdentifierColumn + rowIndex;
        desiredSheet.getCell(uniqueIdentifierCell).value =
          error.uniqueIdentifier;
      }

      const statusCell = statusColumn + rowIndex;
      const errorDetailsCell = errorDetailsColumn + rowIndex;
      desiredSheet.getCell(statusCell).value = error.status;
      desiredSheet.getCell(errorDetailsCell).value = error.errorDetails;

      if (!(error.status === "CREATED" || error.status === "VALID")) {
        additionalDetailsErrors.push(error);
      }
    });
  }
  if (userNameAndPassword) {
    var newUserNameAndPassword: any = [];
    for (const data of userNameAndPassword) {
      const rowArray = data.rowNumber;
      for (let i = 0; i < rowArray.length; i++) {
        if (rowArray[i].sheetName == sheetName) {
          newUserNameAndPassword.push({ ...data, rowNumber: rowArray[i].row });
        }
      }
    }
  }
  deterMineLastColumnAndEnrichUserDetails(
    desiredSheet,
    errorDetailsColumn,
    newUserNameAndPassword,
    request,
    createAndSearchConfig
  );
  request.body.additionalDetailsErrors = request?.body?.additionalDetailsErrors
    ? request?.body?.additionalDetailsErrors.concat(additionalDetailsErrors)
    : additionalDetailsErrors;
  updateFontNameToRoboto(desiredSheet);
  workbook.worksheets[sheetName] = desiredSheet;
}

async function updateStatusFile(
  request: any,
  localizationMap?: { [key: string]: string }
) {
  const fileStoreId = request?.body?.ResourceDetails?.fileStoreId;
  const tenantId = request?.body?.ResourceDetails?.tenantId;
  const createAndSearchConfig =
    createAndSearch[request?.body?.ResourceDetails?.type];
  const fileResponse = await httpRequest(
    config.host.filestore + config.paths.filestore + "/url",
    {},
    { tenantId: tenantId, fileStoreIds: fileStoreId },
    "get"
  );
  const isLockSheetNeeded =
    request?.body?.ResourceDetails?.additionalDetails?.source == "microplan"
      ? true
      : false;

  if (!fileResponse?.fileStoreIds?.[0]?.url) {
    throwError("FILE", 500, "INVALID_FILE");
  }
  const fileUrl = fileResponse?.fileStoreIds?.[0]?.url;
  const sheetName = createAndSearchConfig?.parseArrayConfig?.sheetName;
  const localizedSheetName = getLocalizedName(sheetName, localizationMap);
  const workbook: any = await getExcelWorkbookFromFileURL(
    fileUrl,
    localizedSheetName
  );
  const worksheet: any = workbook.getWorksheet(localizedSheetName);
  if (request?.body?.ResourceDetails?.type == "user") {
    const columnsToUnhide = ["G", "H", "J", "K"];
    unhideColumnsOfProcessedFile(worksheet, columnsToUnhide);
  }
  processErrorData(
    request,
    createAndSearchConfig,
    workbook,
    localizedSheetName,
    localizationMap
  );

  // Set column widths
  const columnWidths = Array(12).fill({ width: 30 });
  columnWidths.forEach((colWidth, index) => {
    if (worksheet.getColumn(index + 1)) {
      worksheet.getColumn(index + 1).width = colWidth.width;
    }
  });
  if (isLockSheetNeeded) lockSheet(request, workbook);
  const responseData = await createAndUploadFile(workbook, request);

  logger.info("File updated successfully:" + JSON.stringify(responseData));
  if (responseData?.[0]?.fileStoreId) {
    request.body.ResourceDetails.processedFileStoreId =
      responseData?.[0]?.fileStoreId;
  } else {
    throwError("FILE", 500, "STATUS_FILE_CREATION_ERROR");
  }
}
async function updateStatusFileForEachSheets(
  request: any,
  localizationMap?: { [key: string]: string }
) {
  const fileStoreId = request?.body?.ResourceDetails?.fileStoreId;
  const tenantId = request?.body?.ResourceDetails?.tenantId;
  const createAndSearchConfig =
    createAndSearch[request?.body?.ResourceDetails?.type];
  const fileResponse = await httpRequest(
    config.host.filestore + config.paths.filestore + "/url",
    {},
    { tenantId: tenantId, fileStoreIds: fileStoreId },
    "get"
  );
  const isLockSheetNeeded =
    request?.body?.ResourceDetails?.additionalDetails?.source == "microplan"
      ? true
      : false;

  if (!fileResponse?.fileStoreIds?.[0]?.url) {
    throwError("FILE", 500, "INVALID_FILE");
  }

  const fileUrl = fileResponse?.fileStoreIds?.[0]?.url;

  const workbook: any = await getExcelWorkbookFromFileURL(fileUrl, "");

  const sheetNames = workbook.worksheets.map(
    (worksheet: any) => worksheet.name
  );
  const localizedSheetNames = getLocalizedHeaders(sheetNames, localizationMap);

  const sheetErrorDetails = request?.body?.sheetErrorDetails;
  if (sheetErrorDetails && sheetErrorDetails?.length > 0) {
    const firstError = sheetErrorDetails[0];
    if (Array.isArray(firstError?.rowNumber)) {
      var newSheetErrorDetails: any = [];
      for (const error of sheetErrorDetails) {
        for (let i = 0; i < error.rowNumber.length; i++) {
          newSheetErrorDetails.push({
            ...error,
            rowNumber: error.rowNumber[i]?.row,
            sheetName: error.rowNumber[i]?.sheetName,
          });
        }
      }
      request.body.sheetErrorDetails = newSheetErrorDetails;
    }
  }

  localizedSheetNames.forEach((sheetName: any) => {
    if (
      sheetName !==
      getLocalizedName(config?.boundary?.boundaryTab, localizationMap) &&
      sheetName !==
      getLocalizedName(config.values.readMeTab, localizationMap) &&
      sheetName !==
      getLocalizedName("USER_MICROPLAN_SHEET_ROLES", localizationMap)
    ) {
      processErrorDataForEachSheets(
        request,
        createAndSearchConfig,
        workbook,
        sheetName
      );
    }
  });
  if (isLockSheetNeeded) lockSheet(request, workbook);
  const responseData = await createAndUploadFile(workbook, request);
  logger.info("File updated successfully:" + JSON.stringify(responseData));
  if (responseData?.[0]?.fileStoreId) {
    request.body.ResourceDetails.processedFileStoreId =
      responseData?.[0]?.fileStoreId;
  } else {
    throwError("FILE", 500, "STATUS_FILE_CREATION_ERROR");
  }
}

export function convertToType(dataToSet: any, type: any) {
  switch (type) {
    case "string":
      return String(dataToSet);
    case "number":
      return Number(dataToSet);
    case "boolean":
      // Convert to boolean assuming any truthy value should be true and falsy should be false
      return Boolean(dataToSet);
    // Add more cases if needed for other types
    default:
      // If type is not recognized, keep dataToSet as it is
      return dataToSet;
  }
}

function setTenantId(
  resultantElement: any,
  requestBody: any,
  createAndSearchConfig: any
) {
  if (createAndSearchConfig?.parseArrayConfig?.tenantId) {
    const tenantId = _.get(
      requestBody,
      createAndSearchConfig?.parseArrayConfig?.tenantId?.getValueViaPath
    );
    _.set(
      resultantElement,
      createAndSearchConfig?.parseArrayConfig?.tenantId?.resultantPath,
      tenantId
    );
  }
}

async function processData(
  requestBody: any,
  dataFromSheet: any[],
  createAndSearchConfig: any,
  localizationMap?: { [key: string]: string }
) {
  const parseLogic = createAndSearchConfig?.parseArrayConfig?.parseLogic;
  const requiresToSearchFromSheet =
    createAndSearchConfig?.requiresToSearchFromSheet;
  const isSourceMicroplan =
    requestBody?.ResourceDetails?.additionalDetails?.source == "microplan";
  var createData = [],
    searchData = [];
  for (const data of dataFromSheet) {
    const resultantElement: any = {};
    for (const element of parseLogic) {
      if (element?.resultantPath) {
        const localizedSheetColumnName = getLocalizedName(
          element.sheetColumnName,
          localizationMap
        );
        let dataToSet = _.get(data, localizedSheetColumnName);
        if (element.conversionCondition) {
          dataToSet = element.conversionCondition[dataToSet];
        }
        if (element.type) {
          dataToSet = convertToType(dataToSet, element.type);
        }
        _.set(resultantElement, element.resultantPath, dataToSet);
      }
    }
    resultantElement["!row#number!"] = data["!row#number!"];
    var addToCreate = true;
    if (requiresToSearchFromSheet) {
      for (const key of requiresToSearchFromSheet) {
        const localizedSheetColumnName = getLocalizedName(
          key.sheetColumnName,
          localizationMap
        );
        if (data[localizedSheetColumnName]) {
          if (isSourceMicroplan) {
            changeCreateDataForMicroplan(
              requestBody,
              resultantElement,
              data,
              localizationMap
            );
          }
          searchData.push(resultantElement);
          addToCreate = false;
          break;
        }
      }
    }
    if (addToCreate) {
      if (isSourceMicroplan) {
        changeCreateDataForMicroplan(
          requestBody,
          resultantElement,
          data,
          localizationMap
        );
      }
      createData.push(resultantElement);
    }
  }
  return { searchData, createData };
}

function setTenantIdAndSegregate(
  processedData: any,
  createAndSearchConfig: any,
  requestBody: any
) {
  for (const resultantElement of processedData.createData) {
    setTenantId(resultantElement, requestBody, createAndSearchConfig);
  }
  for (const resultantElement of processedData.searchData) {
    setTenantId(resultantElement, requestBody, createAndSearchConfig);
  }
  return processedData;
}

// Original function divided into two parts
async function convertToTypeData(
  dataFromSheet: any[],
  createAndSearchConfig: any,
  requestBody: any,
  localizationMap?: { [key: string]: string }
) {
  const processedData = await processData(
    requestBody,
    dataFromSheet,
    createAndSearchConfig,
    localizationMap
  );
  return setTenantIdAndSegregate(
    processedData,
    createAndSearchConfig,
    requestBody
  );
}

function updateActivityResourceId(request: any) {
  if (request?.body?.Activities && Array.isArray(request?.body?.Activities)) {
    for (const activity of request?.body?.Activities) {
      activity.resourceDetailsId = request?.body?.ResourceDetails?.id;
    }
  }
}

async function generateProcessedFileAndPersist(
  request: any,
  localizationMap?: { [key: string]: string }
) {
  if (
    request.body.ResourceDetails.type == "boundaryWithTarget" ||
    (request?.body?.ResourceDetails?.additionalDetails?.source == "microplan" &&
      request.body.ResourceDetails.type == "user")
  ) {
    await updateStatusFileForEachSheets(request, localizationMap);
  } else {
    if (
      request.body.ResourceDetails.type !== "boundary" &&
      request.body.ResourceDetails.type !== "boundaryManagement"
    ) {
      await updateStatusFile(request, localizationMap);
    }
  }
  updateActivityResourceId(request);
  request.body.ResourceDetails = {
    ...request?.body?.ResourceDetails,
    status:
      request.body.ResourceDetails.status != resourceDataStatuses.invalid
        ? resourceDataStatuses.completed
        : resourceDataStatuses.invalid,
    auditDetails: {
      ...request?.body?.ResourceDetails?.auditDetails,
      lastModifiedBy: request?.body?.RequestInfo?.userInfo?.uuid,
      lastModifiedTime: Date.now(),
    },
    additionalDetails: {
      ...request?.body?.ResourceDetails?.additionalDetails,
      sheetErrors: request?.body?.additionalDetailsErrors,
      source:
        request?.body?.ResourceDetails?.additionalDetails?.source == "microplan"
          ? "microplan"
          : null,
    },
  };
  if (
    request?.body?.ResourceDetails?.status === resourceDataStatuses.completed &&
    request?.body?.ResourceDetails?.type === "boundaryManagement"
  ) {
    // delete redis cache key with prefix boundaryRelatiionshipSearch
    await deleteRedisCacheKeysWithPrefix("boundaryRelationShipSearch");

    logger.info(
      "calling generate after boundary data uploaded under type boundary management"
    );
    const newRequestBody = {
      RequestInfo: request?.body?.RequestInfo,
    };
    const params = {
      type: request?.body?.ResourceDetails?.type,
      tenantId: request?.body?.ResourceDetails?.tenantId,
      forceUpdate: "true",
      hierarchyType: request?.body?.ResourceDetails?.hierarchyType,
      campaignId: "default",
    };
    const newRequestBoundary = replicateRequest(
      request,
      newRequestBody,
      params
    );
    setTimeout(async () => {
      // Code to be executed after 10 seconds
      logger.info("Timeout of 10 sec after boundary data creation");
      await callGenerate(
        newRequestBoundary,
        request?.body?.ResourceDetails?.type
      );
    }, 10000);
  }
  const persistMessage: any = { ResourceDetails: request.body.ResourceDetails };
  if (request?.body?.ResourceDetails?.action == "create") {
    persistMessage.ResourceDetails.additionalDetails = {
      source:
        request?.body?.ResourceDetails?.additionalDetails?.source == "microplan"
          ? "microplan"
          : null,
      fileName:
        request?.body?.ResourceDetails?.additionalDetails?.fileName || null,
    };
  }
  await produceModifiedMessages(
    persistMessage,
    config?.kafka?.KAFKA_UPDATE_RESOURCE_DETAILS_TOPIC
  );
  logger.info(
    `ResourceDetails to persist : ${request.body.ResourceDetails.type}`
  );
  if (
    request?.body?.Activities &&
    Array.isArray(request?.body?.Activities) &&
    request?.body?.Activities.length > 0
  ) {
    logger.info("Activities to persist : ");
    logger.debug(getFormattedStringForDebug(request?.body?.Activities));
    logger.info(`Waiting for 2 seconds`);
    await new Promise((resolve) => setTimeout(resolve, 2000));
    const activities = request?.body?.Activities;
    for (let i = 0; i < activities.length; i += 10) {
      const chunk = activities.slice(i, Math.min(i + 10, activities.length));
      const activityObject: any = { Activities: chunk };
      await produceModifiedMessages(
        activityObject,
        config.kafka.KAFKA_CREATE_RESOURCE_ACTIVITY_TOPIC
      );
    }
  }
}

function getRootBoundaryCode(boundaries: any[] = []) {
  for (const boundary of boundaries) {
    if (boundary.isRoot) {
      return boundary.code;
    }
  }
  return "";
}

export function getRootBoundaryType(boundaries: any[] = []) {
  for (const boundary of boundaries) {
    if (boundary.isRoot) {
      return boundary.type;
    }
  }
  return "";
}

async function enrichAndPersistCampaignWithError(requestBody: any, error: any) {
  if (requestBody?.parentCampaign) {
    await makeParentInactiveOrActive(requestBody, true);
  }
  requestBody.CampaignDetails = requestBody?.CampaignDetails || {};
  const action = requestBody?.CampaignDetails?.action;
  requestBody.CampaignDetails.campaignNumber =
    requestBody?.CampaignDetails?.campaignNumber || null;
  requestBody.CampaignDetails.campaignDetails = requestBody?.CampaignDetails
    ?.campaignDetails || {
    deliveryRules: requestBody?.CampaignDetails?.deliveryRules,
    resources: requestBody?.CampaignDetails?.resources || [],
    boundaries: requestBody?.CampaignDetails?.boundaries || [],
  };
  requestBody.CampaignDetails.status = campaignStatuses?.failed;
  // requestBody.CampaignDetails.isActive = false;
  requestBody.CampaignDetails.boundaryCode =
    getRootBoundaryCode(requestBody?.CampaignDetails?.boundaries) || null;
  requestBody.CampaignDetails.projectType =
    requestBody?.CampaignDetails?.projectType || null;
  requestBody.CampaignDetails.hierarchyType =
    requestBody?.CampaignDetails?.hierarchyType || null;
  requestBody.CampaignDetails.additionalDetails =
    requestBody?.CampaignDetails?.additionalDetails || {};
  requestBody.CampaignDetails.startDate =
    requestBody?.CampaignDetails?.startDate || null;
  requestBody.CampaignDetails.endDate =
    requestBody?.CampaignDetails?.endDate || null;
  requestBody.CampaignDetails.auditDetails = {
    createdBy: requestBody?.RequestInfo?.userInfo?.uuid,
    createdTime: Date.now(),
    lastModifiedBy: requestBody?.RequestInfo?.userInfo?.uuid,
    lastModifiedTime: Date.now(),
  };
  if (action == "create" && !requestBody?.CampaignDetails?.projectId) {
    await enrichRootProjectId(requestBody?.CampaignDetails);
  } else if (!requestBody?.CampaignDetails?.projectId) {
    requestBody.CampaignDetails.projectId = null;
  }
  requestBody.CampaignDetails.additionalDetails = {
    ...requestBody?.CampaignDetails?.additionalDetails,
    error: String(
      error?.message + (error?.description ? ` : ${error?.description}` : "") ||
      error
    ),
  };
  requestBody.CampaignDetails.parentId = requestBody?.CampaignDetails?.parentId || null
  const topic = config?.kafka?.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC;
  // wait for 2 seconds
  logger.info(`Waiting for 2 seconds to persist errors`);
  await new Promise((resolve) => setTimeout(resolve, 2000));
  const produceMessage: any = { CampaignDetails: requestBody.CampaignDetails };
  await produceModifiedMessages(produceMessage, topic);
  await persistTrack(
    requestBody?.CampaignDetails?.id,
    processTrackTypes.error,
    processTrackStatuses.failed,
    {
      error: String(
        error?.message +
        (error?.description ? ` : ${error?.description}` : "") || error
      ),
    }
  );
  delete requestBody.CampaignDetails.campaignDetails;
}

async function enrichAndPersistCampaignForCreate(
  requestBody: any,
  firstPersist: boolean = false
) {
  const action = requestBody?.CampaignDetails?.action;
  if (firstPersist) {
    if (!requestBody?.parentCampaign) {
      requestBody.CampaignDetails.campaignNumber = await getCampaignNumber(
        requestBody,
        "CMP-[cy:yyyy-MM-dd]-[SEQ_EG_CMP_ID]",
        "campaign.number",
        requestBody?.CampaignDetails?.tenantId
      );
    } else {
      requestBody.CampaignDetails.campaignNumber =
        requestBody.parentCampaign?.campaignNumber;
      requestBody.CampaignDetails.campaignName =
        requestBody.parentCampaign?.campaignName;
    }
  }
  requestBody.CampaignDetails.campaignDetails = {
    deliveryRules: requestBody?.CampaignDetails?.deliveryRules || [],
    resources: requestBody?.CampaignDetails?.resources || [],
    boundaries: requestBody?.CampaignDetails?.boundaries || [],
  };
  if(requestBody?.CampaignDetails?.status != campaignStatuses.inprogress) {
    requestBody.CampaignDetails.status =
      action == "create" ? campaignStatuses.started : campaignStatuses.drafted;
  }
  requestBody.CampaignDetails.boundaryCode = getRootBoundaryCode(
    requestBody?.CampaignDetails?.boundaries
  );
  requestBody.CampaignDetails.projectType =
    requestBody?.CampaignDetails?.projectType || null;
  requestBody.CampaignDetails.hierarchyType =
    requestBody?.CampaignDetails?.hierarchyType || null;
  requestBody.CampaignDetails.additionalDetails =
    requestBody?.CampaignDetails?.additionalDetails || {};
  requestBody.CampaignDetails.startDate =
    requestBody?.CampaignDetails?.startDate || null;
  requestBody.CampaignDetails.endDate =
    requestBody?.CampaignDetails?.endDate || null;
  requestBody.CampaignDetails.auditDetails = {
    createdBy: requestBody?.RequestInfo?.userInfo?.uuid,
    createdTime: Date.now(),
    lastModifiedBy: requestBody?.RequestInfo?.userInfo?.uuid,
    lastModifiedTime: Date.now(),
  };
  if (
    action == "create" &&
    !requestBody?.CampaignDetails?.projectId &&
    !firstPersist
  ) {
    await enrichRootProjectId(requestBody?.CampaignDetails);
  } else {
    requestBody.CampaignDetails.projectId = null;
  }
  requestBody.CampaignDetails.parentId = requestBody?.CampaignDetails?.parentId || null
  const topic = firstPersist
    ? config?.kafka?.KAFKA_SAVE_PROJECT_CAMPAIGN_DETAILS_TOPIC
    : config?.kafka?.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC;
  delete requestBody.CampaignDetails.codesTargetMapping;
  const produceMessage: any = {
    CampaignDetails: requestBody.CampaignDetails,
  };
  await produceModifiedMessages(produceMessage, topic);
  delete requestBody.CampaignDetails.campaignDetails;
}

function enrichInnerCampaignDetails(
  requestBody: any,
  updatedInnerCampaignDetails: any
) {
  updatedInnerCampaignDetails.resources =
    requestBody?.CampaignDetails?.resources || [];
  updatedInnerCampaignDetails.deliveryRules =
    requestBody?.CampaignDetails?.deliveryRules || [];
  updatedInnerCampaignDetails.boundaries =
    requestBody?.CampaignDetails?.boundaries || [];
}

async function enrichAndPersistCampaignForUpdate(
  request: any
) {
  const action = request?.body?.CampaignDetails?.action;
  const existingCampaignDetails = request?.body?.ExistingCampaignDetails;
  callGenerateIfBoundariesOrCampaignTypeDiffer(request);
  if (existingCampaignDetails) {
    if (areBoundariesSame(existingCampaignDetails?.boundaries, request?.body?.CampaignDetails?.boundaries)) {
      updateTargetColumnsIfDeliveryConditionsDifferForSMC(request);
    }
  }
  const ExistingCampaignDetails = request?.body?.ExistingCampaignDetails;
  var updatedInnerCampaignDetails = {};
  enrichInnerCampaignDetails(request?.body, updatedInnerCampaignDetails);
  request.body.CampaignDetails.campaignNumber =
    ExistingCampaignDetails?.campaignNumber;
  request.body.CampaignDetails.campaignDetails = updatedInnerCampaignDetails;
  if (action === "changeDates") {
    request.body.CampaignDetails.status = request.body.CampaignDetails.status;
  } else if (action === "create") {
    if(request?.body?.CampaignDetails?.status != campaignStatuses.inprogress) {
      request.body.CampaignDetails.status = campaignStatuses.started;
    }
  } else {
    request.body.CampaignDetails.status = campaignStatuses.drafted;
  }
  const boundaryCode = !request?.body?.CampaignDetails?.projectId
    ? getRootBoundaryCode(request.body?.CampaignDetails?.boundaries)
    : request?.body?.CampaignDetails?.boundaryCode ||
    ExistingCampaignDetails?.boundaryCode;
  request.body.CampaignDetails.boundaryCode = boundaryCode;
  request.body.CampaignDetails.startDate =
    request?.body?.CampaignDetails?.startDate ||
    ExistingCampaignDetails?.startDate ||
    null;
  request.body.CampaignDetails.endDate =
    request?.body?.CampaignDetails?.endDate ||
    ExistingCampaignDetails?.endDate ||
    null;
  request.body.CampaignDetails.projectType = request?.body?.CampaignDetails
    ?.projectType
    ? request?.body?.CampaignDetails?.projectType
    : ExistingCampaignDetails?.projectType;
  request.body.CampaignDetails.hierarchyType = request?.body?.CampaignDetails
    ?.hierarchyType
    ? request?.body?.CampaignDetails?.hierarchyType
    : ExistingCampaignDetails?.hierarchyType;
  request.body.CampaignDetails.additionalDetails = request?.body
    ?.CampaignDetails?.additionalDetails
    ? request?.body?.CampaignDetails?.additionalDetails
    : ExistingCampaignDetails?.additionalDetails;
  request.body.CampaignDetails.auditDetails = {
    createdBy: ExistingCampaignDetails?.createdBy,
    createdTime: ExistingCampaignDetails?.createdTime,
    lastModifiedBy: request?.body?.RequestInfo?.userInfo?.uuid,
    lastModifiedTime: Date.now(),
  };
  if (action == "create" && !request?.body?.CampaignDetails?.projectId) {
    await enrichRootProjectId(request.body?.CampaignDetails);
  } else {
    request.body.CampaignDetails.projectId =
      request?.body?.CampaignDetails?.projectId ||
      ExistingCampaignDetails?.projectId ||
      null;
  }
  request.body.CampaignDetails.parentId = request?.body?.CampaignDetails?.parentId || null
  delete request.body.CampaignDetails.codesTargetMapping;
  const producerMessage: any = {
    CampaignDetails: request?.body?.CampaignDetails,
  };
  await produceModifiedMessages(
    producerMessage,
    config?.kafka?.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC
  );
  // delete request.body.ExistingCampaignDetails;
  delete request.body.CampaignDetails.campaignDetails;
}

async function makeParentInactiveOrActive(requestBody: any, active: boolean) {
  let parentCampaign = requestBody?.parentCampaign;
  parentCampaign.isActive = active;
  parentCampaign.campaignDetails = {
    deliveryRules: parentCampaign?.deliveryRules || [],
    resources: parentCampaign?.resources || [],
    boundaries: parentCampaign?.boundaries || [],
  };
  parentCampaign.auditDetails.lastModifiedTime = Date.now();
  parentCampaign.auditDetails.lastModifiedBy =
    requestBody?.RequestInfo?.userInfo?.uuid;
  const produceMessage: any = {
    CampaignDetails: parentCampaign,
  };
  await produceModifiedMessages(
    produceMessage,
    config?.kafka?.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC
  );
}

// function getCreateResourceIds(resources: any[]) {
//   return resources
//     .filter(
//       (resource: any) =>
//         typeof resource.createResourceId === "string" &&
//         resource.createResourceId.trim() !== ""
//     )
//     .map((resource: any) => {
//       const resourceId = resource.createResourceId;
//       return resourceId;
//     });
// }

// async function persistForCampaignProjectMapping(
//   requestBody: any,
//   createResourceDetailsIds: any
// ) {
//   if (createResourceDetailsIds && requestBody?.CampaignDetails?.projectId) {
//     var requestBodyForMapping: any = {
//       RequestInfo: requestBody?.RequestInfo,
//       Campaign: {},
//     };
//     if (requestBody?.ExistingCampaignDetails) {
//       delete requestBody.ExistingCampaignDetails;
//     }
//     requestBodyForMapping.Campaign.id = requestBody?.CampaignDetails?.id;
//     requestBodyForMapping.Campaign.hierarchyType =
//       requestBody?.CampaignDetails?.hierarchyType;
//     requestBodyForMapping.Campaign.tenantId = requestBody?.CampaignDetails?.tenantId;
//     requestBodyForMapping.Campaign.campaignName =
//       requestBody?.CampaignDetails?.campaignName;
//     requestBodyForMapping.Campaign.boundaryCode =
//       requestBody?.CampaignDetails?.boundaryCode;
//     requestBodyForMapping.Campaign.startDate = requestBody?.CampaignDetails?.startDate;
//     requestBodyForMapping.Campaign.endDate = requestBody?.CampaignDetails?.endDate;
//     requestBodyForMapping.Campaign.projectType =
//       requestBody?.CampaignDetails?.projectType;
//     requestBodyForMapping.Campaign.additionalDetails =
//       requestBody?.CampaignDetails?.additionalDetails;
//     requestBodyForMapping.Campaign.deliveryRules =
//       requestBody?.CampaignDetails?.deliveryRules;
//     requestBodyForMapping.Campaign.rootProjectId =
//       requestBody?.CampaignDetails?.projectId;
//     requestBodyForMapping.Campaign.resourceDetailsIds = createResourceDetailsIds;
//     requestBodyForMapping.CampaignDetails = requestBody?.CampaignDetails;
//     requestBodyForMapping.parentCampaign = requestBody?.parentCampaign;
//     var updatedInnerCampaignDetails = {};
//     enrichInnerCampaignDetails(requestBody, updatedInnerCampaignDetails);
//     requestBodyForMapping.CampaignDetails = requestBody?.CampaignDetails;
//     requestBodyForMapping.CampaignDetails.campaignDetails = updatedInnerCampaignDetails;
//     // requestBody.localizationMap = localizationMap
//     logger.info("Persisting CampaignProjectMapping...");
//     logger.debug(
//       `CampaignProjectMapping: ${getFormattedStringForDebug(requestBodyForMapping)}`
//     );
//     await produceModifiedMessages(
//       requestBodyForMapping,
//       config?.kafka?.KAFKA_START_CAMPAIGN_MAPPING_TOPIC
//     );
//   }
// }

function removeBoundariesFromRequest(request: any) {
  const boundaries = request?.body?.CampaignDetails?.boundaries;
  if (boundaries && Array.isArray(boundaries) && boundaries?.length > 0) {
    request.body.CampaignDetails.boundaries = boundaries?.filter(
      (boundary: any) => !boundary?.insertedAfter
    );
  }
}

async function enrichAndPersistProjectCampaignForFirst(
  request: any,
  actionInUrl: any,
  firstPersist: boolean = false
) {
  removeBoundariesFromRequest(request);
  if (actionInUrl == "create") {
    await enrichAndPersistCampaignForCreate(request?.body, firstPersist);
  } else if (actionInUrl == "update") {
    await enrichAndPersistCampaignForUpdate(request);
  }
  if (request?.body?.parentCampaign?.isActive) {
    await makeParentInactiveOrActive(request?.body, false);
  }
  if (request?.body?.CampaignDetails?.action == "create") {
    await createProcessTracks(request.body.CampaignDetails.id);
    await persistProcessStatuses(request.body);
  }
}

async function enrichAndPersistProjectCampaignRequest(
  request: any,
  actionInUrl: any,
  firstPersist: boolean = false
) {
  // var createResourceDetailsIds: any[] = [];
  // if (
  //   request?.body?.CampaignDetails?.resources &&
  //   Array.isArray(request?.body?.CampaignDetails?.resources) &&
  //   request?.body?.CampaignDetails?.resources?.length > 0 &&
  //   request?.body?.CampaignDetails?.action == "create"
  // ) {
  //   createResourceDetailsIds = getCreateResourceIds(
  //     request?.body?.CampaignDetails?.resources
  //   );
  // }
  // removeBoundariesFromRequest(request);
  if (actionInUrl == "create") {
    await enrichAndPersistCampaignForCreate(request?.body, firstPersist);
  } else if (actionInUrl == "update") {
    await enrichAndPersistCampaignForUpdate(request);
  }
  // if (request?.body?.CampaignDetails?.action == "create") {
  //   await persistForCampaignProjectMapping(
  //     request?.body,
  //     createResourceDetailsIds
  //   );
  // }
}

function getChildParentMap(modifiedBoundaryData: any) {
  const childParentMap: Map<
    { key: string; value: string },
    { key: string; value: string } | null
  > = new Map();

  modifiedBoundaryData.forEach((row: any) => {
    for (let j = row.length - 1; j >= 0; j--) {
      const child = row[j];
      const parent = j - 1 >= 0 ? row[j - 1] : null;
      const childIdentifier = { key: child.key, value: child.value }; // Unique identifier for the child
      const parentIdentifier = parent
        ? { key: parent.key, value: parent.value }
        : null; // Unique identifier for the parent, set to null if parent doesn't exist

      // Check if the mapping already exists in the childParentMap
      const existingMapping = Array.from(childParentMap.entries()).find(
        ([existingChild, existingParent]) =>
          _.isEqual(existingChild, childIdentifier) &&
          _.isEqual(existingParent, parentIdentifier)
      );

      // If the mapping doesn't exist, add it to the childParentMap
      if (!existingMapping) {
        childParentMap.set(childIdentifier, parentIdentifier);
      }
    }
  });
  return childParentMap;
}

function getCodeMappingsOfExistingBoundaryCodes(withBoundaryCode: any[]) {
  const countMap = new Map<{ key: string; value: string }, number>();
  const mappingMap = new Map<{ key: string; value: string }, string>();

  withBoundaryCode.forEach((row: any[]) => {
    const len = row.length;
    if (len >= 3) {
      let grandParentFound = false;
      const grandParent = row[len - 3];
      if (findMapValue(mappingMap, grandParent)) {
        const countMapArray = Array.from(countMap.entries());
        for (const [key, value] of countMapArray) {
          if (_.isEqual(key, grandParent)) {
            countMap.set(key, value + 1);
            grandParentFound = true;
            break;
          }
        }
        if (grandParentFound == false) {
          countMap.set(grandParent, 1);
        }
      }
    }
    mappingMap.set(row[len - 2], row[len - 1].value);
  });
  return { mappingMap, countMap };
}

function addBoundaryCodeToData(
  withBoundaryCode: any[],
  withoutBoundaryCode: any[],
  boundaryMap: Map<any, any>
) {
  const boundaryDataWithBoundaryCode = withBoundaryCode;
  const modifiedBoundaryDataWithBoundaryCode = boundaryDataWithBoundaryCode.map(
    (array) => {
      return array.map((obj: any) => {
        if (obj.key === "Boundary Code") {
          return obj.value;
        } else {
          return obj;
        }
      });
    }
  );

  const boundaryDataForWithoutBoundaryCode = withoutBoundaryCode.map(
    (row: any[]) => {
      const boundaryName = row[row.length - 1]; // Get the last element of the row
      const boundaryCode = findMapValue(boundaryMap, boundaryName); // Fetch corresponding boundary code from map
      return [...row, boundaryCode]; // Append boundary code to the row and return updated row
    }
  );
  const boundaryDataForSheet = [
    ...modifiedBoundaryDataWithBoundaryCode,
    ...boundaryDataForWithoutBoundaryCode,
  ];
  return boundaryDataForSheet;
}

function prepareDataForExcel(
  boundaryDataForSheet: any,
  hierarchy: any[],
  boundaryMap: any
) {
  const data = boundaryDataForSheet.map((boundary: any[]) => {
    const boundaryCode = boundary.pop();
    const boundaryValues = boundary.map((obj) => obj.value);
    const rowData = boundaryValues.concat(
      Array(Math.max(0, hierarchy.length - boundary.length)).fill("")
    );
    const boundaryCodeIndex = hierarchy.length;
    rowData[boundaryCodeIndex] = boundaryCode;
    return rowData;
  });
  return data;
}
function extractCodesFromBoundaryRelationshipResponse(boundaries: any[]): any {
  const codes = new Set();
  for (const boundary of boundaries) {
    codes.add(boundary.code); // Add code to the Set
    if (boundary.children && boundary.children.length > 0) {
      const childCodes = extractCodesFromBoundaryRelationshipResponse(
        boundary.children
      ); // Recursively get child codes
      childCodes.forEach((code: any) => codes.add(code)); // Add child codes to the Set
    }
  }
  return codes;
}

async function getTotalCount(campaignDetails: any) {
  const { tenantId, pagination, ids, ...searchFields } = campaignDetails;
  let conditions = [];
  let values = [tenantId];
  let index = 2;
  const campaignsIncludeDates = searchFields?.campaignsIncludeDates;

  for (const field in searchFields) {
    if (searchFields[field] !== undefined && field != "campaignsIncludeDates") {
      if (field === "startDate") {
        const startDateSign = campaignsIncludeDates ? "<=" : ">=";
        conditions.push(`startDate ${startDateSign} $${index}`);
        values.push(searchFields[field]);
        index++;
      } else if (field === "endDate") {
        const endDateSign = campaignsIncludeDates ? ">=" : "<=";
        conditions.push(`endDate ${endDateSign} $${index}`);
        values.push(searchFields[field]);
        index++;
      } else if (field === "campaignName") {
        conditions.push(`${field} ILIKE '%' || $${index} || '%'`);
        values.push(searchFields[field]);
        index++;
      } else if (field != "status") {
        conditions.push(`${field} = $${index}`);
        values.push(searchFields[field]);
        index++;
      }
    }
  }

  let query = `
        SELECT count(*)
        FROM ${config?.DB_CONFIG.DB_CAMPAIGN_DETAILS_TABLE_NAME}
        WHERE tenantId = $1
    `;

  if (ids && ids.length > 0) {
    const idParams = ids.map((id: any, i: any) => `$${index + i}`);
    query += ` AND id IN (${idParams.join(", ")})`;
    values.push(...ids);
    index = index + ids.length;
  } else {
    // If no IDs are provided, filter by isActive = true
    query += ` AND isActive = true`;
  }
  var status = searchFields?.status;
  if (status) {
    if (typeof status === "string") {
      status = [status]; // Convert string to array
    }
    const statusParams = status.map((param: any, i: any) => `$${index + i}`); // Increment index for each parameter
    query += ` AND status IN (${statusParams.join(", ")})`;
    values.push(...status);
  }

  if (conditions.length > 0) {
    query += ` AND ${conditions.join(" AND ")}`;
  }
  const queryResult = await executeQuery(query, values);
  const totalCount = parseInt(queryResult.rows[0].count, 10);
  return totalCount;
}

async function searchProjectCampaignResourcData(campaignDetails: any) {
  // const CampaignDetails = request.body.CampaignDetails;
  const { tenantId, pagination, ids, ...searchFields } = campaignDetails;
  const queryData = buildSearchQuery(tenantId, pagination, ids, searchFields);
  const totalCount = await getTotalCount(campaignDetails);
  const responseData: any[] = await executeSearchQuery(
    queryData.query,
    queryData.values
  );
  // TODO @ashish check the below code looks like duplicate
  for (const data of responseData) {
    data.resources = data?.campaignDetails?.resources;
    data.boundaries = data?.campaignDetails?.boundaries;
    data.deliveryRules = data?.campaignDetails?.deliveryRules;
    delete data.campaignDetails;
    data.auditDetails = {
      createdBy: data?.createdBy,
      lastModifiedBy: data?.lastModifiedBy,
      createdTime: data?.createdTime,
      lastModifiedTime: data?.lastModifiedTime,
    };
    delete data.createdBy;
    delete data.lastModifiedBy;
    delete data.createdTime;
    delete data.lastModifiedTime;
  }
  return { responseData, totalCount };
}

function buildSearchQuery(
  tenantId: string,
  pagination: any,
  ids: string[],
  searchFields: any
): { query: string; values: any[] } {
  let conditions = [];
  let values = [tenantId];
  let index = 2;
  const campaignsIncludeDates = searchFields?.campaignsIncludeDates;

  for (const field in searchFields) {
    if (searchFields[field] !== undefined && field != "campaignsIncludeDates") {
      if (field === "startDate") {
        const startDateSign = campaignsIncludeDates ? "<=" : ">=";
        conditions.push(`startDate ${startDateSign} $${index}`);
        values.push(searchFields[field]);
        index++;
      } else if (field === "endDate") {
        const endDateSign = campaignsIncludeDates ? ">=" : "<=";
        conditions.push(`endDate ${endDateSign} $${index}`);
        values.push(searchFields[field]);
        index++;
      } else if (field === "campaignName") {
        conditions.push(`${field} ILIKE '%' || $${index} || '%'`);
        values.push(searchFields[field]);
        index++;
      } else if (field != "status") {
        conditions.push(`${field} = $${index}`);
        values.push(searchFields[field]);
        index++;
      }
    }
  }

  let query = `
        SELECT *
        FROM ${config?.DB_CONFIG.DB_CAMPAIGN_DETAILS_TABLE_NAME}
        WHERE tenantId = $1
    `;

  if (ids && ids.length > 0) {
    const idParams = ids.map((id: any, i: any) => `$${index + i}`);
    query += ` AND id IN (${idParams.join(", ")})`;
    values.push(...ids);
    index = index + ids.length;
  } else {
    // If no IDs are provided, filter by isActive = true
    query += ` AND isActive = true`;
  }

  var status = searchFields?.status;
  if (status) {
    if (typeof status === "string") {
      status = [status]; // Convert string to array
    }
    const statusParams = status.map((param: any, i: any) => `$${index + i}`); // Increment index for each parameter
    query += ` AND status IN (${statusParams.join(", ")})`;
    values.push(...status);
  }

  if (conditions.length > 0) {
    query += ` AND ${conditions.join(" AND ")}`;
  }

  if (pagination) {
    query += "\n";

    if (pagination.sortBy) {
      query += `ORDER BY ${pagination.sortBy}`;
      if (pagination.sortOrder) {
        query += ` ${pagination.sortOrder.toUpperCase()}`;
      }
      query += "\n";
    }

    if (pagination.limit !== undefined) {
      query += `LIMIT ${pagination.limit}`;
      if (pagination.offset !== undefined) {
        query += ` OFFSET ${pagination.offset}`;
      }
      query += "\n";
    }
  }

  return { query, values };
}

async function executeSearchQuery(query: string, values: any[]) {
  const queryResult = await executeQuery(query, values);
  return campaignDetailsTransformer(queryResult?.rows);
}

async function processDataSearchRequest(request: any) {
  const { SearchCriteria } = request.body;
  const query = buildWhereClauseForDataSearch(SearchCriteria);
  const queryResult = await executeQuery(query.query, query.values);
  request.body.ResourceDetails = genericResourceTransformer(queryResult?.rows);
}

function buildWhereClauseForDataSearch(SearchCriteria: any): {
  query: string;
  values: any[];
} {
  const { id, tenantId, type, status, hierarchyType } = SearchCriteria;
  let conditions = [];
  let values = [];

  // Check for id
  if (id && id.length > 0) {
    conditions.push(`id = ANY($${values.length + 1})`);
    values.push(id);
  }

  // Check for tenantId
  if (tenantId) {
    conditions.push(`tenantId = $${values.length + 1}`);
    values.push(tenantId);
  }

  // Check for type
  if (type) {
    conditions.push(`type = $${values.length + 1}`);
    values.push(type);
  }

  // Check for status
  if (status) {
    conditions.push(`status = $${values.length + 1}`);
    values.push(status);
  }

  // Check for hierarchyType
  if (hierarchyType) {
    conditions.push(`hierarchyType = $${values.length + 1}`);
    values.push(hierarchyType);
  }

  // Build the WHERE clause
  const whereClause =
    conditions.length > 0 ? `WHERE ${conditions.join(" AND ")}` : "";

  // Return the query and values array
  return {
    query: `
            SELECT *
            FROM ${config?.DB_CONFIG.DB_RESOURCE_DETAILS_TABLE_NAME}
            ${whereClause};`,
    values,
  };
}

export function mapTargets(boundaryResponses: any, codesTargetMapping: any) {
  if (!boundaryResponses || !codesTargetMapping) return;

  // Helper function to map individual boundaries
  const mapBoundary = (boundary: any) => {
    if (!boundary.children || boundary.children.length === 0) {
      // If no children, simply return the target value object or default to empty object
      const targetValue = codesTargetMapping[boundary.code];
      return targetValue || {};
    }

    // Initialize a new object to accumulate total target values from children
    let totalTargetValue: any = {};

    // Iterate through each child and accumulate their target values
    for (const child of boundary.children) {
      const childTargetValue = mapBoundary(child);

      // Accumulate the child target values into the total target value
      for (const key in childTargetValue) {
        if (childTargetValue.hasOwnProperty(key)) {
          // Initialize key in totalTargetValue if it doesn't exist
          totalTargetValue[key] = (totalTargetValue[key] || 0) + childTargetValue[key];
        }
      }
    }

    // Store the accumulated total target value for the current boundary
    codesTargetMapping[boundary.code] = totalTargetValue;
    return totalTargetValue;
  };

  // Map each boundary response
  for (const boundaryResponse of boundaryResponses) {
    mapBoundary(boundaryResponse);
  }
}

async function processBoundary(
  boundaryResponse: any,
  boundaries: any,
  includeAllChildren: any,
  boundaryCodes: any,
  boundaryChildren: any
) {
  if (!boundaryResponse) return;
  if (!boundaryCodes.has(boundaryResponse.code)) {
    boundaries.push({
      code: boundaryResponse?.code,
      type: boundaryResponse?.boundaryType,
      insertedAfter: true,
    });
    boundaryCodes.add(boundaryResponse?.code);
  }
  if (
    includeAllChildren &&
    boundaryResponse?.children &&
    Array.isArray(boundaryResponse?.children) &&
    boundaryResponse?.children?.length > 0
  ) {
    for (const child of boundaryResponse.children) {
      processBoundary(child, boundaries, true, boundaryCodes, boundaryChildren);
    }
  } else if (
    boundaryResponse?.children &&
    Array.isArray(boundaryResponse?.children) &&
    boundaryResponse?.children?.length > 0
  ) {
    for (const child of boundaryResponse.children) {
      if (boundaryCodes.has(child.code) && boundaryChildren[child.code]) {
        processBoundary(
          child,
          boundaries,
          true,
          boundaryCodes,
          boundaryChildren
        );
      } else if (boundaryCodes.has(child.code)) {
        processBoundary(
          child,
          boundaries,
          false,
          boundaryCodes,
          boundaryChildren
        );
      }
    }
  }
}

async function addBoundariesForData(request: any, CampaignDetails: any) {
  // var { boundaries } = CampaignDetails;
  var boundaries = await getBoundariesFromCampaignSearchResponse(
    request,
    CampaignDetails
  );
  const rootBoundary = getRootBoundaryCode(boundaries);
  if (rootBoundary) {
    const params = {
      tenantId: request?.body?.ResourceDetails?.tenantId,
      codes: rootBoundary,
      hierarchyType: request?.body?.ResourceDetails?.hierarchyType,
      includeChildren: true,
    };
    const requestBody = {
      RequestInfo : request?.body?.RequestInfo,
    }
    const header = {
      ...defaultheader,
      cachekey: `boundaryRelationShipSearch${params?.hierarchyType}${params?.tenantId
        }${params.codes || ""}${params?.includeChildren || ""}`,
    };
    const boundaryResponse = await httpRequest(
      config.host.boundaryHost + config.paths.boundaryRelationship,
      requestBody,
      params,
      undefined,
      undefined,
      header
    );
    if (boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0]) {
      var boundaryChildren = boundaries.reduce((acc: any, boundary: any) => {
        acc[boundary.code] = boundary?.includeAllChildren;
        return acc;
      }, {});
      var boundaryCodes = new Set(
        boundaries.map((boundary: any) => boundary.code)
      );
      await processBoundary(
        boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0],
        boundaries,
        boundaryChildren[
        boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0]?.code
        ],
        boundaryCodes,
        boundaryChildren
      );
      CampaignDetails.boundaries = boundaries;
    } else {
      throwError(
        "COMMON",
        500,
        "INTERNAL_SERVER_ERROR",
        "Some internal server error occured during boundary validation."
      );
    }
  } else {
    throwError(
      "COMMON",
      500,
      "INTERNAL_SERVER_ERROR",
      "There is no root boundary for this campaign."
    );
  }
}

async function reorderBoundariesOfDataAndValidate(
  request: any,
  localizationMap?: any
) {
  if (request?.body?.ResourceDetails?.campaignId) {
    // const searchBody = {
    //   RequestInfo: request?.body?.RequestInfo,
    const CampaignDetails = {
      ids: [request?.body?.ResourceDetails?.campaignId],
      tenantId: request?.body?.ResourceDetails?.tenantId,
    }
    // };
    // const req: any = replicateRequest(request, searchBody);
    const response = await searchProjectTypeCampaignService(CampaignDetails);
    if (response?.CampaignDetails?.[0]) {
      const CampaignDetails = response?.CampaignDetails?.[0];
      await addBoundariesForData(request, CampaignDetails);
      // logger.debug(
      //   "Boundaries after addition " +
      //   getFormattedStringForDebug(CampaignDetails?.boundaries)
      // );
      await validateBoundaryOfResouces(
        CampaignDetails,
        request,
        localizationMap
      );
    } else {
      throwError(
        "CAMPAIGN",
        400,
        "CAMPAIGN_NOT_FOUND",
        "Campaign not found while Validating sheet boundaries"
      );
    }
  }
}

function convertToProjectsArray(Projects: any, currentArray: any = []) {
  for (const project of Projects) {
    const descendants = project?.descendants;
    delete project?.descendants;
    currentArray.push(project);
    if (descendants && Array.isArray(descendants) && descendants?.length > 0) {
      convertToProjectsArray(descendants, currentArray);
    }
  }
  return currentArray;
}

async function getRelatedProjects(request: any) {
  const { projectId, tenantId } = request?.body?.CampaignDetails;
  const projectSearchBody = {
    RequestInfo: request?.body?.RequestInfo,
    Projects: [
      {
        id: projectId,
        tenantId: tenantId,
      },
    ],
  };
  const projectSearchParams = {
    tenantId: tenantId,
    offset: 0,
    limit: 1,
    includeDescendants: true,
  };
  logger.info("Project search params " + JSON.stringify(projectSearchParams));
  const projectSearchResponse = await httpRequest(
    config?.host?.projectHost + config?.paths?.projectSearch,
    projectSearchBody,
    projectSearchParams
  );
  if (
    projectSearchResponse?.Project &&
    Array.isArray(projectSearchResponse?.Project) &&
    projectSearchResponse?.Project?.length > 0
  ) {
    return convertToProjectsArray(projectSearchResponse?.Project);
  } else {
    throwError("PROJECT", 500, "PROJECT_SEARCH_ERROR");
    return [];
  }
}

async function updateProjectDates(request: any, actionInUrl: any) {
  const { startDate, endDate, projectId } = request?.body?.CampaignDetails;
  if ((startDate || endDate) && projectId && actionInUrl == "update") {
    const projects = await getRelatedProjects(request);
    for (const project of projects) {
      project.startDate = startDate || project.startDate;
      project.endDate = endDate || project.endDate;
      delete project?.address;
    }
    logger.info(
      "Projects related to current Campaign : " + JSON.stringify(projects)
    );
    const projectUpdateBody = {
      RequestInfo: request?.body?.RequestInfo,
      Projects: projects,
    };
    const projectUpdateResponse = await httpRequest(
      config?.host?.projectHost + config?.paths?.projectUpdate,
      projectUpdateBody
    );
    if (
      projectUpdateResponse?.Project &&
      Array.isArray(projectUpdateResponse?.Project) &&
      projectUpdateResponse?.Project?.length == projects?.length
    ) {
      logger.info("Project dates updated successfully");
    } else {
      throwError("PROJECT", 500, "PROJECT_UPDATE_ERROR");
    }
  }
}

export async function getCodesTarget(CampaignDetails: any, localizationMap?: any) {
  const { resources, tenantId } = CampaignDetails;
  const boundaryWithTargetResource = resources?.filter(
    (resource: any) => resource?.type == "boundaryWithTarget"
  );
  if (boundaryWithTargetResource && boundaryWithTargetResource.length > 0) {
    const fileId = boundaryWithTargetResource[0]?.filestoreId;
    const fileResponse = await httpRequest(
      config.host.filestore + config.paths.filestore + "/url",
      {},
      { tenantId: tenantId, fileStoreIds: fileId },
      "get"
    );
    if (!fileResponse?.fileStoreIds?.[0]?.url) {
      throwError("FILE", 500, "DOWNLOAD_URL_NOT_FOUND");
    }
    const codeColumnName = getLocalizedName(
      createAndSearch?.boundaryWithTarget?.boundaryValidation?.column,
      localizationMap
    );
    const targetData = await getTargetSheetDataAfterCode(
      CampaignDetails,
      fileResponse?.fileStoreIds?.[0]?.url,
      codeColumnName,
      localizationMap
    );
    const boundaryTargetMapping: any = {};
    // Iterate through each key in targetData
    for (const key in targetData) {
      // Iterate through each entry in the array under the current key
      targetData[key].forEach((entry: any) => {
        // Check if the entry has both "Boundary Code" and "currentBoundaryTarget"
        if (
          entry[codeColumnName] !== undefined &&
          entry["currentBoundaryTarget"] !== undefined
        ) {
          // Add the mapping to the boundaryTargetMapping object
          boundaryTargetMapping[entry[codeColumnName]] =
            entry["currentBoundaryTarget"];
        }
      });
    }
    logger.info(
      "Boundary target mapping count" +
      Object.keys(boundaryTargetMapping)?.length
    );
    return boundaryTargetMapping;
  } else return null;
}

async function createProject(
  requestBody: any
) {
  await persistTrack(
    requestBody?.CampaignDetails?.id,
    processTrackTypes.targetAndDeliveryRulesCreation,
    processTrackStatuses.inprogress
  );
  try {
    const isProcessAlreadyCompleted = await checkIfProcessIsCompleted(
      requestBody?.CampaignDetails?.campaignNumber,
      processNamesConstantsInOrder.projectCreation
    )
    if (isProcessAlreadyCompleted) {
      logger.info("Project Creation process already completed");
      return;
    }
    const isNoNeedToProceed = await checkIfNoNeedToProceedForResource(
      "boundaryWithTarget",
      processNamesConstantsInOrder.projectCreation,
      requestBody?.CampaignDetails,
      requestBody?.RequestInfo
    )
    if(isNoNeedToProceed){
      logger.info("Project Creation process no need to proceed");
      return;
    }
    // TODO : Remove confirmation from here
    // Function to delay execution for a specified time
    let projectStatusConfirmed = false;
    let status = "";
    const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));
    const processConfirmationAttempts = parseInt(config?.values?.processConfirmationAttempts || "75") || 75;

    // Check process completion with retries
    for (let attempt = 0; attempt < processConfirmationAttempts; attempt++) {
      const isCompleted = await checkIfProcessIsCompleted(
        requestBody?.CampaignDetails?.campaignNumber,
        processNamesConstantsInOrder.projectCreation
      );
      const isFailed = await checkifProcessIsFailed(
        requestBody?.CampaignDetails?.campaignNumber,
        processNamesConstantsInOrder.projectCreation
      )

      if (isCompleted || isFailed) {
        logger.info(`Project Creation confirmed successfully. Attempt ${attempt + 1} out of ${processConfirmationAttempts}`);
        projectStatusConfirmed = true;
        status = isCompleted ? campaignProcessStatus.completed : campaignProcessStatus.failed;
        break;  // Exit successfully if process is completed
      }
      else {
        logger.warn(`Project Creation process not completed yet. Attempt ${attempt + 1} out of ${processConfirmationAttempts}.`);
      }
      await delay(20000);  // Wait for 2 seconds before retrying
    }
    if (!projectStatusConfirmed) {
      logger.error(`Project Creation process did not complete after ${processConfirmationAttempts} attempts.`);
      throw new Error(`Project Creation process did not complete after ${processConfirmationAttempts} attempts.`);
    }
    else {
      if (status == campaignProcessStatus.failed) {
        logger.error(`Project Creation process failed.`);
        throw new Error(`Project Creation process failed.`);
      }
      else{
        const campaignDetailsAndRequestInfo = {
          RequestInfo: requestBody?.RequestInfo,
          CampaignDetails: requestBody?.CampaignDetails,
        }
        await enrichProcessedFileAndPersist(campaignDetailsAndRequestInfo, "boundaryWithTarget");
      }
    }
  } catch (error: any) {
    console.log(error);
    await persistTrack(
      requestBody?.CampaignDetails?.id,
      processTrackTypes.targetAndDeliveryRulesCreation,
      processTrackStatuses.failed,
      {
        error: String(
          error?.message +
          (error?.description ? ` : ${error?.description}` : "") || error
        ),
      }
    );
    throw new Error(error);
  }
  await persistTrack(
    requestBody?.CampaignDetails?.id,
    processTrackTypes.targetAndDeliveryRulesCreation,
    processTrackStatuses.completed
  );
}

export async function checkIfNoNeedToProceedForResource(resourceType : string, processName : string, CampaignDetails: any, RequestInfo: any) {
  const resourceFileId = CampaignDetails?.resources?.find((resource: any) => resource?.type == resourceType)?.filestoreId;
  if (!resourceFileId) {
    await markProcessStatus(CampaignDetails?.campaignNumber, processName, campaignProcessStatus.completed);
    return true;
  }
  const campaignDetailsAndRequestInfo = {
    RequestInfo: RequestInfo,
    CampaignDetails: CampaignDetails,
  }
  const produceMessage: any = {
    processName: processName,
    campaignDetailsAndRequestInfo: campaignDetailsAndRequestInfo
  }
  await produceModifiedMessages(produceMessage, config.kafka.KAFKA_PROCESS_HANDLER_TOPIC);
  return false;
}

async function processAfterPersist(request: any, actionInUrl: any) {
  try {
    // wait for 5 seconds before persisting the process track
    await new Promise((resolve) => setTimeout(resolve, 5000)); 
    if (request?.body?.CampaignDetails?.action == "create") {
      await persistTrack(
        request.body.CampaignDetails.id,
        processTrackTypes.validation,
        processTrackStatuses.completed
      );
      await createProject(request?.body);
      await createCampaignEmployees(request?.body);
      await createCampaignFacilities(request?.body);
      await createCampaignMappings(request?.body);
      request.body.CampaignDetails.status = campaignStatuses.inprogress;
      await processResources(request?.body);
      // await createProjectCampaignResourcData(request);
      await enrichAndPersistProjectCampaignRequest(
        request,
        actionInUrl,
        false
      );
    } else {
      await updateProjectDates(request, actionInUrl);
      await enrichAndPersistProjectCampaignRequest(
        request,
        actionInUrl,
        false
      );
    }
  } catch (error: any) {
    console.log(error);
    logger.error(error);
    await enrichAndPersistCampaignWithError(request?.body, error);
  }
}

async function processBasedOnAction(request: any, actionInUrl: any) {
  if (actionInUrl == "create") {
    request.body.CampaignDetails.id = uuidv4();
  }
  await enrichAndPersistProjectCampaignForFirst(request, actionInUrl, true);
  if (
    actionInUrl == "create" &&
    request.body?.parentCampaign &&
    request?.body?.CampaignDetails?.action === "draft"
  ) {
    callGenerateWhenChildCampaigngetsCreated(request);
  }
  processAfterPersist(request, actionInUrl);
}

async function getLocalizedHierarchy(request: any, localizationMap: any) {
  var hierarchy = await getHierarchy(
    request,
    request?.query?.tenantId,
    request?.query?.hierarchyType
  );
  var modifiedHierarchy = hierarchy.map((ele) =>
    `${request?.query?.hierarchyType}_${ele}`.toUpperCase()
  );
  var resultHierarchy = getLocalizedHeaders(modifiedHierarchy, localizationMap);
  return resultHierarchy;
}

async function appendSheetsToWorkbook(
  request: any,
  boundaryData: any[],
  differentTabsBasedOnLevel: any,
  localizationMap?: any,
  fileUrl?: any
) {
  try {
    logger.info(
      "Received Boundary data for generating  different tabs based on configured boundary level"
    );
    const hierarchy: any[] = await getLocalizedHierarchy(
      request,
      localizationMap
    );
    const workbook = getNewExcelWorkbook();
    const type = request?.query?.type;
    const headingInSheet = headingMapping?.[type];
    const localisedHeading = getLocalizedName(headingInSheet, localizationMap);
    await createReadMeSheet(
      request,
      workbook,
      localisedHeading,
      localizationMap
    );
    const [
      mainSheetData,
      uniqueDistrictsForMainSheet,
      districtLevelRowBoundaryCodeMap,
    ] = createBoundaryDataMainSheet(
      request,
      boundaryData,
      differentTabsBasedOnLevel,
      hierarchy,
      localizationMap
    );
    const responseFromCampaignSearch = await getCampaignSearchResponse(request);
    const campaignObject = responseFromCampaignSearch?.CampaignDetails?.[0];
    // const isSourceMicroplan = checkIfSourceIsMicroplan(campaignObject);
    const mainSheet = workbook.addWorksheet(
      getLocalizedName(getBoundaryTabName(), localizationMap)
    );
    const columnWidths = Array(12).fill(30);
    mainSheet.columns = columnWidths.map((width) => ({ width }));
    // mainSheetData.forEach(row => mainSheet.addRow(row));
    addDataToSheet(
      type,
      mainSheet,
      mainSheetData,
      "F3842D",
      30,
      false,
      true
    );
    mainSheet.state = "hidden";
    logger.info("appending different districts tab in the sheet started");
    await appendDistricts(
      request,
      workbook,
      uniqueDistrictsForMainSheet,
      differentTabsBasedOnLevel,
      boundaryData,
      localizationMap,
      districtLevelRowBoundaryCodeMap,
      hierarchy,
      campaignObject,
      fileUrl
    );
    logger.info("Sheet with different tabs generated successfully");
    return workbook;
  } catch (error) {
    console.log(error);
    throw Error("An error occurred while creating tabs based on district:");
  }
}

async function appendDistricts(
  request: any,
  workbook: any,
  uniqueDistrictsForMainSheet: any,
  differentTabsBasedOnLevel: any,
  boundaryData: any,
  localizationMap: any,
  districtLevelRowBoundaryCodeMap: any,
  hierarchy: any,
  campaignObject: any,
  fileUrl?: any
) {
  const configurableColumnHeadersFromSchemaForTargetSheet =
    await getConfigurableColumnHeadersFromSchemaForTargetSheet(
      request,
      hierarchy,
      boundaryData,
      differentTabsBasedOnLevel,
      campaignObject,
      localizationMap
    );
  let sheetNamesOfProcessedFile: any;
  if (fileUrl) {
    const processedWorkbook = await getTargetWorkbook(fileUrl, localizationMap);
    sheetNamesOfProcessedFile = processedWorkbook.worksheets.map(
      (sheet: any) => sheet.name
    );
  }
  for (const uniqueData of uniqueDistrictsForMainSheet) {
    const uniqueDataFromLevelForDifferentTabs = uniqueData.slice(
      uniqueData.lastIndexOf("#") + 1
    );
    logger.info(
      `generating the boundary data for ${uniqueDataFromLevelForDifferentTabs} - ${differentTabsBasedOnLevel}`
    );
    const districtDataFiltered = boundaryData.filter(
      (boundary: any) =>
        boundary[differentTabsBasedOnLevel] ===
        uniqueDataFromLevelForDifferentTabs &&
        boundary[hierarchy[hierarchy.length - 1]]
    );
    const modifiedFilteredData = modifyFilteredData(
      districtDataFiltered,
      districtLevelRowBoundaryCodeMap.get(uniqueData),
      differentTabsBasedOnLevel,
      localizationMap
    );
    if (modifiedFilteredData?.[0]) {
      const newSheetData = [configurableColumnHeadersFromSchemaForTargetSheet];
      for (const data of modifiedFilteredData) {
        var rowData: any[] = [];
        for (const header of configurableColumnHeadersFromSchemaForTargetSheet) {
          rowData.push(data[header] || "");
        }
        newSheetData.push(rowData);
      }

      await createNewSheet(
        request,
        workbook,
        newSheetData,
        uniqueData,
        localizationMap,
        districtLevelRowBoundaryCodeMap,
        configurableColumnHeadersFromSchemaForTargetSheet,
        campaignObject,
        sheetNamesOfProcessedFile,
        fileUrl
      );
      logger.info(
        `${uniqueDataFromLevelForDifferentTabs} - ${differentTabsBasedOnLevel} boundary data generation completed`
      );
    }
  }
}

async function createNewSheet(
  request: any,
  workbook: any,
  newSheetData: any,
  uniqueData: any,
  localizationMap: any,
  districtLevelRowBoundaryCodeMap: any,
  localizedHeaders: any,
  campaignObject: any,
  sheetNamesOfProcessedFile: any,
  fileUrl?: any
) {
  const newSheet = workbook.addWorksheet(
    getLocalizedName(
      districtLevelRowBoundaryCodeMap.get(uniqueData),
      localizationMap
    )
  );
  let modifiedNewSheetData: any = newSheetData;
  const oldTargetColumnsToHide: any[] = [];
  if (fileUrl) {
    let processedDistrictSheetData: any;
    if (
      sheetNamesOfProcessedFile.includes(
        getLocalizedName(
          districtLevelRowBoundaryCodeMap.get(uniqueData),
          localizationMap
        )
      )
    ) {
      processedDistrictSheetData = await getSheetData(
        fileUrl,
        getLocalizedName(
          districtLevelRowBoundaryCodeMap.get(uniqueData),
          localizationMap
        ),
        false,
        undefined,
        localizationMap
      );
    }
    modifiedNewSheetData = modifyNewSheetData(
      processedDistrictSheetData,
      newSheetData,
      localizedHeaders,
      oldTargetColumnsToHide,
      localizationMap
    );
  }
  const type = request?.query?.type || request?.body?.ResourceDetails?.type;
  addDataToSheet(type, newSheet, modifiedNewSheetData, "F3842D", 40);
  if (oldTargetColumnsToHide && oldTargetColumnsToHide.length > 0) {
    const columnIndexesToBeHidden: any[] = [];
    oldTargetColumnsToHide.forEach((column: any) => {
      const localizedColumn = getLocalizedName(column, localizationMap);
      const columnIndex = getColumnIndexByHeader(newSheet, localizedColumn);
      if(columnIndex != -1) columnIndexesToBeHidden.push(columnIndex);
    });
    hideColumnsOfProcessedFile(newSheet, columnIndexesToBeHidden);
  }
  let columnsNotToBeFreezed: any;
  const boundaryCodeColumnIndex = localizedHeaders.findIndex(
    (header: any) =>
      header ===
      getLocalizedName(config?.boundary?.boundaryCode, localizationMap)
  );
  if (
    isDynamicTargetTemplateForProjectType(campaignObject?.projectType) &&
    campaignObject.deliveryRules &&
    campaignObject.deliveryRules.length > 0
  ) {
    columnsNotToBeFreezed = localizedHeaders.slice(boundaryCodeColumnIndex + 1);
  } else {
    const mdmsResponse = await getMdmsDataBasedOnCampaignType(
      request,
      localizationMap
    );
    columnsNotToBeFreezed = mdmsResponse?.columnsNotToBeFreezed;
  }
  const localizedColumnsNotToBeFreezed = getLocalizedHeaders(
    columnsNotToBeFreezed,
    localizationMap
  );
  lockTargetFields(
    newSheet,
    localizedColumnsNotToBeFreezed,
    boundaryCodeColumnIndex
  );
}

function modifyFilteredData(
  districtDataFiltered: any,
  targetBoundaryCode: any,
  differentTabsBasedOnLevel: any,
  localizationMap?: any
): any {
  // Retrieve the localized version of the target boundary code if a localization map is provided
  const desiredBoundaryCode = getLocalizedName(
    targetBoundaryCode,
    localizationMap
  );
  // Filter the district data to include only rows where the boundary code matches the desired one
  const modifiedFilteredData = districtDataFiltered.filter((row: any) => {
    return row[differentTabsBasedOnLevel] == desiredBoundaryCode;
  });
  // Return the filtered data
  return modifiedFilteredData;
}

async function generateFilteredBoundaryData(
  request: any,
  FiltersFromCampaignId: any
) {
  const rootBoundary: any = (FiltersFromCampaignId?.Filters?.boundaries).filter(
    (boundary: any) => boundary.isRoot
  );
  const params = {
    ...request?.query,
    includeChildren: true,
    codes: rootBoundary?.[0]?.code,
  };
  const boundaryDataFromRootOnwards = await getBoundaryRelationshipData(
    params
  );
  logger.info(`filtering the boundaries`);
  const filteredBoundaryList = filterBoundaries(
    boundaryDataFromRootOnwards,
    FiltersFromCampaignId?.Filters
  );
  logger.info(`filtered the boundaries based on given criteria`);
  return filteredBoundaryList;
}

function filterBoundaries(boundaryData: any[], filters: any): any {
  function filterRecursive(boundary: any): any {
    const boundaryFilters = filters && filters.boundaries; // Accessing boundaries array from filters object
    const filter = boundaryFilters?.find(
      (f: any) =>
        f.code === boundary.code && f.boundaryType === boundary.boundaryType
    );

    if (!filter) {
      return {
        ...boundary,
        children: boundary.children.map(filterRecursive),
      };
    }

    if (!boundary.children.length) {
      if (!filter.includeAllChildren) {
        // throwError("COMMON", 400, "VALIDATION_ERROR", "Boundary cannot have includeAllChildren filter false if it does not have any children");
        logger.error(
          "Boundary cannot have includeAllChildren filter false if it does not have any children"
        );
      }
      // If boundary has no children and includeAllChildren is true, return as is
      return {
        ...boundary,
        children: [],
      };
    }

    if (filter.includeAllChildren) {
      // If includeAllChildren is true, return boundary with all children
      return {
        ...boundary,
        children: boundary.children.map(filterRecursive),
      };
    }

    const filteredChildren: any[] = [];
    boundary.children.forEach((child: any) => {
      const matchingFilter = boundaryFilters.find(
        (f: any) =>
          f.code === child.code && f.boundaryType === child.boundaryType
      );
      if (matchingFilter) {
        filteredChildren.push(filterRecursive(child));
      }
    });
    return {
      ...boundary,
      children: filteredChildren,
    };
  }
  const filteredData = boundaryData.map(filterRecursive);
  return filteredData;
}

function generateHierarchy(boundaries: any[]) {
  // Create an object to store boundary types and their parents
  const parentMap: any = {};

  // Populate the object with boundary types and their parents
  for (const boundary of boundaries) {
    parentMap[boundary.boundaryType] = boundary.parentBoundaryType;
  }

  // Traverse the hierarchy to generate the hierarchy list
  const hierarchyList = [];
  for (const boundaryType in parentMap) {
    if (Object.prototype.hasOwnProperty.call(parentMap, boundaryType)) {
      const parentBoundaryType = parentMap[boundaryType];
      if (parentBoundaryType === null) {
        // This boundary type has no parent, add it to the hierarchy list
        hierarchyList.push(boundaryType);
        // Traverse its children recursively
        traverseChildren(boundaryType, parentMap, hierarchyList);
      }
    }
  }
  return hierarchyList;
}

function traverseChildren(parent: any, parentMap: any, hierarchyList: any[]) {
  for (const boundaryType in parentMap) {
    if (Object.prototype.hasOwnProperty.call(parentMap, boundaryType)) {
      const parentBoundaryType = parentMap[boundaryType];
      if (parentBoundaryType === parent) {
        // This boundary type has the current parent, add it to the hierarchy list
        hierarchyList.push(boundaryType);
        // Traverse its children recursively
        traverseChildren(boundaryType, parentMap, hierarchyList);
      }
    }
  }
}

function createBoundaryMap(
  boundaries: any[],
  boundaryMap: Map<string, string>
): void {
  for (const boundary of boundaries) {
    boundaryMap.set(boundary.code, boundary.boundaryType);
    if (boundary.children.length > 0) {
      createBoundaryMap(boundary.children, boundaryMap);
    }
  }
}

async function boundaryGeometryManagement(request: any, localizationMap: any) {
  try {
    logger.info("Boundary Relationship Creation Starts For Geometry Data");
    await autoGenerateBoundaryCodesForGeoJson(request, localizationMap);
  } catch (error: any) {
    console.log(error);
    await handleResouceDetailsError(request, error);
  }
}

async function boundaryBulkUpload(request: any, localizationMap?: any) {
  try {
    logger.info("Boundary Relationship Creation Starts");
    await autoGenerateBoundaryCodes(request, localizationMap);
    await generateProcessedFileAndPersist(request);
  } catch (error: any) {
    console.log(error);
    await handleResouceDetailsError(request, error);
  }
}

function updateBoundaryDataForBoundaryManagement(
  request: any,
  boundaryData: any[],
  localizationMap: any
): { updatedData: any[]; latLongData: [number, number][] } {
  const latLongData: [number, number][] = [];
  const latKey = getLocalizedName("HCM_ADMIN_CONSOLE_LAT", localizationMap);
  const longKey = getLocalizedName("HCM_ADMIN_CONSOLE_LONG", localizationMap);

  boundaryData.forEach((row) => {
    // Check if the row contains both latitude and longitude keys
    if (latKey in row && longKey in row) {
      // Push latitude and longitude to the latLongData array
      latLongData.push([row[latKey], row[longKey]]);

      // Remove the latitude and longitude from the original row
      delete row[latKey];
      delete row[longKey];
    }
  });

  // Return both the updated boundary data and latLongData
  return {
    updatedData: boundaryData,
    latLongData,
  };
}

async function autoGenerateBoundaryCodesForGeoJson(
  request: any,
  localizationMap?: any
) {
  const { hierarchyType, tenantId } = request?.body?.ResourceDetails || {};
  // const type = request?.body?.ResourceDetails?.type;
  const fileResponse = await httpRequest(
    config.host.filestore + config.paths.filestore + "/url",
    {},
    { tenantId, fileStoreIds: request?.body?.ResourceDetails?.fileStoreId },
    "get"
  );
  var boundaryData = await getDataFromGeoJson(
    fileResponse?.fileStoreIds?.[0]?.url
  );
  const hierarchy =
    (await getHierarchy(request, tenantId, hierarchyType)) || [];
  const dataFromGeoJson = getGeoJsonData(boundaryData, hierarchy);
  const childParentMap = getChildParentMap(dataFromGeoJson);
  const countMap = new Map<{ key: string; value: string }, number>();
  const mappingMap = new Map<{ key: string; value: string }, string>();
  const boundaryMap = await getAutoGeneratedBoundaryCodesHandler(
    dataFromGeoJson,
    childParentMap,
    mappingMap,
    countMap,
    request
  );
  logger.info("Boundary Code Auto Generation Completed");
  await createBoundaryEntities(request, boundaryMap);
  logger.info(
    "waiting for 2 secs to persist the boundary entities before creating boundary relationship"
  );
  await new Promise((resolve) => setTimeout(resolve, 2000));
  const modifiedChildParentMap = modifyChildParentMap(
    childParentMap,
    boundaryMap
  );
  await createBoundaryRelationship(
    request,
    boundaryMap,
    modifiedChildParentMap
  );
  const boundaryGeoJsonAfterProcessing = addBoundaryCodeToGeoJsonData(
    boundaryData,
    hierarchy,
    boundaryMap
  );
  logger.info(
    "Initiated the localisation message creation for the uploaded boundary"
  );
  transformAndCreateLocalisation(boundaryMap, request);
  const boundaryFileDetails: any = await createAndUploadJsonFile(
    boundaryGeoJsonAfterProcessing,
    request
  );
  await updateAndPersistResourceDetails(
    request,
    boundaryFileDetails,
    boundaryData?.name
  );
  logger.info("Boundary Relationship Creation Completed");
}

async function updateAndPersistResourceDetails(
  request: any,
  boundaryFileDetails: any,
  name: any
) {
  const fileStoreId = boundaryFileDetails[0]?.fileStoreId;
  const getLatestResourceDetails = await getResourceDetails(request);

  if (getLatestResourceDetails == null) {
    request.body.ResourceDetails = {
      ...request?.body?.ResourceDetails,
      processedFileStoreId: fileStoreId,
      status:
        request.body.ResourceDetails.status != resourceDataStatuses.invalid
          ? resourceDataStatuses.completed
          : resourceDataStatuses.invalid,
      auditDetails: {
        ...request?.body?.ResourceDetails?.auditDetails,
        lastModifiedBy: request?.body?.RequestInfo?.userInfo?.uuid,
        lastModifiedTime: Date.now(),
      },
      additionalDetails:
      {
        ...request?.body?.ResourceDetails?.additionalDetails,
        sheetErrors: request?.body?.additionalDetailsErrors,
        source:
          request?.body?.ResourceDetails?.additionalDetails?.source ==
            "microplan"
            ? "microplan"
            : null,
        [name]: [fileStoreId],
      },
    };
  } else {
    request.body.ResourceDetails = {
      ...getLatestResourceDetails,
      processedFileStoreId: fileStoreId,
      status:
        getLatestResourceDetails.status != resourceDataStatuses.invalid
          ? resourceDataStatuses.completed
          : resourceDataStatuses.invalid,
      auditDetails: {
        ...getLatestResourceDetails.auditDetails,
        lastModifiedBy: request?.body?.RequestInfo?.userInfo?.uuid,
        lastModifiedTime: Date.now(),
      },
      additionalDetails:
      {
        ...getLatestResourceDetails.additionalDetails,
        sheetErrors: request?.body?.additionalDetailsErrors,
        source:
          getLatestResourceDetails.additionalDetails?.source == "microplan"
            ? "microplan"
            : null,
      },
    };
    let additionalDetails = request?.body?.ResourceDetails?.additionalDetails;
    if (additionalDetails && additionalDetails[name]) {
      additionalDetails[name].push(fileStoreId);
    } else {
      additionalDetails = { ...additionalDetails, [name]: [fileStoreId] };
    }
    request.body.ResourceDetails.additionalDetails = additionalDetails;
  }

  const persistMessage: any = { ResourceDetails: request.body.ResourceDetails };
  await produceModifiedMessages(
    persistMessage,
    config?.kafka?.KAFKA_UPDATE_RESOURCE_DETAILS_TOPIC
  );
  logger.info(
    `ResourceDetails to persist : ${request.body.ResourceDetails.type}`
  );
}

export async function processDataForTargetCalculation(campaignDetails: any, jsonData: any, codeColumnName: string, localizationMap?: any) {
  // Retrieve targetConfigs from MDMS
  const targetConfigs = await searchMDMS([campaignDetails?.projectType], "HCM-ADMIN-CONSOLE.targetConfigs", defaultRequestInfo?.RequestInfo);

  // Process each row of the sheet data
  const resultantData = jsonData.map((row: any) => {

    // Initialize an object to hold row-specific data
    let rowData: any = { [codeColumnName]: row[codeColumnName] };

    rowData['currentBoundaryTarget'] = {};
    const beneficiaries = targetConfigs?.mdms?.[0]?.data?.beneficiaries;

    // Calculate the current target values
    calculateTargetsAtCurrentLevel(row, rowData, beneficiaries, localizationMap);

    // Return the processed row data
    return rowData;
  }).filter(Boolean); // Remove any null entries from the map (i.e., skip the header row)

  return resultantData;
}

export function calculateTargetsAtCurrentLevel(row: any, rowData: any, beneficiaries: any, localizationMap?: any) {
  // Loop through the beneficiaries again to calculate the current target values
  if (Array.isArray(beneficiaries) && beneficiaries?.length > 0) {
    for (const beneficiary of beneficiaries) {
      const beneficiaryType = beneficiary?.beneficiaryType;
      const columns = beneficiary?.columns;
      let totalCurrentValue = 0;

      // Loop through each column to calculate the total current value
      for (const col of columns) {
        const currentValue = row[getLocalizedName(col, localizationMap)];
        if (typeof currentValue === 'number' && Number.isInteger(currentValue)) {
          totalCurrentValue += currentValue;
        }
      }
      // Assign the total current value to the corresponding beneficiary type
      rowData['currentBoundaryTarget'][beneficiaryType] = totalCurrentValue;
    }
  }
  else {
    logger.warn("No beneficiaries config found for the specified campaign type");
  }
}

async function getResourceDetails(request: any) {
  const { tenantId, type, hierarchyType } =
    request?.body?.ResourceDetails || request?.query;
  const resourceDetails = request?.body?.ResourceDetails;

  request.body.SearchCriteria = request.body.SearchCriteria || {};

  request.body.SearchCriteria = {
    tenantId: tenantId,
    type: type,
    hierarchyType: hierarchyType,
    status: resourceDataStatuses.completed,
  };

  const response = await searchDataService(request);
  request.body.ResourceDetails = resourceDetails;
  if (response.length > 0) {
    response.sort(
      (a: any, b: any) =>
        b.auditDetails.lastModifiedTime - a.auditDetails.lastModifiedTime
    );
    return response[0];
  } else {
    return null;
  }
}
const addBoundaryCodeToGeoJsonData = (
  boundaryData: any,
  hiearchy: any,
  boundaryMap: Map<any, any>
) => {
  // const objectMap = boundaryMap.forEach((value, key) => {return { key: key.value, value: value });
  // Create the updatedBoundaryMap using a Map
  const updatedBoundaryMap = new Map();
  boundaryMap.forEach((value, key) => {
    const newKey = key.key + "_" + key.value; // Concatenate key and value
    updatedBoundaryMap.set(newKey, value); // Set in the updated map
  });

  // Iterate through the boundary data
  boundaryData.features.forEach((feature: any) => {
    // Extract the properties object from the feature
    const properties = feature.properties;

    // Iterate through the hierarchy
    hiearchy.forEach((h: string) => {
      // Build the field name
      const field = h.toLowerCase() + "_name";

      // Check if the field exists in the properties object
      if (properties[field]) {
        const boundaryName = h + "_" + properties[field];
        // Assign the boundary code to the properties object
        properties[config.boundary.boundaryCode] =
          updatedBoundaryMap.get(boundaryName); // Use .get() to access the Map
      }
    });
  });

  return boundaryData;
};
const getGeoJsonData = (boundaryData: any, hiearchy: any) => {
  var data: any = [];
  boundaryData.features?.forEach((feature: any) => {
    const properties = feature.properties;
    var row: any = [];
    hiearchy.forEach((h: string) => {
      const field = h.toLowerCase() + "_name";
      if (properties[field]) {
        const d = {
          key: h,
          value: properties[field],
        };
        row.push(d);
      }
    });
    data.push(row);
  });
  return data;
};

const getDataFromGeoJson = async (url: string) => {
  // Define headers for HTTP request
  const headers = {
    "Content-Type": "application/json",
    Accept: "application/json",
  };
  logger.info("loading for the file based on fileurl");
  // Make HTTP request to retrieve Excel file as arraybuffer
  const responseFile = await httpRequest(url, null, {}, "get", "json", headers);
  logger.info("received the file response");
  return responseFile;
};

const autoGenerateBoundaryCodes = async (
  request: any,
  localizationMap?: any
) => {
  const { hierarchyType, tenantId } = request?.body?.ResourceDetails || {};
  const hierarchy =
    (await getHierarchy(request, tenantId, hierarchyType)) || [];
  const headersOfBoundarySheet = hierarchy.map(
    (e) => `${hierarchyType.toUpperCase()}_${e.toUpperCase()}`
  );
  const localizedHeadersOfBoundarySheet = getLocalizedHeaders(
    headersOfBoundarySheet,
    localizationMap
  );
  const type = request?.body?.ResourceDetails?.type;
  const fileResponse = await httpRequest(
    config.host.filestore + config.paths.filestore + "/url",
    {},
    { tenantId, fileStoreIds: request?.body?.ResourceDetails?.fileStoreId },
    "get"
  );
  const localizedBoundaryTab = getLocalizedName(
    getBoundaryTabName(),
    localizationMap
  );
  var boundaryData = await getSheetData(
    fileResponse?.fileStoreIds?.[0]?.url,
    localizedBoundaryTab,
    false,
    undefined,
    localizationMap
  );
  var latLongData: any;
  if (type === "boundaryManagement") {
    validateBoundarySheetDataInCreateFlow(
      boundaryData,
      localizedHeadersOfBoundarySheet
    );
    const result = await updateBoundaryDataForBoundaryManagement(
      request,
      boundaryData,
      localizationMap
    );
    latLongData = result.latLongData;
    boundaryData = result.updatedData;
  }
  const updatedBoundaryData = updateBoundaryData(boundaryData, localizedHeadersOfBoundarySheet);
  const modifiedBoundaryData = modifyBoundaryDataHeaders(
    updatedBoundaryData,
    hierarchy,
    localizationMap
  );
  const [withBoundaryCode, withoutBoundaryCode] = modifyBoundaryData(
    modifiedBoundaryData,
    localizationMap
  );
  const { mappingMap, countMap } =
    getCodeMappingsOfExistingBoundaryCodes(withBoundaryCode);
  const childParentMap = getChildParentMap([
    ...withBoundaryCode,
    ...withoutBoundaryCode,
  ]);
  const boundaryMap = await getAutoGeneratedBoundaryCodesHandler(
    withoutBoundaryCode,
    childParentMap,
    mappingMap,
    countMap,
    request
  );
  logger.info("Boundary Code Auto Generation Completed");
  await createBoundaryEntities(request, boundaryMap);
  logger.info(
    "waiting for 2 secs to persist the boundary entities before creating boundary relationship"
  );
  await new Promise((resolve) => setTimeout(resolve, 2000));
  const modifiedChildParentMap = modifyChildParentMap(
    childParentMap,
    boundaryMap
  );
  await createBoundaryRelationship(
    request,
    boundaryMap,
    modifiedChildParentMap
  );
  const boundaryDataForSheet = addBoundaryCodeToData(
    withBoundaryCode,
    withoutBoundaryCode,
    boundaryMap
  );
  logger.info(
    "Initiated the localisation message creation for the uploaded boundary"
  );
  await transformAndCreateLocalisation(boundaryMap, request);
  const modifiedHierarchy = hierarchy.map((ele) =>
    `${hierarchyType}_${ele}`.toUpperCase()
  );
  var headers = [...modifiedHierarchy, config?.boundary?.boundaryCode];
  const data = prepareDataForExcel(
    boundaryDataForSheet,
    hierarchy,
    boundaryMap
  );
  if (type === "boundaryManagement") {
    headers = [
      ...headers,
      getLocalizedName("HCM_ADMIN_CONSOLE_LAT", localizationMap),
      getLocalizedName("HCM_ADMIN_CONSOLE_LONG", localizationMap),
    ];
    data.forEach((row: any[], index: string | number) => {
      if (latLongData.length > index) {
        row.push(latLongData[index][0], latLongData[index][1]);
      }
    });
  }
  const localizedHeaders = getLocalizedHeaders(headers, localizationMap);
  const boundarySheetData: any = await createExcelSheet(data, localizedHeaders);
  const workbook = getNewExcelWorkbook();
  const boundarySheet = workbook.addWorksheet(localizedBoundaryTab);
  addDataToSheet(type, boundarySheet, boundarySheetData, "93C47D", 40, true);
  const boundaryFileDetails: any = await createAndUploadFile(workbook, request);
  request.body.ResourceDetails.processedFileStoreId =
    boundaryFileDetails?.[0]?.fileStoreId;
};

function updateBoundaryData(boundaryData: any[], hierarchy: any[]): any[] {
  const map: Map<string, string> = new Map();
  const count: Map<string, number> = new Map();
  
  boundaryData = boundaryData.map(row =>
    Object.fromEntries(
      Object.entries(row).map(([key, value]) =>
        [key, typeof value === "string" ? value.trim() : value]
      )
    )
  );

  boundaryData.forEach((row) => {
    const keys = Object.keys(row).filter((key) => hierarchy.includes(key));
    keys.forEach((key, index) => {
      if (index > 0) {
        const element = row[key];
        const previousKey = keys[index - 1];
        const previousElement = row[keys[index - 1]];
        const previousElementKey = `${previousKey}:${previousElement}`;
        const elementKey = `${key}:${element}`;

        if (!map.has(elementKey)) {
          map.set(elementKey, previousElementKey);
          count.set(elementKey, 1);
        } else {
          const currentCount = count.get(elementKey)!;
          if (map.get(elementKey) !== previousElementKey) {
            map.set(elementKey, previousElementKey);
            count.set(elementKey, currentCount + 1);
          }
          const uniqueCount = count.get(elementKey)!;
          const uniqueElement =
            uniqueCount > 1
              ? `${element}-${(uniqueCount - 1).toString().padStart(2, "0")}`
              : `${element}`;
          row[key] = uniqueElement;
        }
      }
    });
  });
  return boundaryData;
}

function modifyBoundaryDataHeaders(
  boundaryData: any[],
  hierarchy: any[],
  localizationMap?: any
) {
  const updatedData = boundaryData.map((obj: any) => {
    const updatedObj: { [key: string]: string | undefined } = {}; // Updated object with modified keys

    let hierarchyIndex = 0; // Track the index of the hierarchy array

    for (const key in obj) {
      if (
        key != getLocalizedName(config?.boundary?.boundaryCode, localizationMap)
      ) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          const hierarchyKey = hierarchy[hierarchyIndex]; // Get the key from the hierarchy array
          updatedObj[hierarchyKey] = obj[key]; // Map the key to the updated object
          hierarchyIndex++; // Move to the next key in the hierarchy array
        }
      } else {
        updatedObj[key] = obj[key];
      }
    }

    return updatedObj;
  });
  return updatedData;
}

function modifyChildParentMap(
  childParentMap: Map<any, any>,
  boundaryMap: Map<any, any>
): Map<string, string | null> {
  const modifiedMap: Map<string, string | null> = new Map();

  // Iterate over each entry in childParentMap
  childParentMap.forEach((value, key) => {
    // Get the modified key and value from boundaryMap
    const modifiedKey = findMapValue(boundaryMap, key) || null;
    const modifiedValue = value ? findMapValue(boundaryMap, value) : null;

    // Set the modified key-value pair in modifiedMap
    modifiedMap.set(modifiedKey, modifiedValue);
  });

  return modifiedMap;
}

async function convertSheetToDifferentTabs(
  request: any,
  boundaryData: any,
  differentTabsBasedOnLevel: any,
  localizationMap?: any,
  fileUrl?: any
) {
  // create different tabs on the level of hierarchy we want to
  const updatedWorkbook = await appendSheetsToWorkbook(
    request,
    boundaryData,
    differentTabsBasedOnLevel,
    localizationMap,
    fileUrl
  );
  // upload the excel and generate file store id
  const boundaryDetails = await createAndUploadFile(updatedWorkbook, request);
  return boundaryDetails;
}

async function getBoundaryDataAfterGeneration(
  result: any,
  request: any,
  localizationMap?: any
) {
  const fileStoreId = result[0].fileStoreId;
  const fileResponse = await httpRequest(
    config.host.filestore + config.paths.filestore + "/url",
    {},
    { tenantId: request?.query?.tenantId, fileStoreIds: fileStoreId },
    "get"
  );
  if (!fileResponse?.fileStoreIds?.[0]?.url) {
    throwError("FILE", 400, "INVALID_FILE");
  }
  const boundaryData = await getSheetData(
    fileResponse?.fileStoreIds?.[0]?.url,
    getBoundaryTabName(),
    false,
    undefined,
    localizationMap
  );
  return boundaryData;
}

function getLocalizedName(
  expectedName: string,
  localizationMap?: { [key: string]: string }
) {
  if (!localizationMap || !(expectedName in localizationMap)) {
    return expectedName;
  }
  const localizedName = localizationMap[expectedName];
  return localizedName;
}

async function getTargetBoundariesRelatedToCampaignId(
  request: any,
  localizationMap?: any
) {
  let CampaignDetailsNew: any;
  if (request?.body?.ResourceDetails?.campaignId) {
    // const searchBody = {
    //   RequestInfo: request?.body?.RequestInfo,
    const CampaignDetails = {
      ids: [request?.body?.ResourceDetails?.campaignId],
      tenantId: request?.body?.ResourceDetails?.tenantId,
    }
    // const req: any = replicateRequest(request, searchBody);
    const response = await searchProjectTypeCampaignService(CampaignDetails);
    if (response?.CampaignDetails?.[0]) {
      CampaignDetailsNew = response?.CampaignDetails?.[0];
      await addBoundariesForData(request, CampaignDetailsNew);
    } else {
      throwError(
        "CAMPAIGN",
        400,
        "CAMPAIGN_NOT_FOUND",
        "Campaign not found while Validating sheet boundaries"
      );
    }
  }
  return CampaignDetailsNew?.boundaries;
}

async function getFiltersFromCampaignSearchResponse(
  request: any,
  responseFromCampaignSearch: any
) {
  const boundaries = await getBoundariesFromCampaignSearchResponse(
    request,
    responseFromCampaignSearch?.CampaignDetails?.[0]
  );
  const boundariesModified = boundaries?.map((ele: any) => ({
    ...ele,
    boundaryType: ele?.type,
  }));
  if (!boundariesModified) {
    logger.info(`no boundaries found so considering the complete hierarchy`);
    return { Filters: null };
  }
  logger.info(`boundaries found for filtering`);
  return { Filters: { boundaries: boundariesModified } };
}

const getConfigurableColumnHeadersBasedOnCampaignType = async (
  request: any,
  localizationMap?: any
) => {
  try {
    const responseFromCampaignSearch = await getCampaignSearchResponse(request);
    const campaignObject = responseFromCampaignSearch?.CampaignDetails?.[0];
    let campaignType = campaignObject?.projectType;
    const isSourceMicroplan = checkIfSourceIsMicroplan(campaignObject);
    campaignType = isSourceMicroplan
      ? `${config?.prefixForMicroplanCampaigns}-${campaignType}`
      : campaignType;
    const isUpdate = request?.body?.parentCampaignObject ? true : false;
    const mdmsResponse = await callMdmsTypeSchema(
      request,
      request?.query?.tenantId || request?.body?.ResourceDetails?.tenantId,
      isUpdate,
      request?.query?.type || request?.body?.ResourceDetails?.type,
      campaignType
    );
    if (!mdmsResponse || mdmsResponse?.columns.length === 0) {
      logger.error(
        `Campaign Type ${campaignType} has not any columns configured in schema`
      );
      throwError(
        "COMMON",
        400,
        "SCHEMA_ERROR",
        `Campaign Type ${campaignType} has not any columns configured in schema`
      );
    }
    // Extract columns from the response
    const columnsForGivenCampaignId = mdmsResponse?.columns;

    // Get localized headers based on the column names
    const headerColumnsAfterHierarchy = getLocalizedHeaders(
      columnsForGivenCampaignId,
      localizationMap
    );
    if (
      !headerColumnsAfterHierarchy.includes(
        getLocalizedName(config.boundary.boundaryCode, localizationMap)
      )
    ) {
      logger.error(
        `Column Headers of generated Boundary Template does not have ${getLocalizedName(
          config.boundary.boundaryCode,
          localizationMap
        )} column`
      );
      throwError(
        "COMMON",
        400,
        "VALIDATION_ERROR",
        `Column Headers of generated Boundary Template does not have ${getLocalizedName(
          config.boundary.boundaryCode,
          localizationMap
        )} column`
      );
    }
    return headerColumnsAfterHierarchy;
  } catch (error: any) {
    console.log(error);
    throwError(
      "FILE",
      400,
      "FETCHING_COLUMN_ERROR",
      "Error fetching column Headers From Schema (either boundary code column not found or given  Campaign Type not found in schema)."
    );
  }
};

async function getFinalValidHeadersForTargetSheetAsPerCampaignType(
  request: any,
  hierarchy: any[],
  differentTabsBasedOnLevel: any,
  localizationMap?: any
) {
  const modifiedHierarchy = hierarchy.map((ele) =>
    `${request?.body?.ResourceDetails?.hierarchyType}_${ele}`.toUpperCase()
  );
  const localizedHierarchy = getLocalizedHeaders(
    modifiedHierarchy,
    localizationMap
  );
  const index = localizedHierarchy.indexOf(
    getLocalizedName(differentTabsBasedOnLevel, localizationMap)
  );
  const responseFromCampaignSearch = await getCampaignSearchResponse(request);
  const campaignObject = responseFromCampaignSearch?.CampaignDetails?.[0];
  const isSourceMicroplan = checkIfSourceIsMicroplan(campaignObject);
  var expectedHeadersForTargetSheetUptoHierarchy: any;
  if (isSourceMicroplan) {
    expectedHeadersForTargetSheetUptoHierarchy = localizedHierarchy;
  } else {
    expectedHeadersForTargetSheetUptoHierarchy =
      index !== -1
        ? localizedHierarchy.slice(index)
        : throwError(
          "COMMON",
          400,
          "VALIDATION_ERROR",
          `${differentTabsBasedOnLevel} level not present in the hierarchy`
        );
  }
  const columnFromSchemaOfTargetTemplate = await generateDynamicTargetHeaders(
    request,
    campaignObject,
    localizationMap
  );
  const localizedcolumnFromSchemaOfTargetTemplate = getLocalizedHeaders(
    columnFromSchemaOfTargetTemplate,
    localizationMap
  );
  let updatedLocalizedcolumnFromSchemaOfTargetTemplate =
    localizedcolumnFromSchemaOfTargetTemplate;
  if (request?.body?.parentCampaignObject) {
    updatedLocalizedcolumnFromSchemaOfTargetTemplate =
      localizedcolumnFromSchemaOfTargetTemplate
        .map((item: any) => `${item}(OLD)`)
        .concat(localizedcolumnFromSchemaOfTargetTemplate);
  }
  const expectedHeadersForTargetSheet = [
    ...expectedHeadersForTargetSheetUptoHierarchy,
    getLocalizedName(config?.boundary?.boundaryCode, localizationMap),
    ...updatedLocalizedcolumnFromSchemaOfTargetTemplate,
  ];
  return expectedHeadersForTargetSheet;
}

async function getDifferentTabGeneratedBasedOnConfig(
  request: any,
  boundaryDataGeneratedBeforeDifferentTabSeparation: any,
  localizationMap?: any,
  fileUrl?: any
) {
  var boundaryDataGeneratedAfterDifferentTabSeparation: any =
    boundaryDataGeneratedBeforeDifferentTabSeparation;
  const boundaryData = await getBoundaryDataAfterGeneration(
    boundaryDataGeneratedBeforeDifferentTabSeparation,
    request,
    localizationMap
  );
  let differentTabsBasedOnLevel = await getBoundaryOnWhichWeSplit(
    request,
    request?.query?.tenantId
  );
  differentTabsBasedOnLevel = getLocalizedName(
    `${request?.query?.hierarchyType}_${differentTabsBasedOnLevel}`.toUpperCase(),
    localizationMap
  );
  logger.info(
    `Boundaries are seperated based on hierarchy type ${differentTabsBasedOnLevel}`
  );
  const isKeyOfThatTypePresent = boundaryData.some((data: any) =>
    data.hasOwnProperty(differentTabsBasedOnLevel)
  );
  const boundaryTypeOnWhichWeSplit = boundaryData.filter(
    (data: any) => data[differentTabsBasedOnLevel]
  );
  if (
    isKeyOfThatTypePresent &&
    boundaryTypeOnWhichWeSplit.length >=
    parseInt(config?.boundary?.numberOfBoundaryDataOnWhichWeSplit)
  ) {
    logger.info(
      `sinces the conditions are matched boundaries are getting splitted into different tabs`
    );
    boundaryDataGeneratedAfterDifferentTabSeparation =
      await convertSheetToDifferentTabs(
        request,
        boundaryData,
        differentTabsBasedOnLevel,
        localizationMap,
        fileUrl
      );
  }
  return boundaryDataGeneratedAfterDifferentTabSeparation;
}

async function getBoundaryOnWhichWeSplit(request: any, tenantId: any) {
  const responseFromCampaignSearch = await getCampaignSearchResponse(request);
  const MdmsCriteria: any = {
    tenantId: tenantId,
    schemaCode: `${config.values.moduleName}.${config.masterNameForSplitBoundariesOn}`,
    filters: {
      hierarchy: responseFromCampaignSearch?.CampaignDetails?.[0].hierarchyType,
    },
  };
  const mdmsResponse: any = await searchMDMSDataViaV2Api(MdmsCriteria);
  if (!Array.isArray(mdmsResponse?.mdms) || mdmsResponse.mdms.length === 0) {
    throwError("MDMS", 500, "MDMS_DATA_NOT_FOUND_ERROR", `${responseFromCampaignSearch?.CampaignDetails?.[0].hierarchyType} hierarchy not configured in mdms data 
                ${config.values.moduleName}.${config.masterNameForSplitBoundariesOn}`)
  }
  return mdmsResponse?.mdms?.[0]?.data?.splitBoundariesOn;
}

function checkIfSourceIsMicroplan(objectWithAdditionalDetails: any): boolean {
  return objectWithAdditionalDetails?.additionalDetails?.source === "microplan";
}

function createIdRequestsForEmployees(numberOfEmployess: number, tenantId: string): any[] {
  if (numberOfEmployess > 0) {
    return Array.from({ length: numberOfEmployess }, () => ({
      tenantId: tenantId,
      idName: config?.values?.idgen?.idNameForUserNameGeneration,
      format: config?.values?.idgen?.formatForUserName,
    }));
  } else {
    return [];
  }
}

async function createUniqueUserNameViaIdGen(idRequests: any) {
  const requestBody = {
    RequestInfo: defaultRequestInfo?.RequestInfo,
    idRequests: idRequests
  }
  const idgenurl = config?.host?.idGenHost + config?.paths?.idGen;
  try {
    // Make HTTP request to ID generation service
    const result = await httpRequest(
      idgenurl,
      requestBody,
      undefined,
      undefined,
      undefined,
      undefined
    );

    // Return null if ID generation fails
    return result;
  } catch (error: any) {
    // Log the error
    logger.error(`Error during ID generation: ${error.message}`);

    // Throw a custom error
    throwError(
      "ID_GENERATION",
      500,
      "ID_GENERATION_FAILED",
      `Error occurred while generating ID: ${error.message}`
    );
  }
}

async function processFetchMicroPlan(request: any) {
  try {
    logger.info("Waiting for 1 second for templates to get generated...");
    await new Promise((resolve) => setTimeout(resolve, 1000));

    logger.info("Started processing fetch microplan");

    const { tenantId } = request.body.MicroplanDetails;
    const localizationMap = await getLocalizedMessagesHandler(request, tenantId);
    const resources: any = request?.body?.CampaignDetails?.resources || [];
    const filteredResources = resources.filter(
      (obj: any) => obj?.filestoreId && obj?.resourceId
    );

    logger.info(`Filtered resources with valid IDs: ${filteredResources?.length}`);
    logger.debug(`Filtered resources: ${getFormattedStringForDebug(filteredResources)}`);

    const fetchOperations: Promise<void>[] = [];

    // Add fetch operations conditionally
    if (filteredResources.length === 0 || filteredResources.every((obj: any) => obj?.type !== "facility")) {
      fetchOperations.push(fetchFacilityData(request, localizationMap));
    }
    if (filteredResources.length === 0 || filteredResources.every((obj: any) => obj?.type !== "boundaryWithTarget")) {
      fetchOperations.push(fetchTargetData(request, localizationMap));
    }
    if (filteredResources.length === 0 || filteredResources.every((obj: any) => obj?.type !== "user")) {
      fetchOperations.push(fetchUserData(request, localizationMap));
    }

    // Run all fetch operations in parallel
    await Promise.all(fetchOperations);

    logger.info("Updating campaign object after successful fetch microplan...");
    await updateCampaignAfterSearch(request, "MICROPLAN_COMPLETED");

    logger.info("Completed processing fetch microplan");
  } catch (error: any) {
    logger.error(`Error during microplan fetch: ${error.message}`);
    await updateCampaignAfterSearch(request, "MICROPLAN_FETCH_FAILED");
  }
}


async function updateCampaignAfterSearch(request: any, source = "MICROPLAN_FETCHING") {
  logger.info("search campaign with id ")
  const { tenantId, campaignId } = request.body.MicroplanDetails;
  const campaignDetails = {
    tenantId: tenantId,
    ids: [campaignId]
  }
  const searchedCampaignResponse = await searchProjectTypeCampaignService(campaignDetails)
  const searchedCamapignObject = searchedCampaignResponse?.CampaignDetails;
  if (Array.isArray(searchedCamapignObject) && searchedCamapignObject.length > 0) {
    const newRequestBody = {
      RequestInfo: request.body.RequestInfo, // Retain the original RequestInfo
      CampaignDetails: searchedCamapignObject?.[0] // campaigndetails from search response
    };
    const req: any = replicateRequest(request, newRequestBody)
    logger.info("Updating the received campaign object, source & its key");
    if (!req.body.CampaignDetails.additionalDetails) {
      req.body.CampaignDetails.additionalDetails = {};
    }
    req.body.CampaignDetails.additionalDetails.activity = source;
    (!req.body?.CampaignDetails?.additionalDetails?.["disease"]) && (req.body.CampaignDetails.additionalDetails["disease"] = "MALARIA"),
      (!req.body?.CampaignDetails?.additionalDetails?.["beneficiaryType"]) && (req.body.CampaignDetails.additionalDetails["beneficiaryType"] =
        "INDIVIDUAL");
    req.body.CampaignDetails.additionalDetails["key"] = 1;
    logger.debug(
      `updated object with new source , disease & beneficiarytype ${getFormattedStringForDebug(req.body.CampaignDetails)}`
    );
    await updateProjectTypeCampaignService(req);
    logger.info("Updated the received campaign object");
  } else {
    throwError("CAMPAIGN", 500, "CAMPAIGN_SEARCH_ERROR", "Error in campaign search");
  }
}

export async function handleCampaignProcessing(messageObject: any) {
  try {
    const { processName, campaignDetailsAndRequestInfo } = messageObject;
    switch (processName) {
      case processNamesConstantsInOrder.projectCreation:
        await processProjectCreation(campaignDetailsAndRequestInfo);
        break;
      case processNamesConstantsInOrder.employeeCreation:
        await processEmployeeCreation(campaignDetailsAndRequestInfo);
        break;
      case processNamesConstantsInOrder.facilityCreation:
        await processFacilityCreation(campaignDetailsAndRequestInfo);
        break;
      case processNamesConstantsInOrder.mapping:
        await processCampaignMappings(campaignDetailsAndRequestInfo);
        break;
      default:
        logger.info(`No process found for ${processName}`);
        break;
    }
  }
  catch (error: any) {
    console.error(error);
    logger.error(`Error during campaign processing: ${error.message}`);
    await markProcessStatus(messageObject?.campaignDetailsAndRequestInfo?.CampaignDetails.campaignNumber, messageObject?.processName, processTrackStatuses.failed, error?.message);
  }
}

export async function handleCampaignSubProcessing(messageObject: any) {
  try {
    const { processName, campaignNumber, data } = messageObject;
    const isProcessFailed = await checkifProcessIsFailed(processName, campaignNumber);
    if (isProcessFailed) return;
    switch (processName) {
      case processNamesConstantsInOrder.projectCreation:
        await processSubProjectCreationFromConsumer(data, campaignNumber);
        break;
      case processNamesConstantsInOrder.employeeCreation:
        await processSubEmployeeCreationFromConsumer(data, campaignNumber);
        break;
      case processNamesConstantsInOrder.facilityCreation:
        await processSubFacilityCreationFromConsumer(data, campaignNumber);
        break;
      case processNamesConstantsInOrder.mapping:
        await processSubMappingFromConsumer(data, campaignNumber);
        break;
      default:
        logger.info(`No sub process found for ${processName}`);
        break;
    }
  }
  catch (error: any) {
    console.error(error);
    logger.error(`Error during campaign processing: ${error.message}`);
    await markProcessStatus(messageObject?.campaignNumber, messageObject?.processName, processTrackStatuses.failed, error?.message);
  }
}

export async function updateCreateResourceId(CampaignDetails: any, resourceType: any, processedFileStoreId: any, userUuid: string) {
  const currentTime = new Date().getTime();
  const resourceFileStoreId = CampaignDetails?.resources?.find((resource: any) => resource?.type === resourceType)?.filestoreId;
  const ResourceDetails = {
    id : uuidv4(),
    status: resourceDataStatuses.completed,
    tenantId : CampaignDetails?.tenantId,
    fileStoreId : resourceFileStoreId,
    processedFileStoreId: processedFileStoreId,
    action : "create",
    campaignId : CampaignDetails?.id,
    type : resourceType,
    auditDetails : {
      createdBy : userUuid,
      lastModifiedBy : userUuid,
      createdTime : currentTime,
      lastModifiedTime : currentTime
    },
    additionalDetails : {},
    hierarchyType : CampaignDetails?.hierarchyType
  }
  const produceMessageForResource = {
    ResourceDetails : ResourceDetails
  }
  await produceModifiedMessages(produceMessageForResource, config.kafka.KAFKA_CREATE_RESOURCE_DETAILS_TOPIC);
  CampaignDetails.resources.find((resource: any) => resource?.type === resourceType).createResourceId = ResourceDetails?.id;
  const campaignDetails = {
    resources: CampaignDetails?.resources || CampaignDetails?.camapignDetails?.resources,
    boundaries : CampaignDetails?.boundaries || CampaignDetails?.camapignDetails?.boundaries,
    deliveryRules : CampaignDetails?.deliveryRules || CampaignDetails?.camapignDetails?.deliveryRules
  }
  logger.info(`Updated resource details for resource type: ${resourceType}`);
  CampaignDetails.campaignDetails = campaignDetails
  const produceModifiedMessageForCampaign = {
    CampaignDetails : CampaignDetails
  }
  await produceModifiedMessages(produceModifiedMessageForCampaign, config.kafka.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC);
}

export function getBoundaryCodeAndBoundaryTypeMapping(boundaries : any, currentMapping : any = {}) {
   for(const boundary of boundaries) {
     currentMapping[boundary.code] = boundary.boundaryType;
     if(boundary.children?.length > 0) {
       getBoundaryCodeAndBoundaryTypeMapping(boundary.children, currentMapping);
     }
   }
   return currentMapping;
}

export function getResourceFileIdFromCampaignDetails(campaignDetails: any, resourceType: string) {
  const fileId = campaignDetails?.resources?.find((resource: any) => resource?.type == resourceType)?.filestoreId;
  if (!fileId) {
    throw new Error(`${resourceType} file not found in campaign details`);
  }
  else {
    return fileId;
  }
}

export async function getAllFormatedDataFromDataSheet(type: any, dataFromSheet: any, localizationMap: any) {
  const parseLogic = createAndSearch[type]?.parseArrayConfig?.parseLogic;
  const allData = [];
  for (const data of dataFromSheet) {
    const resultantElement: any = {};
    for (const element of parseLogic) {
      if (element?.resultantPath) {
        const localizedSheetColumnName = getLocalizedName(
          element.sheetColumnName,
          localizationMap
        );
        let dataToSet = _.get(data, localizedSheetColumnName);
        if (dataToSet !== undefined) {
          if (element.conversionCondition) {
            dataToSet = element.conversionCondition[dataToSet];
          }
          if (element.type) {
            dataToSet = convertToType(dataToSet, element.type);
          }
          _.set(resultantElement, element.resultantPath, dataToSet);
        }
      }
    }
    resultantElement["!row#number!"] = data["!row#number!"];
    const usageColumnName = getLocalizedName(createAndSearch[type]?.activeColumnName, localizationMap);
    resultantElement["!isActive!"] = _.get(data, usageColumnName);
    allData.push(resultantElement);
  }
  return allData;
}

export async function enrichProcessedFileAndPersist(campaignDetailsAndRequestInfo: any, resourceType: string) {
  const { CampaignDetails, RequestInfo } = campaignDetailsAndRequestInfo;
  const tenantId = CampaignDetails?.tenantId;
  const resourceFileId = CampaignDetails?.resources?.find((resource: any) => resource?.type == resourceType)?.filestoreId;
  if (!resourceFileId) {
    throw new Error(`Resource file not found for resource type: ${resourceType}`);
  }
  else {
    const fileResponse = await httpRequest(`${config.host.filestore}${config.paths.filestore}/url`, {}, { tenantId, fileStoreIds: resourceFileId }, "get");
    if (!fileResponse?.fileStoreIds?.[0]?.url) {
      throwError("FILE", 500, "DOWNLOAD_URL_NOT_FOUND");
    }
    if (resourceType == "user") {
      await persistCreateResourceIdForUser(CampaignDetails, RequestInfo, fileResponse, resourceFileId, tenantId);
    }
    else if (resourceType == "facility") {
      await persistCreateResourceIdForFacility(CampaignDetails, RequestInfo, fileResponse, resourceFileId, tenantId);
    }
    else if (resourceType == "boundaryWithTarget") {
      await persistCreateResourceIdForBoundaryWithTarget(CampaignDetails, RequestInfo, fileResponse, resourceFileId, tenantId);
    }
  }
}

export {
  generateProcessedFileAndPersist,
  convertToTypeData,
  getChildParentMap,
  addBoundaryCodeToData,
  prepareDataForExcel,
  extractCodesFromBoundaryRelationshipResponse,
  searchProjectCampaignResourcData,
  processDataSearchRequest,
  getCodeMappingsOfExistingBoundaryCodes,
  processBasedOnAction,
  appendSheetsToWorkbook,
  generateFilteredBoundaryData,
  generateHierarchy,
  createBoundaryMap,
  autoGenerateBoundaryCodes,
  convertSheetToDifferentTabs,
  getBoundaryDataAfterGeneration,
  boundaryBulkUpload,
  enrichAndPersistCampaignWithError,
  getLocalizedName,
  reorderBoundariesOfDataAndValidate,
  getTargetBoundariesRelatedToCampaignId,
  getFiltersFromCampaignSearchResponse,
  getConfigurableColumnHeadersBasedOnCampaignType,
  getFinalValidHeadersForTargetSheetAsPerCampaignType,
  getDifferentTabGeneratedBasedOnConfig,
  checkIfSourceIsMicroplan,
  getBoundaryOnWhichWeSplit,
  createIdRequestsForEmployees,
  createUniqueUserNameViaIdGen,
  getRootBoundaryCode,
  boundaryGeometryManagement,
  getResourceDetails,
  enrichInnerCampaignDetails,
  processFetchMicroPlan,
  updateCampaignAfterSearch,
  processBoundary,
};
