
import { defaultheader, httpRequest } from "./request";
import config from "../config/index";
import { v4 as uuidv4 } from 'uuid';
import { produceModifiedMessages } from "../kafka/Producer";
import { confirmProjectParentCreation, createProjectCampaignResourcData, getCampaignSearchResponse, getHierarchy, handleResouceDetailsError, projectCreate } from "../api/campaignApis";
import { getCampaignNumber, createAndUploadFile, getSheetData, createExcelSheet, getAutoGeneratedBoundaryCodesHandler, createBoundaryEntities, createBoundaryRelationship, getMDMSV1Data, getTargetSheetDataAfterCode, callMdmsTypeSchema, getSheetDataFromWorksheet } from "../api/genericApis";
import { getFormattedStringForDebug, logger } from "./logger";
import createAndSearch from "../config/createAndSearch";
import { addDataToSheet, createBoundaryDataMainSheet, createReadMeSheet, findMapValue, getBoundaryRelationshipData, getConfigurableColumnHeadersFromSchemaForTargetSheet, getLocalizedHeaders, getLocalizedMessagesHandler, getMdmsDataBasedOnCampaignType, modifyBoundaryData, replicateRequest, throwError } from "./genericUtils";
import { enrichProjectDetailsFromCampaignDetails } from "./transforms/projectTypeUtils";
import { executeQuery } from "./db";
import { campaignDetailsTransformer, genericResourceTransformer } from "./transforms/searchResponseConstructor";
import { transformAndCreateLocalisation } from "./transforms/localisationMessageConstructor";
import { campaignStatuses, headingMapping, processTrackStatuses, processTrackTypes, resourceDataStatuses } from "../config/constants";
import { getBoundaryColumnName, getBoundaryTabName } from "./boundaryUtils";
import { searchProjectTypeCampaignService } from "../service/campaignManageService";
import { validateBoundaryOfResouces } from "../validators/campaignValidators";
import { getExcelWorkbookFromFileURL, getNewExcelWorkbook, lockTargetFields, updateFontNameToRoboto } from "./excelUtils";
import { areBoundariesSame, callGenerateIfBoundariesDiffer } from "./generateUtils";
import { createProcessTracks, persistTrack } from "./processTrackUtils";
import { generateDynamicTargetHeaders, isDynamicTargetTemplateForProjectType, updateTargetColumnsIfDeliveryConditionsDifferForSMC } from "./targetUtils";
const _ = require('lodash');



function updateRange(range: any, worksheet: any) {
    let maxColumnIndex = 0;

    // Iterate through each row to find the last column with data
    for (let row = range.s.r; row <= range.e.r; row++) {
        const rowCells = worksheet.getRow(row + 1); // ExcelJS rows are 1-based
        rowCells.eachCell((cell: any, colNumber: number) => {
            if (cell.value !== undefined && colNumber > maxColumnIndex) {
                maxColumnIndex = colNumber;
            }
        });
    }

    // Update the end column of the range with the maximum column index found
    range.e.c = maxColumnIndex;
}

function findAndChangeColumns(worksheet: any, columns: any) {
    const firstRow = worksheet.getRow(1); // First row (ExcelJS is 1-based)
    firstRow.eachCell((cell: any, colNumber: number) => {
        if (cell.value === '#status#') {
            columns.statusColumn = cell.address.replace(/\d+/g, '');
            // Set the cell color to green
            cell.fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'CCCC00' }
            };
            // Delete status column cells in subsequent rows
            worksheet.eachRow((row: any, rowIndex: number) => {
                if (rowIndex > 1) {
                    const statusCell = row.getCell(colNumber);
                    statusCell.value = undefined;
                }
            });
        }
        if (cell.value === '#errorDetails#') {
            columns.errorDetailsColumn = cell.address.replace(/\d+/g, '');
            // Set the cell color to green
            cell.fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'CCCC00' }
            };
            // Delete error details column cells in subsequent rows
            worksheet.eachRow((row: any, rowIndex: number) => {
                if (rowIndex > 1) {
                    const errorDetailsCell = row.getCell(colNumber);
                    errorDetailsCell.value = undefined;
                }
            });
        }
    });
}

function makeColumns(worksheet: any, range: any, columns: any) {
    // If the status column doesn't exist, calculate the next available column
    if (!columns?.statusColumn) {
        const emptyColumnIndex = range.e.c;
        columns.statusColumn = String.fromCharCode(65 + (emptyColumnIndex + 1));
        const statusCell = worksheet.getCell(`${columns.statusColumn}1`);
        statusCell.value = '#status#';
        statusCell.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'CCCC00' }
        };
        statusCell.font = { bold: true };
    }

    // Calculate errorDetails column one column to the right of status column
    if (!columns?.errorDetailsColumn) {
        columns.errorDetailsColumn = String.fromCharCode(columns?.statusColumn.charCodeAt(0) + 1);
        const errorDetailsCell = worksheet.getCell(`${columns.errorDetailsColumn}1`);
        errorDetailsCell.value = '#errorDetails#';
        errorDetailsCell.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'CCCC00' }
        };
        errorDetailsCell.font = { bold: true };
    }
}


function findColumns(worksheet: any) {
    const range = {
        s: { r: 0, c: 0 },
        e: { r: worksheet.rowCount - 1, c: worksheet.columnCount - 1 }
    };

    // Check if the status column already exists in the first row
    var columns = {}

    findAndChangeColumns(worksheet, columns);

    makeColumns(worksheet, range, columns);

    updateRange(range, worksheet);

    return columns;
}

function enrichErrors(errorData: any, worksheet: any, statusColumn: any, errorDetailsColumn: any, additionalDetailsErrors: any, createAndSearchConfig: any, localizationMap?: { [key: string]: string }) {
    if (errorData) {
        errorData.forEach((error: any) => {
            const rowIndex = error.rowNumber; // ExcelJS rows are 1-based
            const statusCell = worksheet.getCell(`${statusColumn}${rowIndex}`);
            const errorDetailsCell = worksheet.getCell(`${errorDetailsColumn}${rowIndex}`);
            statusCell.value = error.status;
            errorDetailsCell.value = error.errorDetails;

            if ((error?.status) && !(error?.status === "CREATED" || error?.status === "VALID")) {
                additionalDetailsErrors.push(error);
            }
        });
        if (errorData.some((error: any) => error?.status === "CREATED")) {
            const uniqueIdentifierFirstRowCell = `${createAndSearchConfig?.uniqueIdentifierColumn}1`;
            const columnName = getLocalizedName(createAndSearchConfig?.uniqueIdentifierColumnName, localizationMap);
            const uniqueIdentifierCell = worksheet.getCell(uniqueIdentifierFirstRowCell);
            uniqueIdentifierCell.value = columnName;

            // Set the cell color to green
            uniqueIdentifierCell.fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'ff9248' } // Green color
            };
            uniqueIdentifierCell.font = { bold: true };
            // Hide the unique identifier column
            worksheet.getColumn(createAndSearchConfig?.uniqueIdentifierColumn).hidden = true;
        }
        errorData.forEach((error: any) => {
            const rowIndex = error.rowNumber;
            if (error.isUniqueIdentifier) {
                const uniqueIdentifierCell = worksheet.getCell(`${createAndSearchConfig.uniqueIdentifierColumn}${rowIndex}`);
                uniqueIdentifierCell.value = error.uniqueIdentifier;
                if (createAndSearchConfig?.activeColumn) {
                    const activeCell = worksheet.getCell(`${createAndSearchConfig.activeColumn}${rowIndex}`);
                    activeCell.value = "Active";
                }
            }
        });
    }
}

function enrichActiveColumn(worksheet: any, createAndSearchConfig: any, request: any) {
    if (createAndSearchConfig?.activeColumn && request?.body?.dataToCreate) {
        const dataToCreate = request.body.dataToCreate;
        for (const data of dataToCreate) {
            const rowNumber = data['!row#number!'];
            const activeCell = worksheet.getCell(`${createAndSearchConfig?.activeColumn}${rowNumber}`);
            activeCell.value = "Active";
        }
    }
}

function deterMineLastColumnAndEnrichUserDetails(worksheet: any, errorDetailsColumn: any, userNameAndPassword: any, request: any, createAndSearchConfig: any) {
    let lastColumn = errorDetailsColumn;
    if (createAndSearchConfig?.uniqueIdentifierColumn !== undefined) {
        lastColumn = createAndSearchConfig?.uniqueIdentifierColumn > errorDetailsColumn ?
            createAndSearchConfig?.uniqueIdentifierColumn :
            errorDetailsColumn;
    }

    if (userNameAndPassword) {
        worksheet.getCell("I1").value = "UserName";
        worksheet.getCell("J1").value = "Password";

        // Set the fill color to green for cell I1
        worksheet.getCell("I1").fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'ff9248' } // Green color
        };
        worksheet.getCell("I1").font = { bold: true };

        // Set the fill color to green for cell J1
        worksheet.getCell("J1").fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'ff9248' } // Green color
        };
        worksheet.getCell("J1").font = { bold: true };

        userNameAndPassword.forEach((data: any) => {
            const rowIndex = data.rowNumber;
            worksheet.getCell(`I${rowIndex}`).value = data?.userName;
            worksheet.getCell(`J${rowIndex}`).value = data?.password;
        });

        lastColumn = "J";
        request.body.userNameAndPassword = undefined;
    }

    return lastColumn;
}

function adjustRef(worksheet: any, lastColumn: any) {
    const range = getSheetDataFromWorksheet(worksheet).filter((row: any) => row).length; // Get the number of used rows
    worksheet.views = [
        { state: 'frozen', ySplit: 1, topLeftCell: 'A2', activeCell: 'A2' }
    ];
    worksheet.autoFilter = {
        from: {
            row: 1,
            column: 1
        },
        to: {
            row: range,
            column: worksheet.getColumn(lastColumn).number
        }
    };
}

function processErrorData(request: any, createAndSearchConfig: any, workbook: any, sheetName: any, localizationMap?: { [key: string]: string }) {
    const worksheet = workbook.getWorksheet(sheetName);
    const errorData = request.body.sheetErrorDetails;
    const userNameAndPassword = request.body.userNameAndPassword;
    const columns: any = findColumns(worksheet);
    const statusColumn = columns.statusColumn;
    const errorDetailsColumn = columns.errorDetailsColumn;
    const additionalDetailsErrors: any[] = [];

    enrichErrors(errorData, worksheet, statusColumn, errorDetailsColumn, additionalDetailsErrors, createAndSearchConfig, localizationMap);
    enrichActiveColumn(worksheet, createAndSearchConfig, request);

    request.body.additionalDetailsErrors = additionalDetailsErrors;

    // Determine the last column to set the worksheet ref
    const lastColumn = deterMineLastColumnAndEnrichUserDetails(worksheet, errorDetailsColumn, userNameAndPassword, request, createAndSearchConfig);

    // Adjust the worksheet ref to include the last column
    adjustRef(worksheet, lastColumn);
    updateFontNameToRoboto(worksheet)

    workbook.xlsx.writeBuffer();
}


function processErrorDataForTargets(request: any, createAndSearchConfig: any, workbook: any, sheetName: any) {
    const desiredSheet = workbook.getWorksheet(sheetName);
    const columns: any = findColumns(desiredSheet);
    const statusColumn = columns.statusColumn;
    const errorDetailsColumn = columns.errorDetailsColumn;

    const errorData = request.body.sheetErrorDetails.filter((error: any) => error.sheetName === sheetName);
    const additionalDetailsErrors: any = [];

    if (errorData) {
        errorData.forEach((error: any) => {
            const rowIndex = error.rowNumber;
            if (error.isUniqueIdentifier) {
                const uniqueIdentifierCell = createAndSearchConfig.uniqueIdentifierColumn + (rowIndex);
                desiredSheet.getCell(uniqueIdentifierCell).value = error.uniqueIdentifier;
            }

            const statusCell = statusColumn + (rowIndex);
            const errorDetailsCell = errorDetailsColumn + (rowIndex);
            desiredSheet.getCell(statusCell).value = error.status;
            desiredSheet.getCell(errorDetailsCell).value = error.errorDetails;

            if (!(error.status === "CREATED" || error.status === "VALID")) {
                additionalDetailsErrors.push(error);
            }
        });
    }

    request.body.additionalDetailsErrors = additionalDetailsErrors;
    updateFontNameToRoboto(desiredSheet)
    workbook.worksheets[sheetName] = desiredSheet;
}

async function updateStatusFile(request: any, localizationMap?: { [key: string]: string }) {
    const fileStoreId = request?.body?.ResourceDetails?.fileStoreId;
    const tenantId = request?.body?.ResourceDetails?.tenantId;
    const createAndSearchConfig = createAndSearch[request?.body?.ResourceDetails?.type];
    const fileResponse = await httpRequest(config.host.filestore + config.paths.filestore + "/url", {}, { tenantId: tenantId, fileStoreIds: fileStoreId }, "get");

    if (!fileResponse?.fileStoreIds?.[0]?.url) {
        throwError("FILE", 500, "INVALID_FILE");
    }
    const fileUrl = fileResponse?.fileStoreIds?.[0]?.url;
    const sheetName = createAndSearchConfig?.parseArrayConfig?.sheetName;
    const localizedSheetName = getLocalizedName(sheetName, localizationMap);
    const workbook: any = await getExcelWorkbookFromFileURL(fileUrl, localizedSheetName);
    const worksheet: any = workbook.getWorksheet(localizedSheetName);
    processErrorData(request, createAndSearchConfig, workbook, localizedSheetName, localizationMap);

    // Set column widths
    const columnWidths = Array(12).fill({ width: 30 });
    columnWidths.forEach((colWidth, index) => {
        if (worksheet.getColumn(index + 1)) {
            worksheet.getColumn(index + 1).width = colWidth.width;
        }
    });

    const responseData = await createAndUploadFile(workbook, request);

    logger.info('File updated successfully:' + JSON.stringify(responseData));
    if (responseData?.[0]?.fileStoreId) {
        request.body.ResourceDetails.processedFileStoreId = responseData?.[0]?.fileStoreId;
    } else {
        throwError("FILE", 500, "STATUS_FILE_CREATION_ERROR");
    }
}
async function updateStatusFileForTargets(request: any, localizationMap?: { [key: string]: string }) {
    const fileStoreId = request?.body?.ResourceDetails?.fileStoreId;
    const tenantId = request?.body?.ResourceDetails?.tenantId;
    const createAndSearchConfig = createAndSearch[request?.body?.ResourceDetails?.type];
    const fileResponse = await httpRequest(config.host.filestore + config.paths.filestore + "/url", {}, { tenantId: tenantId, fileStoreIds: fileStoreId }, "get");

    if (!fileResponse?.fileStoreIds?.[0]?.url) {
        throwError("FILE", 500, "INVALID_FILE");
    }


    const fileUrl = fileResponse?.fileStoreIds?.[0]?.url;

    const workbook: any = await getExcelWorkbookFromFileURL(fileUrl, "");

    const sheetNames = workbook.worksheets.map((worksheet: any) => worksheet.name);
    const localizedSheetNames = getLocalizedHeaders(sheetNames, localizationMap);

    localizedSheetNames.forEach((sheetName: any) => {
        if (sheetName !== getLocalizedName(config?.boundary?.boundaryTab, localizationMap) && sheetName !== getLocalizedName(config.values.readMeTab, localizationMap)) {
            processErrorDataForTargets(request, createAndSearchConfig, workbook, sheetName);
        }
    });

    const responseData = await createAndUploadFile(workbook, request);
    logger.info('File updated successfully:' + JSON.stringify(responseData));
    if (responseData?.[0]?.fileStoreId) {
        request.body.ResourceDetails.processedFileStoreId = responseData?.[0]?.fileStoreId;
    } else {
        throwError("FILE", 500, "STATUS_FILE_CREATION_ERROR");
    }
}


function convertToType(dataToSet: any, type: any) {
    switch (type) {
        case "string":
            return String(dataToSet);
        case "number":
            return Number(dataToSet);
        case "boolean":
            // Convert to boolean assuming any truthy value should be true and falsy should be false
            return Boolean(dataToSet);
        // Add more cases if needed for other types
        default:
            // If type is not recognized, keep dataToSet as it is
            return dataToSet;
    }
}

function setTenantId(
    resultantElement: any,
    requestBody: any,
    createAndSearchConfig: any
) {
    if (createAndSearchConfig?.parseArrayConfig?.tenantId) {
        const tenantId = _.get(requestBody, createAndSearchConfig?.parseArrayConfig?.tenantId?.getValueViaPath);
        _.set(resultantElement, createAndSearchConfig?.parseArrayConfig?.tenantId?.resultantPath, tenantId);
    }

}


async function processData(request: any, dataFromSheet: any[], createAndSearchConfig: any, localizationMap?: { [key: string]: string }) {
    const parseLogic = createAndSearchConfig?.parseArrayConfig?.parseLogic;
    const requiresToSearchFromSheet = createAndSearchConfig?.requiresToSearchFromSheet;
    var createData = [], searchData = [];
    for (const data of dataFromSheet) {
        const resultantElement: any = {};
        for (const element of parseLogic) {
            if (element?.resultantPath) {
                const localizedSheetColumnName = getLocalizedName(element.sheetColumnName, localizationMap);
                let dataToSet = _.get(data, localizedSheetColumnName);
                if (element.conversionCondition) {
                    dataToSet = element.conversionCondition[dataToSet];
                }
                if (element.type) {
                    dataToSet = convertToType(dataToSet, element.type);
                }
                _.set(resultantElement, element.resultantPath, dataToSet);
            }
        }
        resultantElement["!row#number!"] = data["!row#number!"];
        var addToCreate = true;
        if (requiresToSearchFromSheet) {
            for (const key of requiresToSearchFromSheet) {
                const localizedSheetColumnName = getLocalizedName(key.sheetColumnName, localizationMap);
                if (data[localizedSheetColumnName]) {
                    searchData.push(resultantElement)
                    addToCreate = false;
                    break;
                }
            }
        }
        if (addToCreate) {
            createData.push(resultantElement)
        }
    }
    return { searchData, createData };
}

function setTenantIdAndSegregate(processedData: any, createAndSearchConfig: any, requestBody: any) {
    for (const resultantElement of processedData.createData) {
        setTenantId(resultantElement, requestBody, createAndSearchConfig);
    }
    for (const resultantElement of processedData.searchData) {
        setTenantId(resultantElement, requestBody, createAndSearchConfig);
    }
    return processedData;
}

// Original function divided into two parts
async function convertToTypeData(request: any, dataFromSheet: any[], createAndSearchConfig: any, requestBody: any, localizationMap?: { [key: string]: string }) {
    const processedData = await processData(request, dataFromSheet, createAndSearchConfig, localizationMap);
    return setTenantIdAndSegregate(processedData, createAndSearchConfig, requestBody);
}

function updateActivityResourceId(request: any) {
    if (request?.body?.Activities && Array.isArray(request?.body?.Activities)) {
        for (const activity of request?.body?.Activities) {
            activity.resourceDetailsId = request?.body?.ResourceDetails?.id
        }
    }
}

async function generateProcessedFileAndPersist(request: any, localizationMap?: { [key: string]: string }) {
    if (request.body.ResourceDetails.type == 'boundaryWithTarget') {
        await updateStatusFileForTargets(request, localizationMap);
    } else {
        if (request.body.ResourceDetails.type !== "boundary") {
            await updateStatusFile(request, localizationMap);
        }
    }
    updateActivityResourceId(request);
    request.body.ResourceDetails = {
        ...request?.body?.ResourceDetails,
        status: request.body.ResourceDetails.status != resourceDataStatuses.invalid ? resourceDataStatuses.completed : resourceDataStatuses.invalid,
        auditDetails: {
            ...request?.body?.ResourceDetails?.auditDetails,
            lastModifiedBy: request?.body?.RequestInfo?.userInfo?.uuid,
            lastModifiedTime: Date.now()
        },
        additionalDetails: { ...request?.body?.ResourceDetails?.additionalDetails, sheetErrors: request?.body?.additionalDetailsErrors } || {}
    };
    const persistMessage: any = { ResourceDetails: request.body.ResourceDetails }
    if (request?.body?.ResourceDetails?.action == "create") {
        persistMessage.ResourceDetails.additionalDetails = {}
    }
    await produceModifiedMessages(persistMessage, config?.kafka?.KAFKA_UPDATE_RESOURCE_DETAILS_TOPIC);
    logger.info(`ResourceDetails to persist : ${request.body.ResourceDetails.type}`);
    if (request?.body?.Activities && Array.isArray(request?.body?.Activities) && request?.body?.Activities.length > 0) {
        logger.info("Activities to persist : ")
        logger.debug(getFormattedStringForDebug(request?.body?.Activities));
        logger.info(`Waiting for 2 seconds`);
        await new Promise(resolve => setTimeout(resolve, 2000));
        const activityObject: any = { Activities: request?.body?.Activities };
        await produceModifiedMessages(activityObject, config.kafka.KAFKA_CREATE_RESOURCE_ACTIVITY_TOPIC);
    }
}

function getRootBoundaryCode(boundaries: any[] = []) {
    for (const boundary of boundaries) {
        if (boundary.isRoot) {
            return boundary.code;
        }
    }
    return "";
}

function enrichRootProjectId(requestBody: any) {
    var rootBoundary;
    for (const boundary of requestBody?.CampaignDetails?.boundaries) {
        if (boundary?.isRoot) {
            rootBoundary = boundary?.code
            break;
        }
    }
    if (rootBoundary) {
        requestBody.CampaignDetails.projectId = requestBody?.boundaryProjectMapping?.[rootBoundary]?.projectId || null
    }
    requestBody.CampaignDetails.projectId = requestBody.CampaignDetails.projectId || null
}

async function enrichAndPersistCampaignWithError(requestBody: any, error: any) {
    requestBody.CampaignDetails = requestBody?.CampaignDetails || {}
    const action = requestBody?.CampaignDetails?.action;
    requestBody.CampaignDetails.campaignNumber = requestBody?.CampaignDetails?.campaignNumber || null
    requestBody.CampaignDetails.campaignDetails = requestBody?.CampaignDetails?.campaignDetails || { deliveryRules: requestBody?.CampaignDetails?.deliveryRules, resources: requestBody?.CampaignDetails?.resources || [], boundaries: requestBody?.CampaignDetails?.boundaries || [] };
    requestBody.CampaignDetails.status = campaignStatuses?.failed;
    requestBody.CampaignDetails.boundaryCode = getRootBoundaryCode(requestBody?.CampaignDetails?.boundaries) || null
    requestBody.CampaignDetails.projectType = requestBody?.CampaignDetails?.projectType || null;
    requestBody.CampaignDetails.hierarchyType = requestBody?.CampaignDetails?.hierarchyType || null;
    requestBody.CampaignDetails.additionalDetails = requestBody?.CampaignDetails?.additionalDetails || {};
    requestBody.CampaignDetails.startDate = requestBody?.CampaignDetails?.startDate || null
    requestBody.CampaignDetails.endDate = requestBody?.CampaignDetails?.endDate || null
    requestBody.CampaignDetails.auditDetails = {
        createdBy: requestBody?.RequestInfo?.userInfo?.uuid,
        createdTime: Date.now(),
        lastModifiedBy: requestBody?.RequestInfo?.userInfo?.uuid,
        lastModifiedTime: Date.now(),
    }
    if (action == "create" && !requestBody?.CampaignDetails?.projectId) {
        enrichRootProjectId(requestBody);
    }
    else if (!requestBody?.CampaignDetails?.projectId) {
        requestBody.CampaignDetails.projectId = null
    }
    requestBody.CampaignDetails.additionalDetails = {
        ...requestBody?.CampaignDetails?.additionalDetails,
        error: String((error?.message + (error?.description ? ` : ${error?.description}` : '')) || error)
    }
    const topic = config?.kafka?.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC
    // wait for 2 seconds
    logger.info(`Waiting for 2 seconds to persist errors`);
    await new Promise(resolve => setTimeout(resolve, 2000));
    const produceMessage: any = { CampaignDetails: requestBody.CampaignDetails }
    await produceModifiedMessages(produceMessage, topic);
    await persistTrack(requestBody?.CampaignDetails?.id, processTrackTypes.error, processTrackStatuses.failed, { error: String((error?.message + (error?.description ? ` : ${error?.description}` : '')) || error) });
    delete requestBody.CampaignDetails.campaignDetails
}

async function enrichAndPersistCampaignForCreate(request: any, firstPersist: boolean = false) {
    const action = request?.body?.CampaignDetails?.action;
    if (firstPersist) {
        request.body.CampaignDetails.campaignNumber = await getCampaignNumber(request.body, "CMP-[cy:yyyy-MM-dd]-[SEQ_EG_CMP_ID]", "campaign.number", request?.body?.CampaignDetails?.tenantId);
    }
    request.body.CampaignDetails.campaignDetails = { deliveryRules: request?.body?.CampaignDetails?.deliveryRules || [], resources: request?.body?.CampaignDetails?.resources || [], boundaries: request?.body?.CampaignDetails?.boundaries || [] };
    request.body.CampaignDetails.status = action == "create" ? campaignStatuses.started : campaignStatuses.drafted;
    request.body.CampaignDetails.boundaryCode = getRootBoundaryCode(request.body.CampaignDetails.boundaries)
    request.body.CampaignDetails.projectType = request?.body?.CampaignDetails?.projectType || null;
    request.body.CampaignDetails.hierarchyType = request?.body?.CampaignDetails?.hierarchyType || null;
    request.body.CampaignDetails.additionalDetails = request?.body?.CampaignDetails?.additionalDetails || {};
    request.body.CampaignDetails.startDate = request?.body?.CampaignDetails?.startDate || null
    request.body.CampaignDetails.endDate = request?.body?.CampaignDetails?.endDate || null
    request.body.CampaignDetails.auditDetails = {
        createdBy: request?.body?.RequestInfo?.userInfo?.uuid,
        createdTime: Date.now(),
        lastModifiedBy: request?.body?.RequestInfo?.userInfo?.uuid,
        lastModifiedTime: Date.now(),
    }
    if (action == "create" && !request?.body?.CampaignDetails?.projectId && !firstPersist) {
        enrichRootProjectId(request.body);
    }
    else {
        request.body.CampaignDetails.projectId = null
    }
    const topic = firstPersist ? config?.kafka?.KAFKA_SAVE_PROJECT_CAMPAIGN_DETAILS_TOPIC : config?.kafka?.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC
    delete request.body.CampaignDetails.codesTargetMapping
    const produceMessage: any = {
        CampaignDetails: request?.body?.CampaignDetails
    };
    await produceModifiedMessages(produceMessage, topic);
    delete request.body.CampaignDetails.campaignDetails
}

function enrichInnerCampaignDetails(request: any, updatedInnerCampaignDetails: any) {
    updatedInnerCampaignDetails.resources = request?.body?.CampaignDetails?.resources || []
    updatedInnerCampaignDetails.deliveryRules = request?.body?.CampaignDetails?.deliveryRules || []
    updatedInnerCampaignDetails.boundaries = request?.body?.CampaignDetails?.boundaries || []
}


async function enrichAndPersistCampaignForUpdate(request: any, firstPersist: boolean = false) {
    const action = request?.body?.CampaignDetails?.action;
    const existingCampaignDetails = request?.body?.ExistingCampaignDetails;
    callGenerateIfBoundariesDiffer(request);
    if (existingCampaignDetails) {
        if (areBoundariesSame(existingCampaignDetails?.boundaries, request?.body?.CampaignDetails?.boundaries)) {
            updateTargetColumnsIfDeliveryConditionsDifferForSMC(request);
        }
    }
    const ExistingCampaignDetails = request?.body?.ExistingCampaignDetails;
    var updatedInnerCampaignDetails = {}
    enrichInnerCampaignDetails(request, updatedInnerCampaignDetails)
    request.body.CampaignDetails.campaignNumber = ExistingCampaignDetails?.campaignNumber
    request.body.CampaignDetails.campaignDetails = updatedInnerCampaignDetails
    request.body.CampaignDetails.status = action == "changeDates" ? request.body.CampaignDetails.status : (action == "create" ? campaignStatuses.started : campaignStatuses.drafted);
    const boundaryCode = !(request?.body?.CampaignDetails?.projectId) ? getRootBoundaryCode(request.body.CampaignDetails.boundaries) : (request?.body?.CampaignDetails?.boundaryCode || ExistingCampaignDetails?.boundaryCode)
    request.body.CampaignDetails.boundaryCode = boundaryCode
    request.body.CampaignDetails.startDate = request?.body?.CampaignDetails?.startDate || ExistingCampaignDetails?.startDate || null
    request.body.CampaignDetails.endDate = request?.body?.CampaignDetails?.endDate || ExistingCampaignDetails?.endDate || null
    request.body.CampaignDetails.projectType = request?.body?.CampaignDetails?.projectType ? request?.body?.CampaignDetails?.projectType : ExistingCampaignDetails?.projectType
    request.body.CampaignDetails.hierarchyType = request?.body?.CampaignDetails?.hierarchyType ? request?.body?.CampaignDetails?.hierarchyType : ExistingCampaignDetails?.hierarchyType
    request.body.CampaignDetails.additionalDetails = request?.body?.CampaignDetails?.additionalDetails ? request?.body?.CampaignDetails?.additionalDetails : ExistingCampaignDetails?.additionalDetails
    request.body.CampaignDetails.auditDetails = {
        createdBy: ExistingCampaignDetails?.createdBy,
        createdTime: ExistingCampaignDetails?.createdTime,
        lastModifiedBy: request?.body?.RequestInfo?.userInfo?.uuid,
        lastModifiedTime: Date.now(),
    }
    if (action == "create" && !request?.body?.CampaignDetails?.projectId) {
        enrichRootProjectId(request.body);
    }
    else {
        request.body.CampaignDetails.projectId = request?.body?.CampaignDetails?.projectId || ExistingCampaignDetails?.projectId || null
    }
    delete request.body.CampaignDetails.codesTargetMapping
    const producerMessage: any = {
        CampaignDetails: request?.body?.CampaignDetails
    }
    await produceModifiedMessages(producerMessage, config?.kafka?.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC);
    delete request.body.ExistingCampaignDetails
    delete request.body.CampaignDetails.campaignDetails
}

function getCreateResourceIds(resources: any[]) {
    return resources
        .filter((resource: any) => typeof resource.createResourceId === 'string' && resource.createResourceId.trim() !== '')
        .map((resource: any) => {
            const resourceId = resource.createResourceId;
            return resourceId;
        });
}

async function persistForCampaignProjectMapping(request: any, createResourceDetailsIds: any, localizationMap?: any) {
    if (createResourceDetailsIds && request?.body?.CampaignDetails?.projectId) {
        var requestBody: any = {
            RequestInfo: request?.body?.RequestInfo,
            Campaign: {}
        }
        requestBody.Campaign.id = request?.body?.CampaignDetails?.id
        requestBody.Campaign.hierarchyType = request?.body?.CampaignDetails?.hierarchyType
        requestBody.Campaign.tenantId = request?.body?.CampaignDetails?.tenantId
        requestBody.Campaign.campaignName = request?.body?.CampaignDetails?.campaignName
        requestBody.Campaign.boundaryCode = request?.body?.CampaignDetails?.boundaryCode
        requestBody.Campaign.startDate = request?.body?.CampaignDetails?.startDate
        requestBody.Campaign.endDate = request?.body?.CampaignDetails?.endDate
        requestBody.Campaign.projectType = request?.body?.CampaignDetails?.projectType
        requestBody.Campaign.additionalDetails = request?.body?.CampaignDetails?.additionalDetails
        requestBody.Campaign.deliveryRules = request?.body?.CampaignDetails?.deliveryRules
        requestBody.Campaign.rootProjectId = request?.body?.CampaignDetails?.projectId
        requestBody.Campaign.resourceDetailsIds = createResourceDetailsIds
        requestBody.CampaignDetails = request?.body?.CampaignDetails
        var updatedInnerCampaignDetails = {}
        enrichInnerCampaignDetails(request, updatedInnerCampaignDetails)
        requestBody.CampaignDetails = request?.body?.CampaignDetails
        requestBody.CampaignDetails.campaignDetails = updatedInnerCampaignDetails
        // requestBody.localizationMap = localizationMap
        logger.info("Persisting CampaignProjectMapping...");
        logger.debug(`CampaignProjectMapping: ${getFormattedStringForDebug(requestBody)}`);
        await produceModifiedMessages(requestBody, config?.kafka?.KAFKA_START_CAMPAIGN_MAPPING_TOPIC);
    }
}

function removeBoundariesFromRequest(request: any) {
    if (request?.body?.CampaignDetails?.boundaries && Array.isArray(request?.body?.CampaignDetails?.boundaries) && request?.body?.CampaignDetails?.boundaries?.length > 0) {
        request.body.CampaignDetails.boundaries = request?.body?.CampaignDetails?.boundaries?.filter((boundary: any) => !boundary?.insertedAfter)
    }
}

async function enrichAndPersistProjectCampaignForFirst(request: any, actionInUrl: any, firstPersist: boolean = false, localizationMap?: any) {
    removeBoundariesFromRequest(request);
    if (actionInUrl == "create") {
        await enrichAndPersistCampaignForCreate(request, firstPersist)
    }
    else if (actionInUrl == "update") {
        await enrichAndPersistCampaignForUpdate(request, firstPersist)
    }
    if (request?.body?.CampaignDetails?.action == "create") {
        await createProcessTracks(request.body.CampaignDetails.id)
    }
}


async function enrichAndPersistProjectCampaignRequest(request: any, actionInUrl: any, firstPersist: boolean = false, localizationMap?: any) {
    var createResourceDetailsIds: any[] = []
    if (request?.body?.CampaignDetails?.resources && Array.isArray(request?.body?.CampaignDetails?.resources) && request?.body?.CampaignDetails?.resources?.length > 0 && request?.body?.CampaignDetails?.action == "create") {
        createResourceDetailsIds = getCreateResourceIds(request?.body?.CampaignDetails?.resources);
    }
    removeBoundariesFromRequest(request);
    if (actionInUrl == "create") {
        await enrichAndPersistCampaignForCreate(request, firstPersist)
    }
    else if (actionInUrl == "update") {
        await enrichAndPersistCampaignForUpdate(request, firstPersist)
    }
    if (request?.body?.CampaignDetails?.action == "create") {
        await persistForCampaignProjectMapping(request, createResourceDetailsIds, localizationMap);
    }
}

function getChildParentMap(modifiedBoundaryData: any) {
    const childParentMap: Map<{ key: string, value: string }, { key: string, value: string } | null> = new Map();

    modifiedBoundaryData.forEach((row: any) => {
        for (let j = row.length - 1; j >= 0; j--) {
            const child = row[j];
            const parent = j - 1 >= 0 ? row[j - 1] : null;
            const childIdentifier = { key: child.key, value: child.value }; // Unique identifier for the child
            const parentIdentifier = parent ? { key: parent.key, value: parent.value } : null; // Unique identifier for the parent, set to null if parent doesn't exist


            // Check if the mapping already exists in the childParentMap
            const existingMapping = Array.from(childParentMap.entries()).find(([existingChild, existingParent]) =>
                _.isEqual(existingChild, childIdentifier) && _.isEqual(existingParent, parentIdentifier)
            );

            // If the mapping doesn't exist, add it to the childParentMap
            if (!existingMapping) {
                childParentMap.set(childIdentifier, parentIdentifier);
            }
        }
    });
    return childParentMap;
}






function getCodeMappingsOfExistingBoundaryCodes(withBoundaryCode: any[]) {
    const countMap = new Map<{ key: string, value: string }, number>();
    const mappingMap = new Map<{ key: string, value: string }, string>();

    withBoundaryCode.forEach((row: any[]) => {
        const len = row.length;
        if (len >= 3) {
            let grandParentFound = false;
            const grandParent = row[len - 3];
            if (findMapValue(mappingMap, grandParent)) {
                const countMapArray = Array.from(countMap.entries());
                for (const [key, value] of countMapArray) {
                    if (_.isEqual(key, grandParent)) {
                        countMap.set(key, value + 1);
                        grandParentFound = true;
                        break;
                    }
                }
                if (grandParentFound == false) {
                    countMap.set(grandParent, 1);
                }
            }
        }
        mappingMap.set(row[len - 2], row[len - 1].value);
    });
    return { mappingMap, countMap };
}


function addBoundaryCodeToData(withBoundaryCode: any[], withoutBoundaryCode: any[], boundaryMap: Map<any, any>) {
    const boundaryDataWithBoundaryCode = withBoundaryCode;
    const modifiedBoundaryDataWithBoundaryCode = boundaryDataWithBoundaryCode.map((array) => {
        return array.map((obj: any) => {
            if (obj.key === 'Boundary Code') {
                return obj.value;
            } else {
                return obj;
            }
        });
    });

    const boundaryDataForWithoutBoundaryCode = withoutBoundaryCode.map((row: any[]) => {
        const boundaryName = row[row.length - 1]; // Get the last element of the row
        const boundaryCode = findMapValue(boundaryMap, boundaryName); // Fetch corresponding boundary code from map
        return [...row, boundaryCode]; // Append boundary code to the row and return updated row
    });
    const boundaryDataForSheet = [...modifiedBoundaryDataWithBoundaryCode, ...boundaryDataForWithoutBoundaryCode];
    return boundaryDataForSheet;
}

function prepareDataForExcel(boundaryDataForSheet: any, hierarchy: any[], boundaryMap: any) {
    const data = boundaryDataForSheet.map((boundary: any[]) => {
        const boundaryCode = boundary.pop();
        const boundaryValues = boundary.map(obj => obj.value);
        const rowData = boundaryValues.concat(Array(Math.max(0, hierarchy.length - boundary.length)).fill(''));
        const boundaryCodeIndex = hierarchy.length;
        rowData[boundaryCodeIndex] = boundaryCode;
        return rowData;
    });
    return data;
}
function extractCodesFromBoundaryRelationshipResponse(boundaries: any[]): any {
    const codes = new Set();
    for (const boundary of boundaries) {
        codes.add(boundary.code); // Add code to the Set
        if (boundary.children && boundary.children.length > 0) {
            const childCodes = extractCodesFromBoundaryRelationshipResponse(boundary.children); // Recursively get child codes
            childCodes.forEach((code: any) => codes.add(code)); // Add child codes to the Set
        }
    }
    return codes;
}


async function getTotalCount(request: any) {
    const CampaignDetails = request.body.CampaignDetails;
    const { tenantId, pagination, ids, ...searchFields } = CampaignDetails;
    let conditions = [];
    let values = [tenantId];
    let index = 2;
    const campaignsIncludeDates = searchFields?.campaignsIncludeDates

    for (const field in searchFields) {
        if (searchFields[field] !== undefined && field != 'campaignsIncludeDates') {
            if (field === 'startDate') {
                const startDateSign = campaignsIncludeDates ? '<=' : '>=';
                conditions.push(`startDate ${startDateSign} $${index}`);
                values.push(searchFields[field]);
                index++;
            } else if (field === 'endDate') {
                const endDateSign = campaignsIncludeDates ? '>=' : '<=';
                conditions.push(`endDate ${endDateSign} $${index}`);
                values.push(searchFields[field]);
                index++;
            } else if (field === 'campaignName') {
                conditions.push(`${field} ILIKE '%' || $${index} || '%'`);
                values.push(searchFields[field]);
                index++;
            } else if (field != 'status') {
                conditions.push(`${field} = $${index}`);
                values.push(searchFields[field]);
                index++;
            }
        }
    }

    let query = `
        SELECT count(*)
        FROM ${config?.DB_CONFIG.DB_CAMPAIGN_DETAILS_TABLE_NAME}
        WHERE tenantId = $1
    `;

    if (ids && ids.length > 0) {
        const idParams = ids.map((id: any, i: any) => `$${index + i}`);
        query += ` AND id IN (${idParams.join(', ')})`;
        values.push(...ids);
        index = index + ids.length;
    }
    var status = searchFields?.status;
    if (status) {
        if (typeof status === 'string') {
            status = [status]; // Convert string to array
        }
        const statusParams = status.map((param: any, i: any) => `$${index + i}`); // Increment index for each parameter
        query += ` AND status IN (${statusParams.join(', ')})`;
        values.push(...status);
    }

    if (conditions.length > 0) {
        query += ` AND ${conditions.join(' AND ')}`;
    }
    const queryResult = await executeQuery(query, values);
    const totalCount = parseInt(queryResult.rows[0].count, 10);
    request.body.totalCount = totalCount;
}




async function searchProjectCampaignResourcData(request: any) {
    const CampaignDetails = request.body.CampaignDetails;
    const { tenantId, pagination, ids, ...searchFields } = CampaignDetails;
    const queryData = buildSearchQuery(tenantId, pagination, ids, searchFields);
    await getTotalCount(request)
    const responseData: any[] = await executeSearchQuery(queryData.query, queryData.values);
    // TODO @ashish check the below code looks like duplicate
    for (const data of responseData) {
        data.resources = data?.campaignDetails?.resources
        data.boundaries = data?.campaignDetails?.boundaries
        data.deliveryRules = data?.campaignDetails?.deliveryRules;
        delete data.campaignDetails;
        data.auditDetails = {
            createdBy: data?.createdBy,
            lastModifiedBy: data?.lastModifiedBy,
            createdTime: data?.createdTime,
            lastModifiedTime: data?.lastModifiedTime
        }
        delete data.createdBy;
        delete data.lastModifiedBy;
        delete data.createdTime;
        delete data.lastModifiedTime;
    }
    request.body.CampaignDetails = responseData;
}

function buildSearchQuery(tenantId: string, pagination: any, ids: string[], searchFields: any): { query: string, values: any[] } {
    let conditions = [];
    let values = [tenantId];
    let index = 2;
    const campaignsIncludeDates = searchFields?.campaignsIncludeDates

    for (const field in searchFields) {
        if (searchFields[field] !== undefined && field != 'campaignsIncludeDates') {
            if (field === 'startDate') {
                const startDateSign = campaignsIncludeDates ? '<=' : '>=';
                conditions.push(`startDate ${startDateSign} $${index}`);
                values.push(searchFields[field]);
                index++;
            } else if (field === 'endDate') {
                const endDateSign = campaignsIncludeDates ? '>=' : '<=';
                conditions.push(`endDate ${endDateSign} $${index}`);
                values.push(searchFields[field]);
                index++;
            } else if (field === 'campaignName') {
                conditions.push(`${field} ILIKE '%' || $${index} || '%'`);
                values.push(searchFields[field]);
                index++;
            } else if (field != 'status') {
                conditions.push(`${field} = $${index}`);
                values.push(searchFields[field]);
                index++;
            }
        }
    }

    let query = `
        SELECT *
        FROM ${config?.DB_CONFIG.DB_CAMPAIGN_DETAILS_TABLE_NAME}
        WHERE tenantId = $1
    `;

    if (ids && ids.length > 0) {
        const idParams = ids.map((id: any, i: any) => `$${index + i}`);
        query += ` AND id IN (${idParams.join(', ')})`;
        values.push(...ids);
        index = index + ids.length;
    }

    var status = searchFields?.status;
    if (status) {
        if (typeof status === 'string') {
            status = [status]; // Convert string to array
        }
        const statusParams = status.map((param: any, i: any) => `$${index + i}`); // Increment index for each parameter
        query += ` AND status IN (${statusParams.join(', ')})`;
        values.push(...status);
    }

    if (conditions.length > 0) {
        query += ` AND ${conditions.join(' AND ')}`;
    }

    if (pagination) {
        query += '\n';

        if (pagination.sortBy) {
            query += `ORDER BY ${pagination.sortBy}`;
            if (pagination.sortOrder) {
                query += ` ${pagination.sortOrder.toUpperCase()}`;
            }
            query += '\n';
        }

        if (pagination.limit !== undefined) {
            query += `LIMIT ${pagination.limit}`;
            if (pagination.offset !== undefined) {
                query += ` OFFSET ${pagination.offset}`;
            }
            query += '\n';
        }
    }

    return { query, values };
}



async function executeSearchQuery(query: string, values: any[]) {
    const queryResult = await executeQuery(query, values);
    return campaignDetailsTransformer(queryResult?.rows);
}

async function processDataSearchRequest(request: any) {
    const { SearchCriteria } = request.body;
    const query = buildWhereClauseForDataSearch(SearchCriteria);
    const queryResult = await executeQuery(query.query, query.values);
    request.body.ResourceDetails = genericResourceTransformer(queryResult?.rows);;
}

function buildWhereClauseForDataSearch(SearchCriteria: any): { query: string; values: any[] } {
    const { id, tenantId, type, status } = SearchCriteria;
    let conditions = [];
    let values = [];

    if (id && id.length > 0) {
        conditions.push(`id = ANY($${values.length + 1})`);
        values.push(id);
    }

    if (tenantId) {
        conditions.push(`tenantId = $${values.length + 1}`);
        values.push(tenantId);
    }

    if (type) {
        conditions.push(`type = $${values.length + 1}`);
        values.push(type);
    }

    if (status) {
        conditions.push(`status = $${values.length + 1}`);
        values.push(status);
    }

    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

    return {
        query: `
    SELECT *
    FROM ${config?.DB_CONFIG.DB_RESOURCE_DETAILS_TABLE_NAME}
    ${whereClause};`, values
    };
}

function mapBoundariesParent(boundaryResponse: any, request: any, parent: any) {
    if (!boundaryResponse) return;
    request.body.boundaryProjectMapping[boundaryResponse.code] = {
        parent: parent || null,
        projectId: null
    }
    if (boundaryResponse?.children && Array.isArray(boundaryResponse?.children) && boundaryResponse?.children?.length > 0) {
        for (const child of boundaryResponse.children) {
            mapBoundariesParent(child, request, boundaryResponse.code);
        }
    }
}

function mapTargets(boundaryResponses: any, codesTargetMapping: any) {
    if (!boundaryResponses || !codesTargetMapping) return;

    for (const boundaryResponse of boundaryResponses) {
        const mapBoundary = (boundary: any) => {
            if (!boundary.children || boundary.children.length === 0) {
                const targetValue = codesTargetMapping[boundary.code];
                return targetValue ? targetValue : 0;
            }

            let totalTargetValue = 0;
            for (const child of boundary.children) {
                const childTargetValue = mapBoundary(child);
                totalTargetValue += childTargetValue;
            }
            codesTargetMapping[boundary.code] = totalTargetValue;
            return totalTargetValue;
        };
        mapBoundary(boundaryResponse);
    }
}


async function processBoundary(boundaryResponse: any, boundaries: any, includeAllChildren: any, boundaryCodes: any, boundaryChildren: any) {
    if (!boundaryResponse) return;
    if (!boundaryCodes.has(boundaryResponse.code)) {
        boundaries.push({ code: boundaryResponse?.code, type: boundaryResponse?.boundaryType, insertedAfter: true });
        boundaryCodes.add(boundaryResponse?.code);
    }
    if (includeAllChildren && boundaryResponse?.children && Array.isArray(boundaryResponse?.children) && boundaryResponse?.children?.length > 0) {
        for (const child of boundaryResponse.children) {
            processBoundary(child, boundaries, true, boundaryCodes, boundaryChildren);
        }
    }
    else if (boundaryResponse?.children && Array.isArray(boundaryResponse?.children) && boundaryResponse?.children?.length > 0) {
        for (const child of boundaryResponse.children) {
            if (boundaryCodes.has(child.code) && boundaryChildren[child.code]) {
                processBoundary(child, boundaries, true, boundaryCodes, boundaryChildren);
            }
            else if (boundaryCodes.has(child.code)) {
                processBoundary(child, boundaries, false, boundaryCodes, boundaryChildren);
            }
        }
    }
}

async function addBoundaries(request: any, boundaryResponse: any, boundaryChildren: any) {
    var { boundaries } = request?.body?.CampaignDetails;
    var boundaryCodes = new Set(boundaries.map((boundary: any) => boundary.code));
    await processBoundary(boundaryResponse, boundaries, boundaryChildren[boundaryResponse?.code], boundaryCodes, boundaryChildren);
    request.body.CampaignDetails.boundaries = boundaries
}

async function addBoundariesForData(request: any, CampaignDetails: any) {
    var { boundaries } = CampaignDetails;
    const rootBoundary = getRootBoundaryCode(boundaries)
    if (rootBoundary) {
        const params = {
            tenantId: request?.body?.ResourceDetails?.tenantId,
            codes: rootBoundary,
            hierarchyType: request?.body?.ResourceDetails?.hierarchyType,
            includeChildren: true
        }
        const header = {
            ...defaultheader,
            cachekey: `boundaryRelationShipSearch${params?.hierarchyType}${params?.tenantId}${params.codes || ''}${params?.includeChildren || ''}`,
        }
        const boundaryResponse = await httpRequest(config.host.boundaryHost + config.paths.boundaryRelationship, request.body, params, undefined, undefined, header);
        if (boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0]) {
            var boundaryChildren = boundaries.reduce((acc: any, boundary: any) => {
                acc[boundary.code] = boundary?.includeAllChildren;
                return acc;
            }, {});
            var boundaryCodes = new Set(boundaries.map((boundary: any) => boundary.code));
            await processBoundary(boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0], boundaries, boundaryChildren[boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0]?.code], boundaryCodes, boundaryChildren);
            CampaignDetails.boundaries = boundaries
        }
        else {
            throwError("COMMON", 500, "INTERNAL_SERVER_ERROR", "Some internal server error occured during boundary validation.");
        }
    }
    else {
        throwError("COMMON", 500, "INTERNAL_SERVER_ERROR", "There is no root boundary for this campaign.");
    }
}

function reorderBoundariesWithParentFirst(reorderedBoundaries: any[], boundaryProjectMapping: any) {
    // Function to get the index of a boundary in the original boundaries array
    function getIndex(code: any, boundaries: any[]) {
        return reorderedBoundaries.findIndex((boundary: any) => boundary.code === code);
    }
    // Reorder boundaries so that parents come first
    for (let i = 0; i < 2 * (reorderedBoundaries?.length); i++) {
        for (const boundary of reorderedBoundaries) {
            const parentCode = boundaryProjectMapping[boundary.code]?.parent;
            if (parentCode) {
                const parentIndex = getIndex(parentCode, reorderedBoundaries);
                const boundaryIndex = getIndex(boundary.code, reorderedBoundaries);

                if (parentIndex !== -1 && boundaryIndex !== -1 && parentIndex > boundaryIndex) {
                    reorderedBoundaries.splice(parentIndex + 1, 0, reorderedBoundaries.splice(boundaryIndex, 1)[0]);
                    break;
                }
            }
        }
    }
}

async function reorderBoundariesOfDataAndValidate(request: any, localizationMap?: any) {
    if (request?.body?.ResourceDetails?.campaignId) {
        const searchBody = {
            RequestInfo: request?.body?.RequestInfo,
            CampaignDetails: {
                ids: [request?.body?.ResourceDetails?.campaignId],
                tenantId: request?.body?.ResourceDetails?.tenantId
            }
        }
        const req: any = replicateRequest(request, searchBody)
        const response = await searchProjectTypeCampaignService(req)
        if (response?.CampaignDetails?.[0]) {
            const CampaignDetails = response?.CampaignDetails?.[0]
            await addBoundariesForData(request, CampaignDetails)
            logger.debug("Boundaries after addition " + getFormattedStringForDebug(CampaignDetails?.boundaries));
            await validateBoundaryOfResouces(CampaignDetails, request, localizationMap)
        }
        else {
            throwError("CAMPAIGN", 400, "CAMPAIGN_NOT_FOUND", "Campaign not found while Validating sheet boundaries");
        }
    }
}

async function reorderBoundaries(request: any, localizationMap?: any) {
    var { boundaries } = request?.body?.CampaignDetails;
    const rootBoundary = getRootBoundaryCode(boundaries)
    request.body.boundaryProjectMapping = {}
    if (rootBoundary) {
        const params = {
            tenantId: request?.body?.CampaignDetails?.tenantId,
            codes: rootBoundary,
            hierarchyType: request?.body?.CampaignDetails?.hierarchyType,
            includeChildren: true
        }
        const header = {
            ...defaultheader,
            cachekey: `boundaryRelationShipSearch${params?.hierarchyType}${params?.tenantId}${params.codes || ''}${params?.includeChildren || ''}`,
        }
        const boundaryResponse = await httpRequest(config.host.boundaryHost + config.paths.boundaryRelationship, request.body, params, undefined, undefined, header);
        if (boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0]) {
            const codesTargetMapping = await getCodesTarget(request, localizationMap)
            mapTargets(boundaryResponse?.TenantBoundary?.[0]?.boundary, codesTargetMapping)
            request.body.CampaignDetails.codesTargetMapping = codesTargetMapping
            logger.debug("codesTargetMapping mapping :: " + getFormattedStringForDebug(codesTargetMapping));
            mapBoundariesParent(boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0], request, null)
            var boundaryChildren = boundaries.reduce((acc: any, boundary: any) => {
                acc[boundary.code] = boundary?.includeAllChildren;
                return acc;
            }, {});
            await addBoundaries(request, boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0], boundaryChildren)
        }
        else {
            throwError("COMMON", 500, "INTERNAL_SERVER_ERROR", "Some internal server error occured during boundary validation.");
        }
    }
    else {
        throwError("COMMON", 500, "INTERNAL_SERVER_ERROR", "There is no root boundary for this campaign.");
    }
    logger.info("Boundaries for campaign creation in received")
    logger.debug("Boundaries after addition " + getFormattedStringForDebug(request?.body?.CampaignDetails?.boundaries));
    reorderBoundariesWithParentFirst(request?.body?.CampaignDetails?.boundaries, request?.body?.boundaryProjectMapping)
    logger.info("Reordered the Boundaries for mapping");
    logger.debug("Reordered Boundaries " + getFormattedStringForDebug(request?.body?.CampaignDetails?.boundaries));
}

function convertToProjectsArray(Projects: any, currentArray: any = []) {
    for (const project of Projects) {
        const descendants = project?.descendants
        delete project?.descendants
        currentArray.push(project);
        if (descendants && Array.isArray(descendants) && descendants?.length > 0) {
            convertToProjectsArray(descendants, currentArray)
        }
    }
    return currentArray;
}

async function getRelatedProjects(request: any) {
    const { projectId, tenantId } = request?.body?.CampaignDetails;
    const projectSearchBody = {
        RequestInfo: request?.body?.RequestInfo,
        Projects: [
            {
                id: projectId,
                tenantId: tenantId
            }
        ]
    }
    const projectSearchParams = {
        tenantId: tenantId,
        offset: 0,
        limit: 1,
        includeDescendants: true
    }
    logger.info("Project search params " + JSON.stringify(projectSearchParams))
    const projectSearchResponse = await httpRequest(config?.host?.projectHost + config?.paths?.projectSearch, projectSearchBody, projectSearchParams);
    if (projectSearchResponse?.Project && Array.isArray(projectSearchResponse?.Project) && projectSearchResponse?.Project?.length > 0) {
        return convertToProjectsArray(projectSearchResponse?.Project)
    }
    else {
        throwError("PROJECT", 500, "PROJECT_SEARCH_ERROR")
        return []
    }
}

async function updateProjectDates(request: any, actionInUrl: any) {
    const { startDate, endDate, projectId } = request?.body?.CampaignDetails
    if ((startDate || endDate) && projectId && actionInUrl == "update") {
        const projects = await getRelatedProjects(request);
        for (const project of projects) {
            project.startDate = startDate || project.startDate;
            project.endDate = endDate || project.endDate;
            delete project?.address;
        }
        logger.info("Projects related to current Campaign : " + JSON.stringify(projects));
        const projectUpdateBody = {
            RequestInfo: request?.body?.RequestInfo,
            Projects: projects
        }
        const projectUpdateResponse = await httpRequest(config?.host?.projectHost + config?.paths?.projectUpdate, projectUpdateBody);
        if (projectUpdateResponse?.Project && Array.isArray(projectUpdateResponse?.Project) && projectUpdateResponse?.Project?.length == projects?.length) {
            logger.info("Project dates updated successfully")
        }
        else {
            throwError("PROJECT", 500, "PROJECT_UPDATE_ERROR")
        }
    }
}

async function getCodesTarget(request: any, localizationMap?: any) {
    const { tenantId, resources } = request?.body?.CampaignDetails;
    const boundaryWithTargetResource = resources?.filter((resource: any) => resource?.type == "boundaryWithTarget");
    const fileId = boundaryWithTargetResource[0]?.filestoreId
    const fileResponse = await httpRequest(config.host.filestore + config.paths.filestore + "/url", {}, { tenantId: tenantId, fileStoreIds: fileId }, "get");
    if (!fileResponse?.fileStoreIds?.[0]?.url) {
        throwError("FILE", 500, "DOWNLOAD_URL_NOT_FOUND");
    }
    const codeColumnName = getLocalizedName(createAndSearch?.boundaryWithTarget?.boundaryValidation?.column, localizationMap)
    const targetData = await getTargetSheetDataAfterCode(fileResponse?.fileStoreIds?.[0]?.url, true, true, codeColumnName);
    const boundaryTargetMapping: any = {};
    // Iterate through each key in targetData
    for (const key in targetData) {
        // Iterate through each entry in the array under the current key
        targetData[key].forEach(entry => {
            // Check if the entry has both "Boundary Code" and "Target at the Selected Boundary level"
            if (entry[codeColumnName] !== undefined && entry['Target at the Selected Boundary level'] !== undefined) {
                // Add the mapping to the boundaryTargetMapping object
                boundaryTargetMapping[entry[codeColumnName]] = entry['Target at the Selected Boundary level'];
            }
        });
    }
    logger.info("Boundary target mapping count" + Object.keys(boundaryTargetMapping)?.length);
    return boundaryTargetMapping;
}

async function createProject(request: any, actionUrl: any, localizationMap?: any) {
    await persistTrack(request.body.CampaignDetails.id, processTrackTypes.targetAndDeliveryRulesCreation, processTrackStatuses.inprogress);
    try {
        logger.info("Create Projects started for the given Campaign")
        var { tenantId, boundaries, projectType, projectId } = request?.body?.CampaignDetails;
        if (boundaries && projectType && !projectId) {
            const projectTypeResponse = await getMDMSV1Data({}, 'HCM-PROJECT-TYPES', "projectTypes", tenantId);
            var Projects: any = enrichProjectDetailsFromCampaignDetails(request?.body?.CampaignDetails, projectTypeResponse?.filter((types: any) => types?.code == projectType)?.[0]);
            const projectCreateBody = {
                RequestInfo: request?.body?.RequestInfo,
                Projects
            }
            await reorderBoundaries(request, localizationMap)
            boundaries = request?.body?.CampaignDetails?.boundaries;
            for (const boundary of boundaries) {
                Projects[0].address = { tenantId: tenantId, boundary: boundary?.code, boundaryType: boundary?.type }
                if (request?.body?.boundaryProjectMapping?.[boundary?.code]?.parent) {
                    const parent = request?.body?.boundaryProjectMapping?.[boundary?.code]?.parent
                    await confirmProjectParentCreation(request, request?.body?.boundaryProjectMapping?.[parent]?.projectId)
                    Projects[0].parent = request?.body?.boundaryProjectMapping?.[parent]?.projectId
                }
                else {
                    Projects[0].parent = null
                }
                Projects[0].referenceID = request?.body?.CampaignDetails?.id
                Projects[0].targets = [
                    {
                        beneficiaryType: request?.body?.CampaignDetails?.additionalDetails?.beneficiaryType,
                        totalNo: request?.body?.CampaignDetails?.codesTargetMapping[boundary?.code],
                        targetNo: request?.body?.CampaignDetails?.codesTargetMapping[boundary?.code]
                    }
                ]
                await projectCreate(projectCreateBody, request)
            }
        }
    } catch (error: any) {
        console.log(error)
        await persistTrack(request?.body?.CampaignDetails?.id, processTrackTypes.targetAndDeliveryRulesCreation, processTrackStatuses.failed, { error: String((error?.message + (error?.description ? ` : ${error?.description}` : '')) || error) });
        throw new Error(error)
    }
    await persistTrack(request?.body?.CampaignDetails?.id, processTrackTypes.targetAndDeliveryRulesCreation, processTrackStatuses.completed);
}


async function processAfterPersist(request: any, actionInUrl: any) {
    try {
        const localizationMap = await getLocalizedMessagesHandler(request, request?.body?.CampaignDetails?.tenantId);
        if (request?.body?.CampaignDetails?.action == "create") {
            await persistTrack(request.body.CampaignDetails.id, processTrackTypes.validation, processTrackStatuses.completed);
            await createProjectCampaignResourcData(request);
            await createProject(request, actionInUrl, localizationMap)
            await enrichAndPersistProjectCampaignRequest(request, actionInUrl, false, localizationMap)
        }
        else {
            await updateProjectDates(request, actionInUrl);
            await enrichAndPersistProjectCampaignRequest(request, actionInUrl, false, localizationMap)
        }
    } catch (error: any) {
        console.log(error)
        logger.error(error)
        await enrichAndPersistCampaignWithError(request?.body, error)
    }
}

async function processBasedOnAction(request: any, actionInUrl: any) {
    if (actionInUrl == "create") {
        request.body.CampaignDetails.id = uuidv4()
    }
    await enrichAndPersistProjectCampaignForFirst(request, actionInUrl, true)
    processAfterPersist(request, actionInUrl)
}


async function getLocalizedHierarchy(request: any, localizationMap: any) {
    var hierarchy = await getHierarchy(request, request?.query?.tenantId, request?.query?.hierarchyType);
    var modifiedHierarchy = hierarchy.map((ele) =>
        `${request?.query?.hierarchyType}_${ele}`.toUpperCase()
    );
    var resultHierarchy = getLocalizedHeaders(
        modifiedHierarchy,
        localizationMap
    );
    return resultHierarchy;
}


async function appendSheetsToWorkbook(request: any, boundaryData: any[], differentTabsBasedOnLevel: any, localizationMap?: any) {
    try {
        logger.info("Received Boundary data for generating  different tabs based on configured boundary level");
        const hierarchy: any[] = await getLocalizedHierarchy(request, localizationMap);
        const workbook = getNewExcelWorkbook();
        const type = request?.query?.type;
        const headingInSheet = headingMapping?.[type];
        const localisedHeading = getLocalizedName(headingInSheet, localizationMap);
        await createReadMeSheet(request, workbook, localisedHeading, localizationMap);
        const [mainSheetData, uniqueDistrictsForMainSheet, districtLevelRowBoundaryCodeMap] = createBoundaryDataMainSheet(request, boundaryData, differentTabsBasedOnLevel, hierarchy, localizationMap)
        const responseFromCampaignSearch = await getCampaignSearchResponse(request);
        const campaignObject = responseFromCampaignSearch?.CampaignDetails?.[0];
        const isSourceMicroplan = checkIfSourceIsMicroplan(campaignObject);
        if (!(isSourceMicroplan)) {
            const mainSheet = workbook.addWorksheet(getLocalizedName(getBoundaryTabName(), localizationMap));
            const columnWidths = Array(12).fill(30);
            mainSheet.columns = columnWidths.map(width => ({ width }));
            // mainSheetData.forEach(row => mainSheet.addRow(row));
            addDataToSheet(mainSheet, mainSheetData, 'F3842D', 30, false, true);
            mainSheet.state = 'hidden';
        }
        logger.info("appending different districts tab in the sheet started")
        await appendDistricts(request, workbook, uniqueDistrictsForMainSheet, differentTabsBasedOnLevel, boundaryData, localizationMap, districtLevelRowBoundaryCodeMap, hierarchy, campaignObject);
        logger.info("Sheet with different tabs generated successfully");
        return workbook;
    } catch (error) {
        console.log(error);
        throw Error("An error occurred while creating tabs based on district:");
    }
}


async function appendDistricts(request: any, workbook: any, uniqueDistrictsForMainSheet: any, differentTabsBasedOnLevel: any, boundaryData: any, localizationMap: any, districtLevelRowBoundaryCodeMap: any, hierarchy: any, campaignObject: any) {
    const configurableColumnHeadersFromSchemaForTargetSheet = await getConfigurableColumnHeadersFromSchemaForTargetSheet(request, hierarchy, boundaryData, differentTabsBasedOnLevel, campaignObject, localizationMap);
    for (const uniqueData of uniqueDistrictsForMainSheet) {
        const uniqueDataFromLevelForDifferentTabs = uniqueData.slice(uniqueData.lastIndexOf('#') + 1);
        logger.info(`generating the boundary data for ${uniqueDataFromLevelForDifferentTabs} - ${differentTabsBasedOnLevel}`)
        const districtDataFiltered = boundaryData.filter((boundary: any) => boundary[differentTabsBasedOnLevel] === uniqueDataFromLevelForDifferentTabs && boundary[hierarchy[hierarchy.length - 1]]);
        const modifiedFilteredData = modifyFilteredData(districtDataFiltered, districtLevelRowBoundaryCodeMap.get(uniqueData), localizationMap);
        if (modifiedFilteredData?.[0]) {
            const newSheetData = [configurableColumnHeadersFromSchemaForTargetSheet];
            for (const data of modifiedFilteredData) {
                var rowData: any[] = [];
                for (const header of configurableColumnHeadersFromSchemaForTargetSheet) {
                    rowData.push(data[header] || '');
                }
                newSheetData.push(rowData);
            }
            await createNewSheet(request, workbook, newSheetData, uniqueData, localizationMap, districtLevelRowBoundaryCodeMap, configurableColumnHeadersFromSchemaForTargetSheet, campaignObject);
            logger.info(`${uniqueDataFromLevelForDifferentTabs} - ${differentTabsBasedOnLevel} boundary data generation completed`)
        }
    }
}

async function createNewSheet(request: any, workbook: any, newSheetData: any, uniqueData: any, localizationMap: any, districtLevelRowBoundaryCodeMap: any, localizedHeaders: any, campaignObject: any) {
    const newSheet = workbook.addWorksheet(getLocalizedName(districtLevelRowBoundaryCodeMap.get(uniqueData), localizationMap));
    addDataToSheet(newSheet, newSheetData, 'F3842D', 40);
    let columnsNotToBeFreezed: any;
    const boundaryCodeColumnIndex = localizedHeaders.findIndex((header: any) => header === getLocalizedName(config?.boundary?.boundaryCode, localizationMap));
    if (isDynamicTargetTemplateForProjectType(campaignObject?.projectType) && campaignObject.deliveryRules && campaignObject.deliveryRules.length > 0) {
        columnsNotToBeFreezed = localizedHeaders.slice(boundaryCodeColumnIndex + 1);
    }
    else {
        const mdmsResponse = await getMdmsDataBasedOnCampaignType(request, localizationMap)
        columnsNotToBeFreezed = mdmsResponse?.columnsNotToBeFreezed;
    }
    const localizedColumnsNotToBeFreezed = getLocalizedHeaders(columnsNotToBeFreezed, localizationMap);
    lockTargetFields(newSheet, localizedColumnsNotToBeFreezed, boundaryCodeColumnIndex);
}





function modifyFilteredData(districtDataFiltered: any, targetBoundaryCode: any, localizationMap?: any): any {

    // Step 2: Slice the boundary code up to the last underscore
    const slicedBoundaryCode = targetBoundaryCode.slice(0, targetBoundaryCode.lastIndexOf('_') + 1);

    // Step 3: Filter the rows that contain the sliced boundary code
    const modifiedFilteredData = districtDataFiltered.filter((row: any, index: any) => {
        // Extract the boundary code from the current row
        const localizedBoundaryCode = getLocalizedName(getBoundaryColumnName(), localizationMap);
        const boundaryCode = row[localizedBoundaryCode];
        // Check if the boundary code starts with the sliced boundary code
        return boundaryCode.startsWith(slicedBoundaryCode);
    });
    // Step 4: Return the modified filtered data
    return modifiedFilteredData;
}

async function generateFilteredBoundaryData(request: any, FiltersFromCampaignId: any) {
    const rootBoundary: any = (FiltersFromCampaignId?.Filters?.boundaries).filter((boundary: any) => boundary.isRoot);
    const params = {
        ...request?.query,
        includeChildren: true,
        codes: rootBoundary?.[0]?.code
    };
    const boundaryDataFromRootOnwards = await getBoundaryRelationshipData(request, params);
    logger.info(`filtering the boundaries`);
    const filteredBoundaryList = filterBoundaries(boundaryDataFromRootOnwards, FiltersFromCampaignId?.Filters)
    logger.info(`filtered the boundaries based on given criteria`)
    return filteredBoundaryList;
}

function filterBoundaries(boundaryData: any[], filters: any): any {
    function filterRecursive(boundary: any): any {
        const boundaryFilters = filters && filters.boundaries; // Accessing boundaries array from filters object
        const filter = boundaryFilters?.find((f: any) => f.code === boundary.code && f.boundaryType === boundary.boundaryType);

        if (!filter) {
            return {
                ...boundary,
                children: boundary.children.map(filterRecursive)
            };
        }

        if (!boundary.children.length) {
            if (!filter.includeAllChildren) {
                // throwError("COMMON", 400, "VALIDATION_ERROR", "Boundary cannot have includeAllChildren filter false if it does not have any children");
                logger.error("Boundary cannot have includeAllChildren filter false if it does not have any children");
            }
            // If boundary has no children and includeAllChildren is true, return as is
            return {
                ...boundary,
                children: []
            };
        }

        if (filter.includeAllChildren) {
            // If includeAllChildren is true, return boundary with all children
            return {
                ...boundary,
                children: boundary.children.map(filterRecursive)
            };
        }

        const filteredChildren: any[] = [];
        boundary.children.forEach((child: any) => {
            const matchingFilter = boundaryFilters.find((f: any) => f.code === child.code && f.boundaryType === child.boundaryType);
            if (matchingFilter) {
                filteredChildren.push(filterRecursive(child));
            }
        });
        return {
            ...boundary,
            children: filteredChildren
        };
    }
    const filteredData = boundaryData.map(filterRecursive);
    return filteredData;
}


function generateHierarchy(boundaries: any[]) {
    // Create an object to store boundary types and their parents
    const parentMap: any = {};

    // Populate the object with boundary types and their parents
    for (const boundary of boundaries) {
        parentMap[boundary.boundaryType] = boundary.parentBoundaryType;
    }

    // Traverse the hierarchy to generate the hierarchy list
    const hierarchyList = [];
    for (const boundaryType in parentMap) {
        if (Object.prototype.hasOwnProperty.call(parentMap, boundaryType)) {
            const parentBoundaryType = parentMap[boundaryType];
            if (parentBoundaryType === null) {
                // This boundary type has no parent, add it to the hierarchy list
                hierarchyList.push(boundaryType);
                // Traverse its children recursively
                traverseChildren(boundaryType, parentMap, hierarchyList);
            }
        }
    }
    return hierarchyList;
}

function traverseChildren(parent: any, parentMap: any, hierarchyList: any[]) {
    for (const boundaryType in parentMap) {
        if (Object.prototype.hasOwnProperty.call(parentMap, boundaryType)) {
            const parentBoundaryType = parentMap[boundaryType];
            if (parentBoundaryType === parent) {
                // This boundary type has the current parent, add it to the hierarchy list
                hierarchyList.push(boundaryType);
                // Traverse its children recursively
                traverseChildren(boundaryType, parentMap, hierarchyList);
            }
        }
    }
}

function createBoundaryMap(boundaries: any[], boundaryMap: Map<string, string>): void {
    for (const boundary of boundaries) {
        boundaryMap.set(boundary.code, boundary.boundaryType);
        if (boundary.children.length > 0) {
            createBoundaryMap(boundary.children, boundaryMap);
        }
    }
}

async function boundaryBulkUpload(request: any, localizationMap?: any) {
    try {
        logger.info("Boundary Relationship Creation Starts");
        await autoGenerateBoundaryCodes(request, localizationMap);
        await generateProcessedFileAndPersist(request);
    }
    catch (error: any) {
        console.log(error)
        await handleResouceDetailsError(request, error)
    }
}

const autoGenerateBoundaryCodes = async (request: any, localizationMap?: any) => {
    const { hierarchyType, tenantId } = request?.body?.ResourceDetails || {};
    const fileResponse = await httpRequest(config.host.filestore + config.paths.filestore + "/url", {}, { tenantId, fileStoreIds: request?.body?.ResourceDetails?.fileStoreId }, "get");
    const localizedBoundaryTab = getLocalizedName(getBoundaryTabName(), localizationMap);
    const boundaryData = await getSheetData(fileResponse?.fileStoreIds?.[0]?.url, localizedBoundaryTab, false, undefined, localizationMap);
    const updatedBoundaryData = updateBoundaryData(boundaryData);
    const hierarchy = await getHierarchy(request, tenantId, hierarchyType) || [];
    const modifiedBoundaryData = modifyBoundaryDataHeaders(updatedBoundaryData, hierarchy, localizationMap);
    const [withBoundaryCode, withoutBoundaryCode] = modifyBoundaryData(modifiedBoundaryData, localizationMap);
    const { mappingMap, countMap } = getCodeMappingsOfExistingBoundaryCodes(withBoundaryCode);
    const childParentMap = getChildParentMap([...withBoundaryCode, ...withoutBoundaryCode]);
    const boundaryMap = await getAutoGeneratedBoundaryCodesHandler(withoutBoundaryCode, childParentMap, mappingMap, countMap, request);
    logger.info("Boundary Code Auto Generation Completed");
    await createBoundaryEntities(request, boundaryMap);
    logger.info("waiting for 2 secs to persist the boundary entities before creating boundary relationship")
    await new Promise(resolve => setTimeout(resolve, 2000));
    const modifiedChildParentMap = modifyChildParentMap(childParentMap, boundaryMap);
    await createBoundaryRelationship(request, boundaryMap, modifiedChildParentMap);
    const boundaryDataForSheet = addBoundaryCodeToData(withBoundaryCode, withoutBoundaryCode, boundaryMap);
    logger.info("Initiated the localisation message creation for the uploaded boundary");
    transformAndCreateLocalisation(boundaryMap, request);
    const modifiedHierarchy = hierarchy.map(ele => `${hierarchyType}_${ele}`.toUpperCase())
    const headers = [...modifiedHierarchy, config?.boundary?.boundaryCode];
    const data = prepareDataForExcel(boundaryDataForSheet, hierarchy, boundaryMap);
    const localizedHeaders = getLocalizedHeaders(headers, localizationMap);
    const boundarySheetData: any = await createExcelSheet(data, localizedHeaders);
    const workbook = getNewExcelWorkbook();
    const boundarySheet = workbook.addWorksheet(localizedBoundaryTab);
    addDataToSheet(boundarySheet, boundarySheetData);
    const boundaryFileDetails: any = await createAndUploadFile(workbook, request);
    request.body.ResourceDetails.processedFileStoreId = boundaryFileDetails?.[0]?.fileStoreId;
}



function updateBoundaryData(boundaryData: any[]): any[] {
    const map: Map<string, string> = new Map();
    const count: Map<string, number> = new Map();

    boundaryData.forEach((row) => {
        const keys = Object.keys(row);
        keys.forEach((key, index) => {
            if (index > 0) {
                const element = row[key];
                const previousKey = keys[index - 1];
                const previousElement = row[keys[index - 1]];
                const previousElementKey = `${previousKey}:${previousElement}`;
                const elementKey = `${key}:${element}`;

                if (!map.has(elementKey)) {
                    map.set(elementKey, previousElementKey);
                    count.set(elementKey, 1);
                } else {
                    const currentCount = count.get(elementKey)!;
                    if (map.get(elementKey) !== previousElementKey) {
                        map.set(elementKey, previousElementKey);
                        count.set(elementKey, currentCount + 1);
                    }
                    const uniqueCount = count.get(elementKey)!;
                    const uniqueElement = (uniqueCount > 1) ? `${element}-${(uniqueCount - 1).toString().padStart(2, '0')}` : `${element}`;
                    row[key] = uniqueElement;
                }
            }
        });
    });
    return boundaryData;
}

function modifyBoundaryDataHeaders(boundaryData: any[], hierarchy: any[], localizationMap?: any) {
    const updatedData = boundaryData.map((obj: any) => {
        const updatedObj: { [key: string]: string | undefined } = {}; // Updated object with modified keys

        let hierarchyIndex = 0; // Track the index of the hierarchy array

        for (const key in obj) {
            if (key != getLocalizedName(config?.boundary?.boundaryCode, localizationMap)) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    const hierarchyKey = hierarchy[hierarchyIndex]; // Get the key from the hierarchy array
                    updatedObj[hierarchyKey] = obj[key]; // Map the key to the updated object
                    hierarchyIndex++; // Move to the next key in the hierarchy array
                }
            }
            else {
                updatedObj[key] = obj[key];
            }
        }


        return updatedObj;
    });
    return updatedData;
}

function modifyChildParentMap(childParentMap: Map<any, any>, boundaryMap: Map<any, any>): Map<string, string | null> {
    const modifiedMap: Map<string, string | null> = new Map();

    // Iterate over each entry in childParentMap
    childParentMap.forEach((value, key) => {
        // Get the modified key and value from boundaryMap
        const modifiedKey = findMapValue(boundaryMap, key) || null;
        const modifiedValue = value ? findMapValue(boundaryMap, value) : null;

        // Set the modified key-value pair in modifiedMap
        modifiedMap.set(modifiedKey, modifiedValue);
    });

    return modifiedMap;
}


async function convertSheetToDifferentTabs(request: any, boundaryData: any, differentTabsBasedOnLevel: any, localizationMap?: any) {
    // create different tabs on the level of hierarchy we want to 
    const updatedWorkbook = await appendSheetsToWorkbook(request, boundaryData, differentTabsBasedOnLevel, localizationMap);
    // upload the excel and generate file store id
    const boundaryDetails = await createAndUploadFile(updatedWorkbook, request);
    return boundaryDetails;
}

async function getBoundaryDataAfterGeneration(result: any, request: any, localizationMap?: any) {
    const fileStoreId = result[0].fileStoreId;
    const fileResponse = await httpRequest(config.host.filestore + config.paths.filestore + "/url", {}, { tenantId: request?.query?.tenantId, fileStoreIds: fileStoreId }, "get");
    if (!fileResponse?.fileStoreIds?.[0]?.url) {
        throwError("FILE", 400, "INVALID_FILE");
    }
    const boundaryData = await getSheetData(fileResponse?.fileStoreIds?.[0]?.url, getBoundaryTabName(), false, undefined, localizationMap);
    return boundaryData;
}

function getLocalizedName(expectedName: string, localizationMap?: { [key: string]: string }) {
    if (!localizationMap || !(expectedName in localizationMap)) {
        return expectedName;
    }
    const localizedName = localizationMap[expectedName];
    return localizedName;
}

async function getTargetBoundariesRelatedToCampaignId(request: any, localizationMap?: any) {
    let CampaignDetails: any;
    if (request?.body?.ResourceDetails?.campaignId) {
        const searchBody = {
            RequestInfo: request?.body?.RequestInfo,
            CampaignDetails: {
                ids: [request?.body?.ResourceDetails?.campaignId],
                tenantId: request?.body?.ResourceDetails?.tenantId
            }
        }
        const req: any = replicateRequest(request, searchBody)
        const response = await searchProjectTypeCampaignService(req)
        if (response?.CampaignDetails?.[0]) {
            CampaignDetails = response?.CampaignDetails?.[0]
            await addBoundariesForData(request, CampaignDetails)
        }
        else {
            throwError("CAMPAIGN", 400, "CAMPAIGN_NOT_FOUND", "Campaign not found while Validating sheet boundaries");
        }
    }
    return CampaignDetails?.boundaries;
}


function getFiltersFromCampaignSearchResponse(responseFromCampaignSearch: any) {
    const boundaries = responseFromCampaignSearch?.CampaignDetails?.[0]?.boundaries?.map((ele: any) => ({ ...ele, boundaryType: ele?.type }));
    if (!boundaries) {
        logger.info(`no boundaries found so considering the complete hierarchy`);
        return { Filters: null };
    }
    logger.info(`boundaries found for filtering`);
    return { Filters: { boundaries: boundaries } }
};



const getConfigurableColumnHeadersBasedOnCampaignType = async (request: any, localizationMap?: any) => {
    try {
        const responseFromCampaignSearch = await getCampaignSearchResponse(request);
        const campaignObject = responseFromCampaignSearch?.CampaignDetails?.[0];
        let campaignType = campaignObject?.projectType;
        const isSourceMicroplan = checkIfSourceIsMicroplan(campaignObject);
        campaignType = (isSourceMicroplan) ? `${config?.prefixForMicroplanCampaigns}-${campaignType}` : campaignType;
        const mdmsResponse = await callMdmsTypeSchema(request, request?.query?.tenantId || request?.body?.ResourceDetails?.tenantId, request?.query?.type || request?.body?.ResourceDetails?.type, campaignType)
        if (!mdmsResponse || mdmsResponse?.columns.length === 0) {
            logger.error(`Campaign Type ${campaignType} has not any columns configured in schema`)
            throwError("COMMON", 400, "SCHEMA_ERROR", `Campaign Type ${campaignType} has not any columns configured in schema`);
        }
        // Extract columns from the response
        const columnsForGivenCampaignId = mdmsResponse?.columns;

        // Get localized headers based on the column names
        const headerColumnsAfterHierarchy = getLocalizedHeaders(columnsForGivenCampaignId, localizationMap);
        if (!headerColumnsAfterHierarchy.includes(getLocalizedName(config.boundary.boundaryCode, localizationMap))) {
            logger.error(`Column Headers of generated Boundary Template does not have ${getLocalizedName(config.boundary.boundaryCode, localizationMap)} column`)
            throwError("COMMON", 400, "VALIDATION_ERROR", `Column Headers of generated Boundary Template does not have ${getLocalizedName(config.boundary.boundaryCode, localizationMap)} column`)
        }
        return headerColumnsAfterHierarchy;
    } catch (error: any) {
        console.log(error)
        throwError("FILE", 400, "FETCHING_COLUMN_ERROR", "Error fetching column Headers From Schema (either boundary code column not found or given  Campaign Type not found in schema) Check logs")
    }

}


async function getFinalValidHeadersForTargetSheetAsPerCampaignType(request: any, hierarchy: any[], differentTabsBasedOnLevel: any, localizationMap?: any) {
    const modifiedHierarchy = hierarchy.map(ele => `${request?.body?.ResourceDetails?.hierarchyType}_${ele}`.toUpperCase());
    const localizedHierarchy = getLocalizedHeaders(modifiedHierarchy, localizationMap);
    const index = localizedHierarchy.indexOf(getLocalizedName(differentTabsBasedOnLevel, localizationMap));
    const expectedHeadersForTargetSheetUptoHierarchy = index !== -1 ? localizedHierarchy.slice(index) : throwError("COMMON", 400, "VALIDATION_ERROR", `${getLocalizedName(config?.boundary?.generateDifferentTabsOnBasisOf, localizationMap)} level not present in the hierarchy`);
    const responseFromCampaignSearch = await getCampaignSearchResponse(request);
    const campaignObject = responseFromCampaignSearch?.CampaignDetails?.[0];
    const columnFromSchemaOfTargetTemplate = await generateDynamicTargetHeaders(request, campaignObject, localizationMap);
    const localizedcolumnFromSchemaOfTargetTemplate = getLocalizedHeaders(columnFromSchemaOfTargetTemplate, localizationMap)
    const expectedHeadersForTargetSheet = [...expectedHeadersForTargetSheetUptoHierarchy, getLocalizedName(config?.boundary?.boundaryCode, localizationMap), ...localizedcolumnFromSchemaOfTargetTemplate];
    return expectedHeadersForTargetSheet;
}

async function getDifferentTabGeneratedBasedOnConfig(request: any, boundaryDataGeneratedBeforeDifferentTabSeparation: any, localizationMap?: any) {
    var boundaryDataGeneratedAfterDifferentTabSeparation: any = boundaryDataGeneratedBeforeDifferentTabSeparation;
    const boundaryData = await getBoundaryDataAfterGeneration(boundaryDataGeneratedBeforeDifferentTabSeparation, request, localizationMap);
    let differentTabsBasedOnLevel = await getBoundaryOnWhichWeSplit(request);
    differentTabsBasedOnLevel = getLocalizedName(`${request?.query?.hierarchyType}_${differentTabsBasedOnLevel}`.toUpperCase(), localizationMap);
    logger.info(`Boundaries are seperated based on hierarchy type ${differentTabsBasedOnLevel}`)
    const isKeyOfThatTypePresent = boundaryData.some((data: any) => data.hasOwnProperty(differentTabsBasedOnLevel));
    const boundaryTypeOnWhichWeSplit = boundaryData.filter((data: any) => data[differentTabsBasedOnLevel]);
    if (isKeyOfThatTypePresent && boundaryTypeOnWhichWeSplit.length >= parseInt(config?.boundary?.numberOfBoundaryDataOnWhichWeSplit)) {
        logger.info(`sinces the conditions are matched boundaries are getting splitted into different tabs`)
        boundaryDataGeneratedAfterDifferentTabSeparation = await convertSheetToDifferentTabs(request, boundaryData, differentTabsBasedOnLevel, localizationMap);
    }
    return boundaryDataGeneratedAfterDifferentTabSeparation;
}

async function getBoundaryOnWhichWeSplit(request: any) {
    const mdmsResponse = await getMDMSV1Data(request, config?.values?.moduleName, config?.masterNameForSplitBoundariesOn, request?.query?.tenantId || request?.body?.ResourceDetails?.tenantId);
    const responseFromCampaignSearch = await getCampaignSearchResponse(request);
    const hierarchyTypeFromCampaignResponseObject = responseFromCampaignSearch?.CampaignDetails?.[0].hierarchyType;
    return mdmsResponse.filter((item: any) => item.hierarchy == hierarchyTypeFromCampaignResponseObject).map((item: any) => item.splitBoundariesOn);
}


function checkIfSourceIsMicroplan(objectWithAdditionalDetails: any): boolean {
    return objectWithAdditionalDetails?.additionalDetails?.source === 'microplan';
}







export {
    generateProcessedFileAndPersist,
    convertToTypeData,
    getChildParentMap,
    addBoundaryCodeToData,
    prepareDataForExcel,
    extractCodesFromBoundaryRelationshipResponse,
    searchProjectCampaignResourcData,
    processDataSearchRequest,
    getCodeMappingsOfExistingBoundaryCodes,
    processBasedOnAction,
    appendSheetsToWorkbook,
    generateFilteredBoundaryData,
    generateHierarchy,
    createBoundaryMap,
    autoGenerateBoundaryCodes,
    convertSheetToDifferentTabs,
    getBoundaryDataAfterGeneration,
    boundaryBulkUpload,
    enrichAndPersistCampaignWithError,
    getLocalizedName,
    reorderBoundaries,
    reorderBoundariesOfDataAndValidate,
    getTargetBoundariesRelatedToCampaignId,
    getFiltersFromCampaignSearchResponse,
    getConfigurableColumnHeadersBasedOnCampaignType,
    getFinalValidHeadersForTargetSheetAsPerCampaignType,
    getDifferentTabGeneratedBasedOnConfig,
    checkIfSourceIsMicroplan,
    getBoundaryOnWhichWeSplit
}
