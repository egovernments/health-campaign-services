import { defaultheader, httpRequest } from "./request";
import config from "../config/index";
import { v4 as uuidv4 } from "uuid";
import { produceModifiedMessages } from "../kafka/Producer";
import {
  getCampaignSearchResponse,
  getHierarchy,
  handleResouceDetailsError,
} from "../api/campaignApis";
import {
  getCampaignNumber,
  createAndUploadFile,
  createExcelSheet,
  getAutoGeneratedBoundaryCodesHandler,
  createBoundaryEntities,
  // getMDMSV1Data,
  getTargetSheetDataAfterCode,
  callMdmsTypeSchema,
  getSheetDataFromWorksheet,
  getTargetWorkbook,
  createAndUploadJsonFile,
  createBoundaryRelationship,
  getSheetData,
  searchMDMS
} from "../api/genericApis";
import { getFormattedStringForDebug, logger } from "./logger";
import createAndSearch from "../config/createAndSearch";
import {
  addDataToSheet,
  createBoundaryDataMainSheet,
  createHeaderToHierarchyMap,
  createReadMeSheet,
  extractFrenchOrPortugeseLocalizationMap,
  // extractFrenchOrPortugeseLocalizationMap,
  findMapValue,
  getConfigurableColumnHeadersFromSchemaForTargetSheet,
  getCurrentProcesses,
  getLocalizedHeaders,
  getLocalizedMessagesHandler,
  getMdmsDataBasedOnCampaignType,
  getRelatedDataWithCampaign,
  modifyBoundaryData,
  modifyBoundaryDataHeadersWithMap,
  prepareProcessesInDb,
  replicateRequest,
  searchAllGeneratedResources,
  throwError,
} from "./genericUtils";
import { executeQuery, getTableName } from "./db";
import {
  campaignDetailsTransformer,
  genericResourceTransformer,
} from "./transforms/searchResponseConstructor";
import { transformAndCreateLocalisation } from "./transforms/localisationMessageConstructor";
import {
  allProcesses,
  campaignStatuses,
  dataRowStatuses,
  generatedResourceStatuses,
  headingMapping,
  processStatuses,
  resourceDataStatuses,
  usageColumnStatus,
} from "../config/constants";
import { getBoundaryTabName } from "./boundaryUtils";
import {
  searchProjectTypeCampaignService,
  updateProjectTypeCampaignService,
} from "../service/campaignManageService";
import {
  validateBoundaryOfResouces,
  validateBoundarySheetDataInCreateFlow,
} from "../validators/campaignValidators";
import {
  // findColumnByHeader,
  getExcelWorkbookFromFileURL,
  getNewExcelWorkbook,
  lockTargetFields,
  updateFontNameToRoboto,
} from "./excelUtils";
import {
  areBoundariesSame,
  callGenerate,
  callGenerateIfBoundariesOrCampaignTypeDiffer,
  isGenerationTriggerNeeded,
} from "./generateUtils";
import {
  generateDynamicTargetHeaders,
  isDynamicTargetTemplateForProjectType,
} from "./targetUtils";
import {
  fetchProjectsWithProjectId,
  getBoundariesFromCampaignSearchResponse,
  getColumnIndexByHeader,
  hideColumnsOfProcessedFile,
  modifyNewSheetData,
  unhideColumnsOfProcessedFile,
} from "./onGoingCampaignUpdateUtils";
import { changeCreateDataForMicroplan, lockSheet } from "./microplanUtils";
const _ = require("lodash");
import { searchDataService } from "../service/dataManageService";
import { createMdmsData, defaultRequestInfo, searchBoundaryRelationshipData, searchMDMSDataViaV2Api } from "../api/coreApis";
import { deleteRedisCacheKeysWithPrefix } from "./redisUtils";
import {
  fetchFacilityData,
  fetchTargetData,
  fetchUserData,
} from "./microplanIntergration";
import { GenerateTemplateQuery } from "../models/GenerateTemplateQuery";
import { getLocaleFromRequest } from "./localisationUtils";
import { generateDataService } from "../service/sheetManageService";
import Localisation from "../controllers/localisationController/localisation.controller";
import { triggerUserCredentialEmailFlow } from "./mailUtils";

function updateRange(range: any, worksheet: any) {
  let maxColumnIndex = 0;

  // Iterate through each row to find the last column with data
  for (let row = range.s.r; row <= range.e.r; row++) {
    const rowCells = worksheet.getRow(row + 1); // ExcelJS rows are 1-based
    rowCells.eachCell((cell: any, colNumber: number) => {
      if (cell.value !== undefined && colNumber > maxColumnIndex) {
        maxColumnIndex = colNumber;
      }
    });
  }

  // Update the end column of the range with the maximum column index found
  range.e.c = maxColumnIndex;
}

function findAndChangeColumns(worksheet: any, columns: any) {
  const firstRow = worksheet.getRow(1);
  firstRow.eachCell((cell: any, colNumber: number) => {
    if (cell.value === "#status#") {
      columns.statusColumn = cell.address.replace(/\d+/g, "");
      // Set the cell color to green
      cell.fill = {
        type: "pattern",
        pattern: "solid",
        fgColor: { argb: "CCCC00" },
      };
      // Delete status column cells in subsequent rows
      worksheet.eachRow((row: any, rowIndex: number) => {
        if (rowIndex > 1) {
          const statusCell = row.getCell(colNumber);
          statusCell.value = undefined;
        }
      });
    }
    if (cell.value === "#errorDetails#") {
      columns.errorDetailsColumn = cell.address.replace(/\d+/g, "");
      // Set the cell color to green
      cell.fill = {
        type: "pattern",
        pattern: "solid",
        fgColor: { argb: "CCCC00" },
      };
      // Delete error details column cells in subsequent rows
      worksheet.eachRow((row: any, rowIndex: number) => {
        if (rowIndex > 1) {
          const errorDetailsCell = row.getCell(colNumber);
          errorDetailsCell.value = undefined;
        }
      });
    }
  });
}

function makeColumns(worksheet: any, range: any, columns: any) {
  // If the status column doesn't exist, calculate the next available column
  if (!columns?.statusColumn) {
    const emptyColumnIndex = range.e.c;
    columns.statusColumn = String.fromCharCode(65 + (emptyColumnIndex + 1));
    const statusCell = worksheet.getCell(`${columns.statusColumn}1`);
    statusCell.value = "#status#";
    statusCell.fill = {
      type: "pattern",
      pattern: "solid",
      fgColor: { argb: "CCCC00" },
    };
    statusCell.font = { bold: true };
    worksheet.getColumn(columns.statusColumn).width = 40;
  }

  // Calculate errorDetails column one column to the right of status column
  if (!columns?.errorDetailsColumn) {
    columns.errorDetailsColumn = String.fromCharCode(
      columns?.statusColumn.charCodeAt(0) + 1
    );
    const errorDetailsCell = worksheet.getCell(
      `${columns.errorDetailsColumn}1`
    );
    errorDetailsCell.value = "#errorDetails#";
    errorDetailsCell.fill = {
      type: "pattern",
      pattern: "solid",
      fgColor: { argb: "CCCC00" },
    };
    errorDetailsCell.font = { bold: true };
    worksheet.getColumn(columns.errorDetailsColumn).width = 40;
  }
}

function findColumns(worksheet: any) {
  const range = {
    s: { r: 0, c: 0 },
    e: { r: worksheet.rowCount - 1, c: worksheet.columnCount - 1 },
  };

  // Check if the status column already exists in the first row
  var columns = {};

  findAndChangeColumns(worksheet, columns);

  makeColumns(worksheet, range, columns);

  updateRange(range, worksheet);

  return columns;
}

function enrichErrors(
  errorData: any,
  worksheet: any,
  statusColumn: any,
  errorDetailsColumn: any,
  additionalDetailsErrors: any,
  createAndSearchConfig: any,
  localizationMap?: { [key: string]: string }
) {
  if (errorData) {
    errorData.forEach((error: any) => {
      const rowIndex = error.rowNumber; // ExcelJS rows are 1-based
      const statusCell = worksheet.getCell(`${statusColumn}${rowIndex}`);
      const errorDetailsCell = worksheet.getCell(
        `${errorDetailsColumn}${rowIndex}`
      );
      statusCell.value = error.status;
      errorDetailsCell.value = error.errorDetails;

      if (
        error?.status &&
        !(error?.status === "CREATED" || error?.status === "VALID")
      ) {
        additionalDetailsErrors.push(error);
      }
    });
    if (errorData.some((error: any) => error?.status === "CREATED")) {
      const uniqueIdentifierFirstRowCell = `${createAndSearchConfig?.uniqueIdentifierColumn}1`;
      const columnName = getLocalizedName(
        createAndSearchConfig?.uniqueIdentifierColumnName,
        localizationMap
      );
      const uniqueIdentifierCell = worksheet.getCell(
        uniqueIdentifierFirstRowCell
      );
      uniqueIdentifierCell.value = columnName;

      // Set the cell color to green
      uniqueIdentifierCell.fill = {
        type: "pattern",
        pattern: "solid",
        fgColor: { argb: "ff9248" }, // Green color
      };
      uniqueIdentifierCell.font = { bold: true };
      // Hide the unique identifier column
      worksheet.getColumn(
        createAndSearchConfig?.uniqueIdentifierColumn
      ).hidden = true;
    }
    errorData.forEach((error: any) => {
      const rowIndex = error.rowNumber;
      if (error.isUniqueIdentifier) {
        const uniqueIdentifierCell = worksheet.getCell(
          `${createAndSearchConfig.uniqueIdentifierColumn}${rowIndex}`
        );
        uniqueIdentifierCell.value = error.uniqueIdentifier;
        if (createAndSearchConfig?.activeColumn) {
          const activeCell = worksheet.getCell(
            `${createAndSearchConfig.activeColumn}${rowIndex}`
          );
          activeCell.value = usageColumnStatus.active;
        }
      }
    });
  }
}

function enrichActiveAndUUidColumn(
  worksheet: any,
  createAndSearchConfig: any,
  request: any
) {
  if (
    createAndSearchConfig?.activeColumn &&
    request?.body?.dataToCreate &&
    request?.body?.dataToCreate?.length > 0 &&
    request?.body?.ResourceDetails?.type == "user"
  ) {
    const dataToCreate = request.body.dataToCreate;
    for (const data of dataToCreate) {
      const rowNumber = data["!row#number!"];
      const activeCell = worksheet.getCell(
        `${createAndSearchConfig?.activeColumn}${rowNumber}`
      );
      const uniqueIdentifierCell = worksheet.getCell(
        `${createAndSearchConfig?.uniqueIdentifierColumn}${rowNumber}`
      );
      activeCell.value = usageColumnStatus.active;
      uniqueIdentifierCell.value = data["userServiceUuid"] || data?.user?.["userServiceUuid"];
    }
  }
}

function deterMineLastColumnAndEnrichUserDetails(
  worksheet: any,
  userNameAndPassword:
    | { rowNumber: number; userName: string; password: string }[]
    | undefined,
  request: any
): string {

  // Default columns
  let usernameColumn = "L";
  let passwordColumn = "M";

  // Update columns if the request indicates a different source
  if (
    request?.body?.ResourceDetails?.additionalDetails?.source == "microplan"
  ) {
    usernameColumn = "F";
    passwordColumn = "G";
  }

  // const foundUsernameColumn = findColumnByHeader("UserName", worksheet);
  // const foundPasswordColumn = findColumnByHeader("Password", worksheet);

  // if (foundUsernameColumn) {
  //   usernameColumn = foundUsernameColumn;
  // }
  // if (foundPasswordColumn) {
  //   passwordColumn = foundPasswordColumn;
  // }

  // Populate username and password columns if data is provided
  if (userNameAndPassword) {
    // Set headers with formatting
    const setCellHeader = (cell: string) => {
      worksheet.getCell(cell).value =
        cell === usernameColumn + "1" ? "UserName" : "Password";
      worksheet.getCell(cell).fill = {
        type: "pattern",
        pattern: "solid",
        fgColor: { argb: "ff9248" }, // Green color
      };
      worksheet.getCell(cell).font = { bold: true };
      const columnLetter = cell.replace(/\d+$/, "");
      worksheet.getColumn(columnLetter).width = 40;
    };

    setCellHeader(usernameColumn + "1");
    setCellHeader(passwordColumn + "1");

    // Set values
    userNameAndPassword.forEach((data) => {
      const rowIndex = data.rowNumber;
      worksheet.getCell(`${usernameColumn}${rowIndex}`).value = data.userName;
      worksheet.getCell(`${passwordColumn}${rowIndex}`).value = data.password;
    });
  }

  return passwordColumn;
}

function adjustRef(worksheet: any, lastColumn: any) {
  const range = getSheetDataFromWorksheet(worksheet).filter(
    (row: any) => row
  ).length; // Get the number of used rows
  worksheet.views = [
    { state: "frozen", ySplit: 1, topLeftCell: "A2", activeCell: "A2" },
  ];
  worksheet.autoFilter = {
    from: {
      row: 1,
      column: 1,
    },
    to: {
      row: range,
      column: worksheet.getColumn(lastColumn).number,
    },
  };
}

function processErrorData(
  request: any,
  createAndSearchConfig: any,
  workbook: any,
  sheetName: any,
  localizationMap?: { [key: string]: string }
) {
  const worksheet = workbook.getWorksheet(sheetName);
  var errorData = request.body.sheetErrorDetails;
  const userNameAndPassword = request.body.userNameAndPassword;
  // Determine the last column to set the worksheet ref
  const lastColumn = deterMineLastColumnAndEnrichUserDetails(
    worksheet,
    userNameAndPassword,
    request
  );
  const columns: any = findColumns(worksheet);
  const statusColumn = columns.statusColumn;
  const errorDetailsColumn = columns.errorDetailsColumn;
  const additionalDetailsErrors: any[] = [];
  errorData = mergeErrors(errorData);
  enrichErrors(
    errorData,
    worksheet,
    statusColumn,
    errorDetailsColumn,
    additionalDetailsErrors,
    createAndSearchConfig,
    localizationMap
  );
  enrichActiveAndUUidColumn(worksheet, createAndSearchConfig, request);

  request.body.additionalDetailsErrors = request?.body?.additionalDetailsErrors
    ? request?.body?.additionalDetailsErrors.concat(additionalDetailsErrors)
    : additionalDetailsErrors;

  // Adjust the worksheet ref to include the last column
  adjustRef(worksheet, lastColumn);
  updateFontNameToRoboto(worksheet);

  workbook.xlsx.writeBuffer();
}

function mergeErrors(errorData: any) {
  const errorMap: any = {};

  errorData.forEach((item: any) => {
    const { rowNumber, sheetName, status, errorDetails, ...rest } = item;

    // If the rowNumber already exists, merge the errorDetails
    if (errorMap[rowNumber]) {
      errorMap[rowNumber].errorDetails += "; " + errorDetails;
    } else {
      // If not, add a new entry
      errorMap[rowNumber] = {
        rowNumber,
        sheetName,
        status,
        errorDetails,
        ...rest,
      };
    }
  });

  // Convert the errorMap back into an array
  return Object.values(errorMap);
}

function processErrorDataForEachSheets(
  request: any,
  createAndSearchConfig: any,
  workbook: any,
  sheetName: any
) {
  const desiredSheet = workbook.getWorksheet(sheetName);
  const columns: any = findColumns(desiredSheet);
  const statusColumn = columns.statusColumn;
  const errorDetailsColumn = columns.errorDetailsColumn;
  const userNameAndPassword = request?.body?.userNameAndPassword;

  var errorData = request.body.sheetErrorDetails.filter(
    (error: any) => error.sheetName === sheetName
  );
  const additionalDetailsErrors: any = [];
  errorData = mergeErrors(errorData);
  if (errorData) {
    errorData.forEach((error: any) => {
      const rowIndex = error.rowNumber;
      if (error.isUniqueIdentifier) {
        const uniqueIdentifierCell =
          createAndSearchConfig.uniqueIdentifierColumn + rowIndex;
        desiredSheet.getCell(uniqueIdentifierCell).value =
          error.uniqueIdentifier;
      }

      const statusCell = statusColumn + rowIndex;
      const errorDetailsCell = errorDetailsColumn + rowIndex;
      desiredSheet.getCell(statusCell).value = error.status;
      desiredSheet.getCell(errorDetailsCell).value = error.errorDetails;

      if (!(error.status === "CREATED" || error.status === "VALID")) {
        additionalDetailsErrors.push(error);
      }
    });
  }
  if (userNameAndPassword) {
    var newUserNameAndPassword: any = [];
    for (const data of userNameAndPassword) {
      const rowArray = data.rowNumber;
      for (let i = 0; i < rowArray.length; i++) {
        if (rowArray[i].sheetName == sheetName) {
          newUserNameAndPassword.push({ ...data, rowNumber: rowArray[i].row });
        }
      }
    }
  }
  deterMineLastColumnAndEnrichUserDetails(
    desiredSheet,
    newUserNameAndPassword,
    request
  );
  request.body.additionalDetailsErrors = request?.body?.additionalDetailsErrors
    ? request?.body?.additionalDetailsErrors.concat(additionalDetailsErrors)
    : additionalDetailsErrors;
  updateFontNameToRoboto(desiredSheet);
  workbook.worksheets[sheetName] = desiredSheet;
}

async function updateStatusFile(
  request: any,
  localizationMap?: { [key: string]: string }
) {
  const fileStoreId = request?.body?.ResourceDetails?.fileStoreId;
  const tenantId = request?.body?.ResourceDetails?.tenantId;
  const createAndSearchConfig =
    createAndSearch[request?.body?.ResourceDetails?.type];
  const fileResponse = await httpRequest(
    config.host.filestore + config.paths.filestore + "/url",
    {},
    { tenantId: tenantId, fileStoreIds: fileStoreId },
    "get"
  );
  const isLockSheetNeeded =
    request?.body?.ResourceDetails?.additionalDetails?.source == "microplan"
      ? true
      : false;

  if (!fileResponse?.fileStoreIds?.[0]?.url) {
    throwError("FILE", 500, "INVALID_FILE");
  }
  const fileUrl = fileResponse?.fileStoreIds?.[0]?.url;
  const sheetName = createAndSearchConfig?.parseArrayConfig?.sheetName;
  const localizedSheetName = getLocalizedName(sheetName, localizationMap);
  const workbook: any = await getExcelWorkbookFromFileURL(
    fileUrl,
    localizedSheetName
  );
  const worksheet: any = workbook.getWorksheet(localizedSheetName);
  if (request?.body?.ResourceDetails?.type == "user") {
    const columnsToUnhide = ["L", "N", "M", "O", "P"];
    unhideColumnsOfProcessedFile(worksheet, columnsToUnhide);
  }
  processErrorData(
    request,
    createAndSearchConfig,
    workbook,
    localizedSheetName,
    localizationMap
  );
  await hideMultiSelectMainColumns(worksheet, request, localizationMap);

  // Set column widths
  const columnWidths = Array(12).fill({ width: 30 });
  columnWidths.forEach((colWidth, index) => {
    if (worksheet.getColumn(index + 1)) {
      worksheet.getColumn(index + 1).width = colWidth.width;
    }
  });
  if (isLockSheetNeeded) lockSheet(request, workbook);
  const responseData = await createAndUploadFile(workbook, request);

  logger.info("File updated successfully:" + JSON.stringify(responseData));
  if (responseData?.[0]?.fileStoreId) {
    request.body.ResourceDetails.processedFileStoreId =
      responseData?.[0]?.fileStoreId;
  } else {
    throwError("FILE", 500, "STATUS_FILE_CREATION_ERROR");
  }
}

async function hideMultiSelectMainColumns(
  worksheet: any,
  request: any,
  localizationMap?: { [key: string]: string }) {
  const type = request?.body?.ResourceDetails?.type;
  const tenantId = request?.body?.ResourceDetails?.tenantId;
  const isUpdate = request?.body?.parentCampaignObject ? true : false;
  const isSourceMicroplan = checkIfSourceIsMicroplan(request?.body?.ResourceDetails);
  const schema = await getSchema(tenantId, isUpdate, type, isSourceMicroplan);
  const properties = schema?.properties;
  if (properties && Object.keys(properties)?.length > 0) {
    const headerRow = worksheet.getRow(1); // Assuming header is in the first row

    for (const key in properties) {
      if (properties[key]?.multiSelectDetails) {
        const columnName = getLocalizedName(key, localizationMap);

        const columnIndex = headerRow.values.indexOf(columnName);
        if (columnIndex > -1) {
          worksheet.getColumn(columnIndex).hidden = true;
        } else {
          console.warn(`Column with header "${columnName}" not found in worksheet.`);
        }
      }
    }
  }
}

export async function getSchema(tenantId: string, isUpdate: boolean, type: string, isSourceMicroplan: boolean) {
  if (type === "facility" || type === "user") {
    return isSourceMicroplan
      ? await callMdmsTypeSchema(tenantId, isUpdate, type, "microplan")
      : await callMdmsTypeSchema(tenantId, isUpdate, type);
  }
  return null;
}

async function updateStatusFileForEachSheets(
  request: any,
  localizationMap?: { [key: string]: string }
) {
  const fileStoreId = request?.body?.ResourceDetails?.fileStoreId;
  const tenantId = request?.body?.ResourceDetails?.tenantId;
  const createAndSearchConfig =
    createAndSearch[request?.body?.ResourceDetails?.type];
  const fileResponse = await httpRequest(
    config.host.filestore + config.paths.filestore + "/url",
    {},
    { tenantId: tenantId, fileStoreIds: fileStoreId },
    "get"
  );
  const isLockSheetNeeded =
    request?.body?.ResourceDetails?.additionalDetails?.source == "microplan"
      ? true
      : false;

  if (!fileResponse?.fileStoreIds?.[0]?.url) {
    throwError("FILE", 500, "INVALID_FILE");
  }

  const fileUrl = fileResponse?.fileStoreIds?.[0]?.url;

  const workbook: any = await getExcelWorkbookFromFileURL(fileUrl, "");

  const sheetNames = workbook.worksheets.map(
    (worksheet: any) => worksheet.name
  );
  const localizedSheetNames = getLocalizedHeaders(sheetNames, localizationMap);

  const sheetErrorDetails = request?.body?.sheetErrorDetails;
  if (sheetErrorDetails && sheetErrorDetails?.length > 0) {
    const firstError = sheetErrorDetails[0];
    if (Array.isArray(firstError?.rowNumber)) {
      var newSheetErrorDetails: any = [];
      for (const error of sheetErrorDetails) {
        for (let i = 0; i < error.rowNumber.length; i++) {
          newSheetErrorDetails.push({
            ...error,
            rowNumber: error.rowNumber[i]?.row,
            sheetName: error.rowNumber[i]?.sheetName,
          });
        }
      }
      request.body.sheetErrorDetails = newSheetErrorDetails;
    }
  }

  localizedSheetNames.forEach((sheetName: any) => {
    if (
      sheetName !==
      getLocalizedName(config?.boundary?.boundaryTab, localizationMap) &&
      sheetName !==
      getLocalizedName(config.values.readMeTab, localizationMap) &&
      sheetName !==
      getLocalizedName("USER_MICROPLAN_SHEET_ROLES", localizationMap)
    ) {
      processErrorDataForEachSheets(
        request,
        createAndSearchConfig,
        workbook,
        sheetName
      );
    }
  });
  if (isLockSheetNeeded) lockSheet(request, workbook);
  const responseData = await createAndUploadFile(workbook, request);
  logger.info("File updated successfully:" + JSON.stringify(responseData));
  if (responseData?.[0]?.fileStoreId) {
    request.body.ResourceDetails.processedFileStoreId =
      responseData?.[0]?.fileStoreId;
  } else {
    throwError("FILE", 500, "STATUS_FILE_CREATION_ERROR");
  }
}

function convertToType(dataToSet: any, type: any) {
  switch (type) {
    case "string":
      return String(dataToSet);
    case "number":
      return Number(dataToSet);
    case "boolean":
      // Convert to boolean assuming any truthy value should be true and falsy should be false
      return Boolean(dataToSet);
    // Add more cases if needed for other types
    default:
      // If type is not recognized, keep dataToSet as it is
      return dataToSet;
  }
}

function setTenantId(
  resultantElement: any,
  requestBody: any,
  createAndSearchConfig: any
) {
  if (createAndSearchConfig?.parseArrayConfig?.tenantId) {
    const tenantId = _.get(
      requestBody,
      createAndSearchConfig?.parseArrayConfig?.tenantId?.getValueViaPath
    );
    _.set(
      resultantElement,
      createAndSearchConfig?.parseArrayConfig?.tenantId?.resultantPath,
      tenantId
    );
  }
}

async function processData(
  request: any,
  dataFromSheet: any[],
  createAndSearchConfig: any,
  localizationMap?: { [key: string]: string }
) {
  const parseLogic = createAndSearchConfig?.parseArrayConfig?.parseLogic;
  const latLongColumnsList = config.values.latLongColumns
    ? config.values.latLongColumns.split(",").map((item: any) => item.trim()).filter(Boolean)
    : [];
  const requiresToSearchFromSheet =
    createAndSearchConfig?.requiresToSearchFromSheet;
  const isSourceMicroplan =
    request?.body?.ResourceDetails?.additionalDetails?.source == "microplan";
  var createData = [],
    searchData = [];
  for (const data of dataFromSheet) {
    const resultantElement: any = {};
    for (const element of parseLogic) {
      if (element?.resultantPath) {
        const localizedSheetColumnName = getLocalizedName(
          element.sheetColumnName,
          localizationMap
        );
        let dataToSet = _.get(data, localizedSheetColumnName);
        if (element.conversionCondition) {
          dataToSet = element.conversionCondition[dataToSet];
        }
        if (element.type) {
          dataToSet = convertToType(dataToSet, element.type);
        }
        _.set(resultantElement, element.resultantPath, dataToSet);
      }
    }
    resultantElement["!row#number!"] = data["!row#number!"];
    var addToCreate = true;
    if (requiresToSearchFromSheet) {
      for (const key of requiresToSearchFromSheet) {
        const localizedSheetColumnName = getLocalizedName(
          key.sheetColumnName,
          localizationMap
        );
        if (data[localizedSheetColumnName]) {
          if (isSourceMicroplan) {
            changeCreateDataForMicroplan(
              request,
              resultantElement,
              data,
              latLongColumnsList,
              localizationMap
            );
          }
          searchData.push(resultantElement);
          addToCreate = false;
          break;
        }
      }
    }
    if (addToCreate) {
      if (isSourceMicroplan) {
        changeCreateDataForMicroplan(
          request,
          resultantElement,
          data,
          latLongColumnsList,
          localizationMap
        );
      }
      createData.push(resultantElement);
    }
  }
  return { searchData, createData };
}

function setTenantIdAndSegregate(
  processedData: any,
  createAndSearchConfig: any,
  requestBody: any
) {
  for (const resultantElement of processedData.createData) {
    setTenantId(resultantElement, requestBody, createAndSearchConfig);
  }
  for (const resultantElement of processedData.searchData) {
    setTenantId(resultantElement, requestBody, createAndSearchConfig);
  }
  return processedData;
}

// Original function divided into two parts
async function convertToTypeData(
  request: any,
  dataFromSheet: any[],
  createAndSearchConfig: any,
  requestBody: any,
  localizationMap?: { [key: string]: string }
) {
  const processedData = await processData(
    request,
    dataFromSheet,
    createAndSearchConfig,
    localizationMap
  );
  return setTenantIdAndSegregate(
    processedData,
    createAndSearchConfig,
    requestBody
  );
}

function updateActivityResourceId(request: any) {
  if (request?.body?.Activities && Array.isArray(request?.body?.Activities)) {
    for (const activity of request?.body?.Activities) {
      activity.resourceDetailsId = request?.body?.ResourceDetails?.id;
    }
  }
}

async function generateProcessedFileAndPersist(
  request: any,
  localizationMap?: { [key: string]: string }
) {
  if (
    request.body.ResourceDetails.type == "boundaryWithTarget" ||
    (request?.body?.ResourceDetails?.additionalDetails?.source == "microplan" &&
      request.body.ResourceDetails.type == "user")
  ) {
    await updateStatusFileForEachSheets(request, localizationMap);
  } else {
    if (
      request.body.ResourceDetails.type !== "boundary" &&
      request.body.ResourceDetails.type !== "boundaryManagement"
    ) {
      await updateStatusFile(request, localizationMap);
    }
  }
  updateActivityResourceId(request);
  request.body.ResourceDetails = {
    ...request?.body?.ResourceDetails,
    status:
      request.body.ResourceDetails.status != resourceDataStatuses.invalid
        ? resourceDataStatuses.completed
        : resourceDataStatuses.invalid,
    auditDetails: {
      ...request?.body?.ResourceDetails?.auditDetails,
      lastModifiedBy: request?.body?.RequestInfo?.userInfo?.uuid,
      lastModifiedTime: Date.now(),
    },
    additionalDetails: {
      ...request?.body?.ResourceDetails?.additionalDetails,
      sheetErrors: request?.body?.additionalDetailsErrors,
      source:
        request?.body?.ResourceDetails?.additionalDetails?.source == "microplan"
          ? "microplan"
          : null,
    },
  };
  if (
    request?.body?.ResourceDetails?.status === resourceDataStatuses.completed &&
    request?.body?.ResourceDetails?.type === "boundaryManagement"
  ) {
    // delete redis cache key with prefix boundaryRelatiionshipSearch
    await deleteRedisCacheKeysWithPrefix("boundaryRelationShipSearch");

    logger.info(
      "calling generate after boundary data uploaded under type boundary management"
    );
    const newRequestBody = {
      RequestInfo: request?.body?.RequestInfo,
    };
    const params = {
      type: request?.body?.ResourceDetails?.type,
      tenantId: request?.body?.ResourceDetails?.tenantId,
      forceUpdate: "true",
      hierarchyType: request?.body?.ResourceDetails?.hierarchyType,
      campaignId: "default",
    };
    const newRequestBoundary = replicateRequest(
      request,
      newRequestBody,
      params
    );
    setTimeout(async () => {
      // Code to be executed after 10 seconds
      logger.info("Timeout of 30 sec after boundary data creation");
      await callGenerate(
        newRequestBoundary,
        request?.body?.ResourceDetails?.type
      );
    }, 30000);
  }
  request.body.ResourceDetails.processedFileStoreId = request?.body?.ResourceDetails?.processedFileStoreId || null;
  const persistMessage: any = { ResourceDetails: request.body.ResourceDetails };
  if (request?.body?.ResourceDetails?.action == "create") {
    persistMessage.ResourceDetails.additionalDetails = {
      source:
        request?.body?.ResourceDetails?.additionalDetails?.source == "microplan"
          ? "microplan"
          : null,
      fileName:
        request?.body?.ResourceDetails?.additionalDetails?.fileName || null,
    };
  }
  await produceModifiedMessages(
    persistMessage,
    config?.kafka?.KAFKA_UPDATE_RESOURCE_DETAILS_TOPIC,
    request?.body?.ResourceDetails?.tenantId
  );
  logger.info(
    `ResourceDetails to persist : ${request.body.ResourceDetails.type}`
  );
  if (
    request?.body?.Activities &&
    Array.isArray(request?.body?.Activities) &&
    request?.body?.Activities.length > 0
  ) {
    logger.info("Activities to persist : ");
    logger.debug(getFormattedStringForDebug(request?.body?.Activities));
    logger.info(`Waiting for 2 seconds`);
    await new Promise((resolve) => setTimeout(resolve, 2000));
    const activities = request?.body?.Activities;
    for (let i = 0; i < activities.length; i += 10) {
      const chunk = activities.slice(i, Math.min(i + 10, activities.length));
      const activityObject: any = { Activities: chunk };
      await produceModifiedMessages(
        activityObject,
        config.kafka.KAFKA_CREATE_RESOURCE_ACTIVITY_TOPIC,
        activityObject?.Activities?.[0]?.tenantId
      );
    }
  }
}

function getRootBoundaryCode(boundaries: any[] = []) {
  if(boundaries?.length == 0) return "";
  for (const boundary of boundaries) {
    if (boundary.isRoot) {
      return boundary.code;
    }
  }
  return "";
}

async function enrichRootProjectIdAndBoundaryCode(campaignDetails: any) {
  campaignDetails.boundaryCode = campaignDetails?.boundaryCode || getRootBoundaryCode(campaignDetails?.boundaries) || null;
  campaignDetails.projectId = campaignDetails?.projectId || await getRootProjectIdViaCampaignNumber(campaignDetails?.campaignNumber, campaignDetails?.boundaryCode, campaignDetails?.tenantId);
  campaignDetails.projectId = campaignDetails.projectId || null;
}

async function enrichAndPersistCampaignWithError(requestBody: any, error: any) {
  if (requestBody?.parentCampaign) {
    await makeParentInactiveOrActive(requestBody, true);
  }
  requestBody.CampaignDetails = requestBody?.CampaignDetails || {};
  requestBody.CampaignDetails.campaignNumber =
    requestBody?.CampaignDetails?.campaignNumber || null;
  requestBody.CampaignDetails.campaignDetails = requestBody?.CampaignDetails
    ?.campaignDetails || {
    deliveryRules: requestBody?.CampaignDetails?.deliveryRules,
    resources: requestBody?.CampaignDetails?.resources || [],
    boundaries: requestBody?.CampaignDetails?.boundaries || [],
  };
  requestBody.CampaignDetails.status = campaignStatuses?.failed;
  // requestBody.CampaignDetails.isActive = false;
  requestBody.CampaignDetails.projectType =
    requestBody?.CampaignDetails?.projectType || null;
  requestBody.CampaignDetails.hierarchyType =
    requestBody?.CampaignDetails?.hierarchyType || null;
  requestBody.CampaignDetails.parentId = requestBody?.CampaignDetails?.parentId || null;
  requestBody.CampaignDetails.additionalDetails =
    requestBody?.CampaignDetails?.additionalDetails || {};
  requestBody.CampaignDetails.startDate =
    requestBody?.CampaignDetails?.startDate || null;
  requestBody.CampaignDetails.endDate =
    requestBody?.CampaignDetails?.endDate || null;
  requestBody.CampaignDetails.auditDetails = {
    createdBy: requestBody?.RequestInfo?.userInfo?.uuid,
    createdTime: Date.now(),
    lastModifiedBy: requestBody?.RequestInfo?.userInfo?.uuid,
    lastModifiedTime: Date.now(),
  };
  await enrichRootProjectIdAndBoundaryCode(requestBody?.CampaignDetails);
  requestBody.CampaignDetails.additionalDetails = {
    ...requestBody?.CampaignDetails?.additionalDetails,
    error: error?.code || "INTERNAL_SERVER_ERROR",
  };
  const topic = config?.kafka?.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC;
  // wait for 2 seconds
  logger.info(`Waiting for 2 seconds to persist errors`);
  await new Promise((resolve) => setTimeout(resolve, 2000));
  const produceMessage: any = { CampaignDetails: requestBody.CampaignDetails };
  await produceModifiedMessages(produceMessage, topic, requestBody?.CampaignDetails?.tenantId);
  delete requestBody.CampaignDetails.campaignDetails;
}

export async function enrichAndPersistCampaignWithErrorProcessingTask(campaignDetails: any, parentCampaign: any, useruuid: string, error: any) {
  if (parentCampaign) {
    parentCampaign.isActive = true;
    parentCampaign.parentId = parentCampaign?.parentId || null;
    parentCampaign.campaignDetails = {
      deliveryRules: parentCampaign?.deliveryRules || [],
      resources: parentCampaign?.resources || [],
      boundaries: parentCampaign?.boundaries || [],
    };
    parentCampaign.auditDetails.lastModifiedTime = Date.now();
    parentCampaign.auditDetails.lastModifiedBy = useruuid;
    const produceMessage: any = {
      CampaignDetails: parentCampaign,
    };
    await produceModifiedMessages(
      produceMessage,
      config?.kafka?.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC,
      parentCampaign?.tenantId
    );
  }
  campaignDetails.parentId = campaignDetails?.parentId || null;
  campaignDetails.status = campaignStatuses?.failed;
  campaignDetails.campaignDetails = {
    deliveryRules: campaignDetails?.deliveryRules || [],
    resources: campaignDetails?.resources || [],
    boundaries: campaignDetails?.boundaries || [],
  };
  const currTime = Date.now();
  // requestBody.CampaignDetails.isActive = false;
  campaignDetails.auditDetails = {
    createdBy: useruuid,
    createdTime: currTime,
    lastModifiedBy: useruuid,
    lastModifiedTime: currTime,
  };
  campaignDetails.additionalDetails = {
    ...campaignDetails?.additionalDetails,
    error: error?.code || "INTERNAL_SERVER_ERROR",
  };
  const topic = config?.kafka?.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC;
  // wait for 2 seconds
  logger.info(`Waiting for 2 seconds to persist errors`);
  await new Promise((resolve) => setTimeout(resolve, 2000));
  const produceMessage: any = { CampaignDetails: campaignDetails };
  await produceModifiedMessages(produceMessage, topic, campaignDetails?.tenantId);
}

async function enrichAndPersistCampaignForCreate(
  request: any,
  firstPersist: boolean = false
) {
  const action = request?.body?.CampaignDetails?.action;
  if (firstPersist) {
    if (!request?.body?.parentCampaign) {
      request.body.CampaignDetails.campaignNumber = await getCampaignNumber(
        request.body,
        "CMP-[cy:yyyy-MM-dd]-[SEQ_EG_CMP_ID]",
        "campaign.number",
        request?.body?.CampaignDetails?.tenantId
      );
    } else {
      request.body.CampaignDetails.campaignNumber =
        request.body.parentCampaign?.campaignNumber;
      request.body.CampaignDetails.campaignName =
        request.body.parentCampaign?.campaignName;
    }
    processAppConfig(request?.body?.CampaignDetails, request?.body?.RequestInfo);
  }
  request.body.CampaignDetails.campaignDetails = {
    deliveryRules: request?.body?.CampaignDetails?.deliveryRules || [],
    resources: request?.body?.CampaignDetails?.resources || [],
    boundaries: request?.body?.CampaignDetails?.boundaries || [],
  };
  request.body.CampaignDetails.status =
    action == "create" ? campaignStatuses.started : campaignStatuses.drafted;
  request.body.CampaignDetails.projectType =
    request?.body?.CampaignDetails?.projectType || null;
  request.body.CampaignDetails.hierarchyType =
    request?.body?.CampaignDetails?.hierarchyType || null;
  request.body.CampaignDetails.parentId =
    request?.body?.CampaignDetails?.parentId || null;
  request.body.CampaignDetails.additionalDetails =
    request?.body?.CampaignDetails?.additionalDetails || {};
  request.body.CampaignDetails.startDate =
    request?.body?.CampaignDetails?.startDate || null;
  request.body.CampaignDetails.endDate =
    request?.body?.CampaignDetails?.endDate || null;
  request.body.CampaignDetails.auditDetails = {
    createdBy: request?.body?.RequestInfo?.userInfo?.uuid,
    createdTime: Date.now(),
    lastModifiedBy: request?.body?.RequestInfo?.userInfo?.uuid,
    lastModifiedTime: Date.now(),
  };
  await enrichRootProjectIdAndBoundaryCode(request.body?.CampaignDetails);
  const topic = firstPersist
    ? config?.kafka?.KAFKA_SAVE_PROJECT_CAMPAIGN_DETAILS_TOPIC
    : config?.kafka?.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC;
  delete request.body.CampaignDetails.codesTargetMapping;
  const produceMessage: any = {
    CampaignDetails: request?.body?.CampaignDetails,
  };
  await produceModifiedMessages(produceMessage, topic, request?.body?.CampaignDetails?.tenantId);
  delete request.body.CampaignDetails.campaignDetails;
}

async function processAppConfig(campaignDetails: any, RequestInfo: any) {
  try {
    if (!campaignDetails?.parentId) {
      if (campaignDetails?.additionalDetails?.cloneFrom) {
        await createAppConfigFromClone(campaignDetails?.tenantId, campaignDetails?.campaignNumber, campaignDetails?.additionalDetails?.cloneFrom, RequestInfo);
      }
      else {
        await createAppConfig(campaignDetails?.tenantId, campaignDetails?.campaignNumber, campaignDetails?.projectType, RequestInfo);
      }
    }
  } catch (error) {
    logger.warn("Error while processing app config", error);
  }
}

export async function enrichAndPersistCampaignForCreateViaFlow2(
  campaignDetails: any,
) {
  campaignDetails.campaignDetails = {
    deliveryRules: campaignDetails?.deliveryRules || [],
    resources: campaignDetails?.resources || [],
    boundaries: campaignDetails?.boundaries || [],
  };
  campaignDetails.parentId = campaignDetails?.parentId || null;
  campaignDetails.boundaryCode = campaignDetails?.boundaryCode || getRootBoundaryCode(campaignDetails?.boundaries) || null;
  campaignDetails.projectId = campaignDetails?.projectId || await getRootProjectIdViaCampaignNumber(campaignDetails?.campaignNumber, campaignDetails?.boundaryCode, campaignDetails?.tenantId);

  campaignDetails.status =
    campaignDetails.action == "create" ? campaignStatuses.inprogress : campaignStatuses.started;
  const topic = config?.kafka?.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC;
  const produceMessage: any = {
    CampaignDetails: campaignDetails,
  };
  await produceModifiedMessages(produceMessage, topic, campaignDetails?.tenantId);
}

async function getRootProjectIdViaCampaignNumber(campaignNumber: string, boundaryCode: string, tenantId: string) {
  if (!campaignNumber || !boundaryCode) {
    return null;
  }
  const rootProjectData = await getRelatedDataWithCampaign("boundary", campaignNumber, tenantId, dataRowStatuses.completed, boundaryCode);
  return rootProjectData?.length ? rootProjectData[0]?.uniqueIdAfterProcess : null;
}

function enrichInnerCampaignDetails(
  request: any,
  updatedInnerCampaignDetails: any
) {
  updatedInnerCampaignDetails.resources =
    request?.body?.CampaignDetails?.resources || [];
  updatedInnerCampaignDetails.deliveryRules =
    request?.body?.CampaignDetails?.deliveryRules || [];
  updatedInnerCampaignDetails.boundaries =
    request?.body?.CampaignDetails?.boundaries || [];
}

async function enrichAndPersistCampaignForUpdate(
  request: any,
  firstPersist: boolean = false
) {
  const action = request?.body?.CampaignDetails?.action;
  // const boundaries = request?.body?.boundariesCombined;
  // const existingCampaignDetails = request?.body?.ExistingCampaignDetails;
  // callGenerateIfBoundariesOrCampaignTypeDiffer(request);
  // if (existingCampaignDetails) {
  //   if (areBoundariesSame(existingCampaignDetails?.boundaries, boundaries)) {
  //     updateTargetColumnsIfDeliveryConditionsDifferForSMC(request);
  //   }
  // }
  const ExistingCampaignDetails = request?.body?.ExistingCampaignDetails;
  var updatedInnerCampaignDetails = {};
  enrichInnerCampaignDetails(request, updatedInnerCampaignDetails);
  request.body.CampaignDetails.campaignNumber =
    ExistingCampaignDetails?.campaignNumber;
  request.body.CampaignDetails.campaignDetails = updatedInnerCampaignDetails;
  request.body.CampaignDetails.parentId = request?.body?.CampaignDetails?.parentId || null;
  request.body.CampaignDetails.status =
    action == "create"
      ? campaignStatuses.started
      : campaignStatuses.drafted;
  request.body.CampaignDetails.startDate =
    request?.body?.CampaignDetails?.startDate ||
    ExistingCampaignDetails?.startDate ||
    null;
  request.body.CampaignDetails.endDate =
    request?.body?.CampaignDetails?.endDate ||
    ExistingCampaignDetails?.endDate ||
    null;
  request.body.CampaignDetails.projectType = request?.body?.CampaignDetails
    ?.projectType
    ? request?.body?.CampaignDetails?.projectType
    : ExistingCampaignDetails?.projectType;
  request.body.CampaignDetails.hierarchyType = request?.body?.CampaignDetails
    ?.hierarchyType
    ? request?.body?.CampaignDetails?.hierarchyType
    : ExistingCampaignDetails?.hierarchyType;
  request.body.CampaignDetails.additionalDetails = request?.body
    ?.CampaignDetails?.additionalDetails
    ? request?.body?.CampaignDetails?.additionalDetails
    : ExistingCampaignDetails?.additionalDetails;
  request.body.CampaignDetails.auditDetails = {
    createdBy: ExistingCampaignDetails?.createdBy,
    createdTime: ExistingCampaignDetails?.createdTime,
    lastModifiedBy: request?.body?.RequestInfo?.userInfo?.uuid,
    lastModifiedTime: Date.now(),
  };
  await enrichRootProjectIdAndBoundaryCode(request.body?.CampaignDetails);
  delete request.body.CampaignDetails.codesTargetMapping;
  const producerMessage: any = {
    CampaignDetails: request?.body?.CampaignDetails,
  };
  await produceModifiedMessages(
    producerMessage,
    config?.kafka?.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC,
    request?.body?.CampaignDetails?.tenantId
  );
  // delete request.body.ExistingCampaignDetails;
  delete request.body.CampaignDetails.campaignDetails;
}

async function makeParentInactiveOrActive(requestBody: any, active: boolean) {
  let parentCampaign = requestBody?.parentCampaign;
  parentCampaign.isActive = active;
  parentCampaign.parentId = parentCampaign?.parentId || null;
  parentCampaign.campaignDetails = {
    deliveryRules: parentCampaign?.deliveryRules || [],
    resources: parentCampaign?.resources || [],
    boundaries: parentCampaign?.boundaries || [],
  };
  parentCampaign.auditDetails.lastModifiedTime = Date.now();
  parentCampaign.auditDetails.lastModifiedBy =
    requestBody?.RequestInfo?.userInfo?.uuid;
  const produceMessage: any = {
    CampaignDetails: parentCampaign,
  };
  await produceModifiedMessages(
    produceMessage,
    config?.kafka?.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC,
    parentCampaign?.tenantId
  );
}

function getCreateResourceIds(resources: any[]) {
  return resources
    .filter(
      (resource: any) =>
        typeof resource.createResourceId === "string" &&
        resource.createResourceId.trim() !== ""
    )
    .map((resource: any) => {
      const resourceId = resource.createResourceId;
      return resourceId;
    });
}

async function persistForCampaignProjectMapping(
  request: any,
  createResourceDetailsIds: any,
  localizationMap?: any
) {
  if (createResourceDetailsIds && request?.body?.CampaignDetails?.projectId) {
    var requestBody: any = {
      RequestInfo: request?.body?.RequestInfo,
      Campaign: {},
    };
    if (request?.body?.ExistingCampaignDetails) {
      delete request.body.ExistingCampaignDetails;
    }
    requestBody.Campaign.id = request?.body?.CampaignDetails?.id;
    // requestBody.Campaign.newlyCreatedBoundaryProjectMap =
    //   request?.body?.newlyCreatedBoundaryProjectMap;
    requestBody.Campaign.hierarchyType =
      request?.body?.CampaignDetails?.hierarchyType;
    requestBody.Campaign.tenantId = request?.body?.CampaignDetails?.tenantId;
    requestBody.Campaign.campaignName =
      request?.body?.CampaignDetails?.campaignName;
    requestBody.Campaign.boundaryCode =
      request?.body?.CampaignDetails?.boundaryCode;
    requestBody.Campaign.startDate = request?.body?.CampaignDetails?.startDate;
    requestBody.Campaign.endDate = request?.body?.CampaignDetails?.endDate;
    requestBody.Campaign.projectType =
      request?.body?.CampaignDetails?.projectType;
    requestBody.Campaign.additionalDetails =
      request?.body?.CampaignDetails?.additionalDetails;
    requestBody.Campaign.deliveryRules =
      request?.body?.CampaignDetails?.deliveryRules;
    requestBody.Campaign.rootProjectId =
      request?.body?.CampaignDetails?.projectId;
    requestBody.Campaign.resourceDetailsIds = createResourceDetailsIds;
    requestBody.CampaignDetails = request?.body?.CampaignDetails;
    requestBody.parentCampaign = request?.body?.parentCampaign;
    var updatedInnerCampaignDetails = {};
    enrichInnerCampaignDetails(request, updatedInnerCampaignDetails);
    requestBody.CampaignDetails = request?.body?.CampaignDetails;
    requestBody.CampaignDetails.campaignDetails = updatedInnerCampaignDetails;
    // requestBody.localizationMap = localizationMap
    logger.info("Persisting CampaignProjectMapping...");
    logger.debug(
      `CampaignProjectMapping: ${getFormattedStringForDebug(requestBody)}`
    );
    await produceModifiedMessages(
      requestBody,
      config?.kafka?.KAFKA_START_CAMPAIGN_MAPPING_TOPIC,
      request?.body?.CampaignDetails?.tenantId
    );
  }
}

function removeBoundariesFromRequest(request: any) {
  const boundaries = request?.body?.CampaignDetails?.boundaries;
  if (boundaries && Array.isArray(boundaries) && boundaries?.length > 0) {
    request.body.CampaignDetails.boundaries = boundaries?.filter(
      (boundary: any) => !boundary?.insertedAfter
    );
  }
}

async function enrichAndPersistProjectCampaignForFirst(
  request: any,
  actionInUrl: any,
  firstPersist: boolean = false,
  localizationMap?: any
) {
  removeBoundariesFromRequest(request);
  if (actionInUrl == "create") {
    await enrichAndPersistCampaignForCreate(request, firstPersist);
  } else if (actionInUrl == "update") {
    await enrichAndPersistCampaignForUpdate(request, firstPersist);
  }
  if (request?.body?.parentCampaign?.isActive) {
    await makeParentInactiveOrActive(request?.body, false);
  }
}

async function enrichAndPersistProjectCampaignRequest(
  request: any,
  actionInUrl: any,
  firstPersist: boolean = false,
  localizationMap?: any
) {
  var createResourceDetailsIds: any[] = [];
  if (
    request?.body?.CampaignDetails?.resources &&
    Array.isArray(request?.body?.CampaignDetails?.resources) &&
    request?.body?.CampaignDetails?.resources?.length > 0 &&
    request?.body?.CampaignDetails?.action == "create"
  ) {
    createResourceDetailsIds = getCreateResourceIds(
      request?.body?.CampaignDetails?.resources
    );
  }
  // removeBoundariesFromRequest(request);
  if (actionInUrl == "create") {
    await enrichAndPersistCampaignForCreate(request, firstPersist);
  } else if (actionInUrl == "update") {
    await enrichAndPersistCampaignForUpdate(request, firstPersist);
  }
  if (request?.body?.CampaignDetails?.action == "create") {
    await persistForCampaignProjectMapping(
      request,
      createResourceDetailsIds,
      localizationMap
    );
  }
}

function getChildParentMap(modifiedBoundaryData: any) {
  const childParentMap = new Map<
    { key: string; value: string },
    { key: string; value: string } | null
  >();
  const stringifiedMap = new Set<string>(); // To avoid deep _.isEqual() lookup
  modifiedBoundaryData.forEach((row: any[]) => {
    for (let j = row.length - 1; j >= 0; j--) {
      const child = row[j];
      const parent = j - 1 >= 0 ? row[j - 1] : null;
      const childIdentifier = { key: child.key, value: child.value };
      const parentIdentifier = parent ? { key: parent.key, value: parent.value } : null;
      const lookupKey = parentIdentifier
        ? `${child.key}|${child.value}__${parent.key}|${parent.value}`
        : `${child.key}|${child.value}__null`;
      if (!stringifiedMap.has(lookupKey)) {
        childParentMap.set(childIdentifier, parentIdentifier);
        stringifiedMap.add(lookupKey);
      }
    }
  });
  return childParentMap;
}

function getCodeMappingsOfExistingBoundaryCodes(withBoundaryCode: any[], localizationMap: any) {
  const countMap = new Map<{ key: string; value: string }, number>();
  const mappingMap = new Map<{ key: string; value: string }, string>();


  withBoundaryCode.forEach((row: any[]) => {
    const effectiveRow = [];
    for (const item of row) {
      if (item.key === getLocalizedName(config?.boundary?.boundaryCode, localizationMap)) {
        effectiveRow.push(item);
        break;

      }
      effectiveRow.push(item);
    }
    const len = effectiveRow.length;
    if (len >= 3) {
      let grandParentFound = false;
      const grandParent = effectiveRow[len - 3];
      if (findMapValue(mappingMap, grandParent)) {
        const countMapArray = Array.from(countMap.entries());
        for (const [key, value] of countMapArray) {
          if (_.isEqual(key, grandParent)) {
            countMap.set(key, value + 1);
            grandParentFound = true;
            break;
          }
        }
        if (grandParentFound == false) {
          countMap.set(grandParent, 1);
        }
      }
    }
    mappingMap.set(effectiveRow[len - 2], effectiveRow[len - 1].value);
  });
  return { mappingMap, countMap };
}

function addBoundaryCodeToData(
  withBoundaryCode: any[],
  withoutBoundaryCode: any[],
  boundaryMap: Map<any, any>,
  hierarchy: any,
  localizationMap: any
) {
  const boundaryKey = getLocalizedName(config?.boundary?.boundaryCode, localizationMap);

  // Part 1: extract boundary codes directly
  // const modifiedBoundaryDataWithBoundaryCode = withBoundaryCode.map((array) => {
  //   return array.map((obj: any) => {
  //     if (obj.key === boundaryKey) {
  //       return obj.value; // replace with value (just the boundary code)
  //     } else {
  //       return obj;
  //     }
  //   });
  // });

  // Part 2: for rows without boundary code
  const boundaryDataForWithoutBoundaryCode = withoutBoundaryCode.map((row: any[]) => {
    let boundaryName: string | undefined;

    for (let level of hierarchy) {
      const match = row.find(obj => obj.key === level && obj.value);
      if (match) {
        boundaryName = match; // keep updating as we go down hierarchy
      }
    }

    const boundaryCode = findMapValue(boundaryMap, boundaryName);
    const boundaryCodeObj = { key: boundaryKey, value: boundaryCode };
    return [...row, boundaryCodeObj]; // just append the boundary code at the end
  });


  const boundaryDataForSheet = [
    ...withBoundaryCode,
    ...boundaryDataForWithoutBoundaryCode,
  ];

  return boundaryDataForSheet;
}

function prepareDataForExcel(
  boundaryDataForSheet: any[],
  hierarchy: any[],
  boundaryMap: any,
  localizationMap: any
) {
  const boundaryKey = getLocalizedName(config?.boundary?.boundaryCode, localizationMap);

  const data = boundaryDataForSheet.map((row: any[]) => {
    const rowMap = new Map<string, any>();
    row.forEach(obj => rowMap.set(obj.key, obj.value));

    // 1. Pick hierarchy values in order
    const hierarchyValues = hierarchy.map(level => rowMap.get(level) || "");

    // 2. Get boundary code value
    const boundaryCode = rowMap.get(boundaryKey) || "";

    // 3. Get remaining key-value pairs (excluding hierarchy + boundaryKey)
    const excludedKeys = new Set([...hierarchy, boundaryKey]);
    const remainingValues = row
      .filter(obj => !excludedKeys.has(obj.key))
      .map(obj => obj.value || "");

    // 4. Final row structure: hierarchy values + boundary code + remaining key-value pairs
    return [...hierarchyValues, boundaryCode, ...remainingValues];
  });

  return data;
}
function extractCodesFromBoundaryRelationshipResponse(boundaries: any[]): any {
  const codes = new Set();
  for (const boundary of boundaries) {
    codes.add(boundary.code); // Add code to the Set
    if (boundary.children && boundary.children.length > 0) {
      const childCodes = extractCodesFromBoundaryRelationshipResponse(
        boundary.children
      ); // Recursively get child codes
      childCodes.forEach((code: any) => codes.add(code)); // Add child codes to the Set
    }
  }
  return codes;
}

async function getTotalCount(campaignDetails: any) {
  const { tenantId, pagination, ids, ...searchFields } = campaignDetails;
  let conditions = [];
  let values = [tenantId];
  let index = 2;
  const campaignsIncludeDates = searchFields?.campaignsIncludeDates;

  for (const field in searchFields) {
    if (searchFields[field] !== undefined && field != "campaignsIncludeDates"  && field != "isLikeSearch" && field != "isOverrideDatesFromProject" ){
      if (field === "startDate") {
        const startDateSign = campaignsIncludeDates ? "<=" : ">=";
        conditions.push(`startDate ${startDateSign} $${index}`);
        values.push(searchFields[field]);
        index++;
      } else if (field === "endDate") {
        const endDateSign = campaignsIncludeDates ? ">=" : "<=";
        conditions.push(`endDate ${endDateSign} $${index}`);
        values.push(searchFields[field]);
        index++;
      } else if (field === "campaignName") {
        if (searchFields?.isLikeSearch) {
          conditions.push(`campaignName ILIKE '%' || $${index} || '%'`);
        } else {
          conditions.push(`campaignName = $${index}`);
        }
        values.push(searchFields[field]);
        index++;
      } else if (field != "status") {
        conditions.push(`${field} = $${index}`);
        values.push(searchFields[field]);
        index++;
      }
    }
  }
  const tableName = getTableName(config?.DB_CONFIG.DB_CAMPAIGN_DETAILS_TABLE_NAME, tenantId);
  let query = `
        SELECT count(*)
        FROM ${tableName}
        WHERE tenantId = $1
    `;

  if (ids && ids.length > 0) {
    const idParams = ids.map((id: any, i: any) => `$${index + i}`);
    query += ` AND id IN (${idParams.join(", ")})`;
    values.push(...ids);
    index = index + ids.length;
  } else {
    // If no IDs are provided, filter by isActive = true
    query += ` AND isActive = true`;
  }
  var status = searchFields?.status;
  if (status) {
    if (typeof status === "string") {
      status = [status]; // Convert string to array
    }
    const statusParams = status.map((param: any, i: any) => `$${index + i}`); // Increment index for each parameter
    query += ` AND status IN (${statusParams.join(", ")})`;
    values.push(...status);
  }

  if (conditions.length > 0) {
    query += ` AND ${conditions.join(" AND ")}`;
  }
  const queryResult = await executeQuery(query, values);
  const totalCount = parseInt(queryResult.rows[0].count, 10);
  return totalCount;
}

async function searchProjectCampaignResourcData(campaignDetails: any, request?: any) {
  // const CampaignDetails = request.body.CampaignDetails;
  const { tenantId, pagination, ids, ...searchFields } = campaignDetails;
  const queryData = buildSearchQuery(tenantId, pagination, ids, searchFields);
  const totalCount = await getTotalCount(campaignDetails);
  const responseData: any[] = await executeSearchQuery(
    queryData.query,
    queryData.values
  );

  const projectIds = Array.from(
    new Set(responseData.map(d => d?.projectId).filter(Boolean))
  );

  // Step 2: Bulk fetch all project details
  let projectsMap = new Map<string, { startDate: number, endDate: number }>();

  if (searchFields?.isOverrideDatesFromProject) {
    if (projectIds.length > 0) {
      try {
        const projects = await fetchProjectsWithProjectId(request, projectIds, tenantId, false); // returns array of projects

        // Step 3: Build map of referenceId -> { startDate, endDate }
        for (const project of projects) {
          if (project?.referenceID) {
            projectsMap.set(project.referenceID, {
              startDate: project.startDate,
              endDate: project.endDate,
            });
          }
        }
      } catch (err) {
        console.error("Bulk project fetch failed while searching campaign with config overrideDatesFromProject enabled", err);
      }
    }
  }
  // TODO @ashish check the below code looks like duplicate
  for (const data of responseData) {
    data.resources = data?.campaignDetails?.resources;
    data.boundaries = data?.campaignDetails?.boundaries;
    data.deliveryRules = data?.campaignDetails?.deliveryRules;
    delete data.campaignDetails;
    data.auditDetails = {
      createdBy: data?.createdBy,
      lastModifiedBy: data?.lastModifiedBy,
      createdTime: data?.createdTime,
      lastModifiedTime: data?.lastModifiedTime,
    };
    delete data.createdBy;
    delete data.lastModifiedBy;
    delete data.createdTime;
    delete data.lastModifiedTime;

    if (searchFields?.isOverrideDatesFromProject) {
      const projDates = projectsMap.get(data?.campaignNumber);
      if (projDates) {
        if (projDates.startDate !== undefined && data.startDate !== undefined && projDates.startDate !== data.startDate) {
          data.startDate = projDates.startDate;
        }
        if (projDates.endDate !== undefined && data.endDate !== undefined && projDates.endDate !== data.endDate) {
          data.endDate = projDates.endDate;
        }
      }
    }
  }
  return { responseData, totalCount };
}

function buildSearchQuery(
  tenantId: string,
  pagination: any,
  ids: string[],
  searchFields: any
): { query: string; values: any[] } {
  let conditions = [];
  let values = [tenantId];
  let index = 2;
  const campaignsIncludeDates = searchFields?.campaignsIncludeDates;

  for (const field in searchFields) {
    if (searchFields[field] !== undefined && field != "campaignsIncludeDates" && field != "isLikeSearch" && field != "isOverrideDatesFromProject" ) {
      if (field === "startDate") {
        const startDateSign = campaignsIncludeDates ? "<=" : ">=";
        conditions.push(`startDate ${startDateSign} $${index}`);
        values.push(searchFields[field]);
        index++;
      } else if (field === "endDate") {
        const endDateSign = campaignsIncludeDates ? ">=" : "<=";
        conditions.push(`endDate ${endDateSign} $${index}`);
        values.push(searchFields[field]);
        index++;
      } else if (field === "campaignName") {
        if (searchFields?.isLikeSearch) {
          conditions.push(`campaignName ILIKE '%' || $${index} || '%'`);
        } else {
          conditions.push(`campaignName = $${index}`);
        }
        values.push(searchFields[field]);
        index++;
      } else if (field != "status") {
        conditions.push(`${field} = $${index}`);
        values.push(searchFields[field]);
        index++;
      }
    }
  }
  const tableName = getTableName(config?.DB_CONFIG.DB_CAMPAIGN_DETAILS_TABLE_NAME, tenantId);
  // Build the base
  let query = `
        SELECT *
        FROM ${tableName}
        WHERE tenantId = $1
    `;

  if (ids && ids.length > 0) {
    const idParams = ids.map((id: any, i: any) => `$${index + i}`);
    query += ` AND id IN (${idParams.join(", ")})`;
    values.push(...ids);
    index = index + ids.length;
  } else {
    // If no IDs are provided, filter by isActive = true
    query += ` AND isActive = true`;
  }

  var status = searchFields?.status;
  if (status) {
    if (typeof status === "string") {
      status = [status]; // Convert string to array
    }
    const statusParams = status.map((param: any, i: any) => `$${index + i}`); // Increment index for each parameter
    query += ` AND status IN (${statusParams.join(", ")})`;
    values.push(...status);
  }

  if (conditions.length > 0) {
    query += ` AND ${conditions.join(" AND ")}`;
  }

  if (pagination) {
    query += "\n";

    if (pagination.sortBy) {
      query += `ORDER BY ${pagination.sortBy}`;
      if (pagination.sortOrder) {
        query += ` ${pagination.sortOrder.toUpperCase()}`;
      }
      query += "\n";
    }

    if (pagination.limit !== undefined) {
      query += `LIMIT ${pagination.limit}`;
      if (pagination.offset !== undefined) {
        query += ` OFFSET ${pagination.offset}`;
      }
      query += "\n";
    }
  }

  return { query, values };
}

async function executeSearchQuery(query: string, values: any[]) {
  const queryResult = await executeQuery(query, values);
  return campaignDetailsTransformer(queryResult?.rows);
}

async function processDataSearchRequest(request: any) {
  const { SearchCriteria } = request.body;
  const query = buildWhereClauseForDataSearch(SearchCriteria);
  const queryResult = await executeQuery(query.query, query.values);
  request.body.ResourceDetails = genericResourceTransformer(queryResult?.rows);
}

function buildWhereClauseForDataSearch(SearchCriteria: any): {
  query: string;
  values: any[];
} {
  const { id, tenantId, type, status, hierarchyType } = SearchCriteria;
  let conditions = [];
  let values = [];

  // Check for id
  if (id && id.length > 0) {
    conditions.push(`id = ANY($${values.length + 1})`);
    values.push(id);
  }

  // Check for tenantId
  if (tenantId) {
    conditions.push(`tenantId = $${values.length + 1}`);
    values.push(tenantId);
  }

  // Check for type
  if (type) {
    conditions.push(`type = $${values.length + 1}`);
    values.push(type);
  }

  // Check for status
  if (status) {
    conditions.push(`status = $${values.length + 1}`);
    values.push(status);
  }

  // Check for hierarchyType
  if (hierarchyType) {
    conditions.push(`hierarchyType = $${values.length + 1}`);
    values.push(hierarchyType);
  }

  // Build the WHERE clause
  const whereClause =
    conditions.length > 0 ? `WHERE ${conditions.join(" AND ")}` : "";

  // Return the query and values array
  const tableName = getTableName(config?.DB_CONFIG.DB_RESOURCE_DETAILS_TABLE_NAME, tenantId);
  return {
    query: `
            SELECT *
            FROM ${tableName}
            ${whereClause};`,
    values,
  };
}

function mapBoundariesParent(boundaryResponse: any, request: any, parent: any) {
  if (!boundaryResponse) return;

  request.body.boundaryProjectMapping[boundaryResponse.code] = {
    parent: parent || null,
    projectId: null,
  };
  if (
    boundaryResponse?.children &&
    Array.isArray(boundaryResponse?.children) &&
    boundaryResponse?.children?.length > 0
  ) {
    for (const child of boundaryResponse.children) {
      mapBoundariesParent(child, request, boundaryResponse.code);
    }
  }
}

function mapTargets(boundaryResponses: any, codesTargetMapping: any) {
  if (!boundaryResponses || !codesTargetMapping) return;

  // Helper function to map individual boundaries
  const mapBoundary = (boundary: any) => {
    if (!boundary.children || boundary.children.length === 0) {
      // If no children, simply return the target value object or default to empty object
      const targetValue = codesTargetMapping[boundary.code];
      return targetValue || {};
    }

    // Initialize a new object to accumulate total target values from children
    let totalTargetValue: any = {};

    // Iterate through each child and accumulate their target values
    for (const child of boundary.children) {
      const childTargetValue = mapBoundary(child);

      // Accumulate the child target values into the total target value
      for (const key in childTargetValue) {
        if (childTargetValue.hasOwnProperty(key)) {
          // Initialize key in totalTargetValue if it doesn't exist
          totalTargetValue[key] = (totalTargetValue[key] || 0) + childTargetValue[key];
        }
      }
    }

    // Store the accumulated total target value for the current boundary
    codesTargetMapping[boundary.code] = totalTargetValue;
    return totalTargetValue;
  };

  // Map each boundary response
  for (const boundaryResponse of boundaryResponses) {
    mapBoundary(boundaryResponse);
  }
}

export async function populateBoundariesRecursively(
  boundaryResponse: any,
  boundaries: any,
  includeAllChildren: any,
  boundaryCodes: any,
  boundaryChildren: any,
  parent: any = null
) {
  if (!boundaryResponse) return;

  if (!boundaryCodes.has(boundaryResponse.code)) {
    boundaries.push({
      code: boundaryResponse?.code,
      type: boundaryResponse?.boundaryType,
      insertedAfter: true,
      parent: parent
    });
    boundaryCodes.add(boundaryResponse?.code);
  }

  if (
    includeAllChildren &&
    boundaryResponse?.children &&
    Array.isArray(boundaryResponse?.children) &&
    boundaryResponse?.children?.length > 0
  ) {
    for (const child of boundaryResponse.children) {
      await populateBoundariesRecursively(
        child,
        boundaries,
        true,
        boundaryCodes,
        boundaryChildren,
        boundaryResponse.code
      );
    }
  } else if (
    boundaryResponse?.children &&
    Array.isArray(boundaryResponse?.children) &&
    boundaryResponse?.children?.length > 0
  ) {
    for (const child of boundaryResponse.children) {
      if (boundaryCodes.has(child.code) && boundaryChildren[child.code]) {
        await populateBoundariesRecursively(
          child,
          boundaries,
          true,
          boundaryCodes,
          boundaryChildren,
          boundaryResponse.code
        );
      } else if (boundaryCodes.has(child.code)) {
        await populateBoundariesRecursively(
          child,
          boundaries,
          false,
          boundaryCodes,
          boundaryChildren,
          boundaryResponse.code
        );
      }
    }
  }
}


async function processBoundary(
  boundaryResponse: any,
  boundaries: any,
  includeAllChildren: any,
  boundaryCodes: any,
  boundaryChildren: any
) {
  if (!boundaryResponse) return;
  if (!boundaryCodes.has(boundaryResponse.code)) {
    boundaries.push({
      code: boundaryResponse?.code,
      type: boundaryResponse?.boundaryType,
      insertedAfter: true
    });
    boundaryCodes.add(boundaryResponse?.code);
  }
  if (
    includeAllChildren &&
    boundaryResponse?.children &&
    Array.isArray(boundaryResponse?.children) &&
    boundaryResponse?.children?.length > 0
  ) {
    for (const child of boundaryResponse.children) {
      processBoundary(child, boundaries, true, boundaryCodes, boundaryChildren);
    }
  } else if (
    boundaryResponse?.children &&
    Array.isArray(boundaryResponse?.children) &&
    boundaryResponse?.children?.length > 0
  ) {
    for (const child of boundaryResponse.children) {
      if (boundaryCodes.has(child.code) && boundaryChildren[child.code]) {
        processBoundary(
          child,
          boundaries,
          true,
          boundaryCodes,
          boundaryChildren
        );
      } else if (boundaryCodes.has(child.code)) {
        processBoundary(
          child,
          boundaries,
          false,
          boundaryCodes,
          boundaryChildren
        );
      }
    }
  }
}

async function addBoundaries(
  request: any,
  boundaryResponse: any,
  boundaryChildren: any
) {
  var boundaries = request?.body?.boundariesCombined;
  var boundaryCodes = new Set(boundaries.map((boundary: any) => boundary.code));
  await processBoundary(
    boundaryResponse,
    boundaries,
    boundaryChildren[boundaryResponse?.code],
    boundaryCodes,
    boundaryChildren
  );
  request.body.boundariesCombined = boundaries;
}

async function addBoundariesForData(request: any, CampaignDetails: any) {
  // var { boundaries } = CampaignDetails;
  var boundaries = await getBoundariesFromCampaignSearchResponse(
    request,
    CampaignDetails
  );
  const rootBoundary = getRootBoundaryCode(boundaries);
  if (rootBoundary) {
    const params = {
      tenantId: request?.body?.ResourceDetails?.tenantId,
      codes: rootBoundary,
      hierarchyType: request?.body?.ResourceDetails?.hierarchyType,
      includeChildren: true,
    };
    const header = {
      ...defaultheader,
      cachekey: `boundaryRelationShipSearch${params?.hierarchyType}${params?.tenantId
        }${params.codes || ""}${params?.includeChildren || ""}`,
    };
    const boundaryResponse = await httpRequest(
      config.host.boundaryHost + config.paths.boundaryRelationship,
      request.body,
      params,
      undefined,
      undefined,
      header
    );
    if (boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0]) {
      var boundaryChildren = boundaries.reduce((acc: any, boundary: any) => {
        acc[boundary.code] = boundary?.includeAllChildren;
        return acc;
      }, {});
      var boundaryCodes = new Set(
        boundaries.map((boundary: any) => boundary.code)
      );
      await processBoundary(
        boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0],
        boundaries,
        boundaryChildren[
        boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0]?.code
        ],
        boundaryCodes,
        boundaryChildren
      );
      CampaignDetails.boundaries = boundaries;
    } else {
      throwError(
        "COMMON",
        500,
        "INTERNAL_SERVER_ERROR",
        "Some internal server error occured during boundary validation."
      );
    }
  } else {
    throwError(
      "COMMON",
      500,
      "INTERNAL_SERVER_ERROR",
      "There is no root boundary for this campaign."
    );
  }
}

function reorderBoundariesWithParentFirst(
  boundaries: any[],
  boundaryProjectMapping: any
) {
  const startTime = Date.now();

  const boundaryGraph = new Map();
  const inDegree = new Map();

  logger.info(`Started processing ${boundaries.length} boundaries...`);

  // Step 1: Build the graph and calculate in-degrees
  boundaries.forEach((boundary) => {
    const code = boundary.code;
    boundaryGraph.set(code, []);
    inDegree.set(code, 0); // Initialize in-degree for each boundary
  });

  boundaries.forEach((boundary) => {
    const code = boundary.code;
    const parentCode = boundaryProjectMapping[code]?.parent;

    if (parentCode) {
      boundaryGraph.get(parentCode).push(code); // Parent points to child
      inDegree.set(code, inDegree.get(code) + 1); // Increment in-degree of child
    }
  });

  const graphConstructionTime = Date.now();
  logger.info(
    `Graph construction completed. Time taken: ${(
      (graphConstructionTime - startTime) / 1000
    ).toFixed(2)} seconds.`
  );

  // Step 2: Perform topological sort using Kahn's Algorithm
  const queue: any = [];
  const sortedBoundaries = [];

  // Enqueue nodes with 0 in-degree
  boundaries.forEach((boundary) => {
    if (inDegree.get(boundary.code) === 0) {
      queue.push(boundary);
    }
  });

  let nodesProcessed = 0;
  while (queue.length > 0) {
    const currentBoundary = queue.shift();
    sortedBoundaries.push(currentBoundary);
    nodesProcessed++;

    // Log progress periodically
    if (nodesProcessed % 500 === 0) {
      const elapsed = (Date.now() - startTime) / 1000;
      const avgTimePerBoundary = elapsed / nodesProcessed;
      const estimatedRemaining = avgTimePerBoundary * (boundaries.length - nodesProcessed);
      logger.info(
        `Processed ${nodesProcessed} boundaries. Elapsed: ${elapsed.toFixed(
          2
        )} seconds. Estimated time remaining: ${estimatedRemaining.toFixed(2)} seconds.`
      );
    }

    const children = boundaryGraph.get(currentBoundary.code) || [];
    children.forEach((childCode: any) => {
      inDegree.set(childCode, inDegree.get(childCode) - 1);
      if (inDegree.get(childCode) === 0) {
        queue.push(
          boundaries.find((boundary) => boundary.code === childCode)
        );
      }
    });
  }

  // Check for cycles (remaining nodes with non-zero in-degree)
  if (sortedBoundaries.length !== boundaries.length) {
    throw new Error(
      "Cycle detected in the boundary-parent relationships. Reordering failed."
    );
  }

  const endTime = Date.now();
  logger.info(
    `Reordering completed. Processed ${boundaries.length} boundaries in ${(
      (endTime - startTime) / 1000
    ).toFixed(2)} seconds.`
  );

  return sortedBoundaries;
}

async function reorderBoundariesOfDataAndValidate(
  request: any,
  localizationMap?: any
) {
  if (request?.body?.ResourceDetails?.campaignId) {
    // const searchBody = {
    //   RequestInfo: request?.body?.RequestInfo,
    const CampaignDetails = {
      ids: [request?.body?.ResourceDetails?.campaignId],
      tenantId: request?.body?.ResourceDetails?.tenantId,
    }
    // };
    // const req: any = replicateRequest(request, searchBody);
    const response = await searchProjectTypeCampaignService(CampaignDetails);
    if (response?.CampaignDetails?.[0]) {
      const CampaignDetails = response?.CampaignDetails?.[0];
      await addBoundariesForData(request, CampaignDetails);
      logger.debug(
        "Boundaries after addition " +
        getFormattedStringForDebug(CampaignDetails?.boundaries)
      );
      await validateBoundaryOfResouces(
        CampaignDetails,
        request,
        localizationMap
      );
    } else {
      throwError(
        "CAMPAIGN",
        400,
        "CAMPAIGN_NOT_FOUND",
        "Campaign not found while Validating sheet boundaries"
      );
    }
  }
}

async function reorderBoundaries(request: any, localizationMap?: any) {
  // var { boundaries } = request?.body?.CampaignDetails;
  var boundaries = request?.body?.boundariesCombined;
  const rootBoundary = getRootBoundaryCode(boundaries);
  request.body.boundaryProjectMapping = {};
  if (rootBoundary) {
    const params = {
      tenantId: request?.body?.CampaignDetails?.tenantId,
      codes: rootBoundary,
      hierarchyType: request?.body?.CampaignDetails?.hierarchyType,
      includeChildren: true,
    };
    const header = {
      ...defaultheader,
      cachekey: `boundaryRelationShipSearch${params?.hierarchyType}${params?.tenantId
        }${params.codes || ""}${params?.includeChildren || ""}`,
    };
    const boundaryResponse = await httpRequest(
      config.host.boundaryHost + config.paths.boundaryRelationship,
      request.body,
      params,
      undefined,
      undefined,
      header
    );
    if (boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0]) {
      const codesTargetMapping = await getCodesTarget(request, localizationMap);
      if (codesTargetMapping) {
        mapTargets(
          boundaryResponse?.TenantBoundary?.[0]?.boundary,
          codesTargetMapping
        );
        request.body.CampaignDetails.codesTargetMapping = codesTargetMapping;
        logger.debug(
          "codesTargetMapping mapping :: " +
          getFormattedStringForDebug(codesTargetMapping)
        );
      }
      mapBoundariesParent(
        boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0],
        request,
        null
      );
      var boundaryChildren = boundaries.reduce((acc: any, boundary: any) => {
        acc[boundary.code] = boundary?.includeAllChildren;
        return acc;
      }, {});
      await addBoundaries(
        request,
        boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0],
        boundaryChildren
      );
    } else {
      throwError(
        "COMMON",
        500,
        "INTERNAL_SERVER_ERROR",
        "Some internal server error occured during boundary validation."
      );
    }
  } else {
    throwError(
      "COMMON",
      500,
      "INTERNAL_SERVER_ERROR",
      "There is no root boundary for this campaign."
    );
  }
  logger.info("Boundaries for campaign creation in received");
  logger.debug(
    "Boundaries after addition " +
    getFormattedStringForDebug(request?.body?.boundariesCombined)
  );
  const start = Date.now();
  const sortedBoundaries = reorderBoundariesWithParentFirst(
    request?.body?.boundariesCombined,
    request?.body?.boundaryProjectMapping
  );
  request.body.boundariesCombined = sortedBoundaries;
  const end = Date.now();
  logger.info(`Execution time: ${(end - start) / 1000} seconds`);
  logger.info("Reordered the Boundaries for mapping");
  logger.debug(
    "Reordered Boundaries " +
    getFormattedStringForDebug(request?.body?.boundariesCombined)
  );
  return request.body.boundariesCombined;
}

function convertToProjectsArray(Projects: any, currentArray: any = []) {
  for (const project of Projects) {
    const descendants = project?.descendants;
    delete project?.descendants;
    currentArray.push(project);
    if (descendants && Array.isArray(descendants) && descendants?.length > 0) {
      convertToProjectsArray(descendants, currentArray);
    }
  }
  return currentArray;
}

async function getRelatedProjects(request: any) {
  const { projectId, tenantId } = request?.body?.CampaignDetails;
  const projectSearchBody = {
    RequestInfo: request?.body?.RequestInfo,
    Projects: [
      {
        id: projectId,
        tenantId: tenantId,
      },
    ],
  };
  const projectSearchParams = {
    tenantId: tenantId,
    offset: 0,
    limit: 1,
    includeDescendants: true,
  };
  logger.info("Project search params " + JSON.stringify(projectSearchParams));
  const projectSearchResponse = await httpRequest(
    config?.host?.projectHost + config?.paths?.projectSearch,
    projectSearchBody,
    projectSearchParams
  );
  if (
    projectSearchResponse?.Project &&
    Array.isArray(projectSearchResponse?.Project) &&
    projectSearchResponse?.Project?.length > 0
  ) {
    return convertToProjectsArray(projectSearchResponse?.Project);
  } else {
    throwError("PROJECT", 500, "PROJECT_SEARCH_ERROR");
    return [];
  }
}

async function updateProjectDates(request: any, actionInUrl: any) {
  const { startDate, endDate, projectId } = request?.body?.CampaignDetails;
  if ((startDate || endDate) && projectId && actionInUrl == "update") {
    const projects = await getRelatedProjects(request);
    for (const project of projects) {
      project.startDate = startDate || project.startDate;
      project.endDate = endDate || project.endDate;
      delete project?.address;
    }
    logger.info(
      "Projects related to current Campaign : " + JSON.stringify(projects)
    );
    const projectUpdateBody = {
      RequestInfo: request?.body?.RequestInfo,
      Projects: projects,
    };
    const projectUpdateResponse = await httpRequest(
      config?.host?.projectHost + config?.paths?.projectUpdate,
      projectUpdateBody
    );
    if (
      projectUpdateResponse?.Project &&
      Array.isArray(projectUpdateResponse?.Project) &&
      projectUpdateResponse?.Project?.length == projects?.length
    ) {
      logger.info("Project dates updated successfully");
    } else {
      throwError("PROJECT", 500, "PROJECT_UPDATE_ERROR");
    }
  }
}

async function getCodesTarget(request: any, localizationMap?: any) {
  let boundaryCodesWhoseTargetsHasToBeUpdated: any = [];
  const { tenantId, resources } = request?.body?.CampaignDetails;
  const boundaryWithTargetResource = resources?.filter(
    (resource: any) => resource?.type == "boundaryWithTarget"
  );
  if (boundaryWithTargetResource && boundaryWithTargetResource.length > 0) {
    const fileId = boundaryWithTargetResource[0]?.filestoreId;
    const fileResponse = await httpRequest(
      config.host.filestore + config.paths.filestore + "/url",
      {},
      { tenantId: tenantId, fileStoreIds: fileId },
      "get"
    );
    if (!fileResponse?.fileStoreIds?.[0]?.url) {
      throwError("FILE", 500, "DOWNLOAD_URL_NOT_FOUND");
    }
    const codeColumnName = getLocalizedName(
      createAndSearch?.boundaryWithTarget?.boundaryValidation?.column,
      localizationMap
    );
    const targetData = await getTargetSheetDataAfterCode(
      request,
      fileResponse?.fileStoreIds?.[0]?.url,
      true,
      true,
      codeColumnName,
      localizationMap
    );
    const boundaryTargetMapping: any = {};
    // Iterate through each key in targetData
    for (const key in targetData) {
      // Iterate through each entry in the array under the current key
      targetData[key].forEach((entry: any) => {
        // Check if the entry has both "Boundary Code" and "Target at the Selected Boundary level"
        if (
          entry[codeColumnName] !== undefined &&
          entry["Target at the Selected Boundary level"] !== undefined
        ) {
          // Add the mapping to the boundaryTargetMapping object
          boundaryTargetMapping[entry[codeColumnName]] =
            entry["Target at the Selected Boundary level"];
          if (
            Object.keys(entry["Parent Target at the Selected Boundary level"]).length > 0 &&
            !_.isEqual(entry["Parent Target at the Selected Boundary level"], entry["Target at the Selected Boundary level"])
          ) {
            boundaryCodesWhoseTargetsHasToBeUpdated.push(entry[codeColumnName]);
          }
        }
      });
    }
    logger.info(
      "Boundary target mapping count" +
      Object.keys(boundaryTargetMapping)?.length
    );
    request.body.boundaryCodesWhoseTargetsHasToBeUpdated =
      boundaryCodesWhoseTargetsHasToBeUpdated;
    return boundaryTargetMapping;
  } else return null;
}


export async function processAfterPersistNew(request: any, actionInUrl: any) {
  try {
    if (request?.body?.CampaignDetails?.action == "create") {
      const locale = getLocaleFromRequest(request);
      const campaignDetails = request?.body?.CampaignDetails;
      const campaignNumber = campaignDetails?.campaignNumber;
      const tenantId = campaignDetails?.tenantId;
      const useruuid =
        request?.body?.RequestInfo?.userInfo?.uuid ||
        campaignDetails?.auditDetails?.createdBy;

      // Prepare DB setup synchronously
      await prepareProcessesInDb(campaignNumber, tenantId);

      //  Offload the long chain into background (non-blocking)
      setImmediate(async () => {
        try {
          await createAllResources(campaignDetails, request?.body?.parentCampaign || null, useruuid);
          await createAllMappings(campaignDetails, request?.body?.parentCampaign || null, useruuid);
          await userCredGeneration(campaignDetails, useruuid, locale);
          await enrichAndPersistCampaignForCreateViaFlow2(campaignDetails);
          triggerUserCredentialEmailFlow(request); // not awaited = background
        } catch (e) {
          console.log(e);
          logger.error("Async Background Flow Error:", e);
          await enrichAndPersistCampaignWithError(request?.body, e);
        }
      });

      //  Immediately return so main thread isn't blocked
      logger.info(`Started async background flow for campaign: ${campaignNumber}`);
    } else {
      let localizationMap;
      try {
        localizationMap = await getLocalizedMessagesHandler(
          request,
          request?.body?.CampaignDetails?.tenantId
        );
      } catch (err) {
        console.log(err);
        throwError("COMMON", 500, "LOCALISATION_ERROR", "Localisation fetch error");
      }
      await updateProjectDates(request, actionInUrl);
      await enrichAndPersistProjectCampaignRequest(
        request,
        actionInUrl,
        false,
        localizationMap
      );
    }

    delete request.body?.boundariesCombined;
  } catch (error: any) {
    console.log(error);
    logger.error(error);
    await enrichAndPersistCampaignWithError(request?.body, error);
  }
}


async function userCredGeneration(campaignDetails: any, useruuid: string, locale: string = config.localisation.defaultLocale) {
  logger.info(`Starting user cred generation...`);
  let userCredGenerationProcess = allProcesses.userCredGeneration;
  let allCurrentProcesses = await getCurrentProcesses(campaignDetails?.campaignNumber, campaignDetails?.tenantId);
  let task = allCurrentProcesses.find((process: any) => process?.processName == userCredGenerationProcess);
  if (task && task?.status == processStatuses.pending) {
    const generateTemplateQuery: GenerateTemplateQuery = {
      type: "userCredential",
      campaignId: campaignDetails?.id,
      tenantId: campaignDetails?.tenantId,
      hierarchyType: campaignDetails?.hierarchyType
    }
    const response = await generateDataService(generateTemplateQuery, useruuid, locale);
    if (response && response?.id) {
      logger.info(`Waiting for 10 seconds for user cred to template to persist...`);
      await new Promise(resolve => setTimeout(resolve, 10000));
      let status = response?.status;
      let attempts = 0
      while (
        status === generatedResourceStatuses.inprogress &&
        attempts < Math.max(
          (config?.resourceCreationConfig?.maxAttemptsForResourceCreationOrMapping ?? 0) / 5,
          20
        )
      )
      {
        const generatedResources: any = await searchAllGeneratedResources({ id: response?.id, tenantId: campaignDetails?.tenantId }, undefined);
        if (generatedResources?.length > 0) {
          status = generatedResources[0]?.status;
          if (status == generatedResourceStatuses.completed) {
            break;
          }
        }
        else {
          throwError("COMMON", 400, "USER_CREDENTIAL_GENERATION_ERROR", "User credential generation failed");
        }
        logger.info(`Attempts : ${attempts + 1} | Status : ${status} | Waiting for 20 seconds for user cred generation to get completed...`);
        await new Promise(resolve => setTimeout(resolve, 20000));
        const campaignResp = await searchProjectTypeCampaignService({ tenantId: campaignDetails?.tenantId, ids: [campaignDetails?.id] });
        const campaignDetailsStatus = campaignResp?.CampaignDetails?.[0]?.status;
        if (campaignDetailsStatus == campaignStatuses.failed || !campaignDetailsStatus) {
          throwError("COMMON", 400, "USER_CREDENTIAL_GENERATION_ERROR", "Campaign creation failed during user credential generation");
        }
        attempts++;
      }
      if (status != generatedResourceStatuses.completed) {
        throwError("COMMON", 400, "USER_CREDENTIAL_GENERATION_ERROR", "User credential generation failed");
      }
    }
    else {
      throwError("COMMON", 400, "USER_CREDENTIAL_GENERATION_ERROR", "User credential generation failed");
    }
  }
}

async function createAllResources(campaignDetails: any, parentCampaign: any, useruuid: string) {
  const { maxAttemptsForResourceCreationOrMapping, waitTimeOfEachAttemptOfResourceCreationOrMappping } = config?.resourceCreationConfig
  let allCurrentProcesses = await getCurrentProcesses(campaignDetails?.campaignNumber, campaignDetails?.tenantId);
  const resourcesTask = [allProcesses.facilityCreation, allProcesses.userCreation, allProcesses.projectCreation];
  for (let i = 0; i < resourcesTask?.length; i++) {
    const task = allCurrentProcesses.find((process: any) => process?.processName == resourcesTask[i]);
    if (task && task?.status == processStatuses.pending) {
      await produceModifiedMessages({
        task,
        CampaignDetails: campaignDetails,
        parentCampaign,
        useruuid
      }, config.kafka.KAFKA_START_ADMIN_CONSOLE_TASK_TOPIC, campaignDetails?.tenantId, resourcesTask[i]);
    }
  }
  let allTaskCompleted = false;
  let anyTaskFailed = false;
  let attempts = 0;
  let facilityTask: any, userTask: any, projectTask: any;
  const startTime = Date.now();
  while (allTaskCompleted == false && anyTaskFailed == false && attempts < maxAttemptsForResourceCreationOrMapping) {
    logger.info(`Attempt ${attempts + 1}/${maxAttemptsForResourceCreationOrMapping}`);
    logger.info(`Waiting ${waitTimeOfEachAttemptOfResourceCreationOrMappping / 1000}s before polling resource statuses...`);
    await new Promise(resolve => setTimeout(resolve, waitTimeOfEachAttemptOfResourceCreationOrMappping));
    let facilityTaskArray = await getCurrentProcesses(campaignDetails?.campaignNumber, campaignDetails?.tenantId, allProcesses.facilityCreation);
    facilityTask = facilityTaskArray[0];
    let userTaskArray = await getCurrentProcesses(campaignDetails?.campaignNumber, campaignDetails?.tenantId, allProcesses.userCreation);
    userTask = userTaskArray[0];
    let projectTaskArray = await getCurrentProcesses(campaignDetails?.campaignNumber, campaignDetails?.tenantId, allProcesses.projectCreation);
    projectTask = projectTaskArray[0];
    if (facilityTask?.status == processStatuses.completed && userTask?.status == processStatuses.completed && projectTask?.status == processStatuses.completed) {
      allTaskCompleted = true;
    }
    if (facilityTask?.status == processStatuses.failed || userTask?.status == processStatuses.failed || projectTask?.status == processStatuses.failed) {
      anyTaskFailed = true;
    }
    const campaignResp = await searchProjectTypeCampaignService({ tenantId: campaignDetails?.tenantId, ids: [campaignDetails?.id] });
    const campaignDetailsStatus = campaignResp?.CampaignDetails?.[0]?.status;
    if (campaignDetailsStatus == campaignStatuses.failed || !campaignDetailsStatus) {
      throwError("COMMON", 400, "RESOURCE_CREATION_ERROR", "Campaign creation failed during resources creation.");
    }
    attempts++;
  }

  const totalTimeTakenInMs = Date.now() - startTime;
  const totalTimeInSeconds = (totalTimeTakenInMs / 1000).toFixed(2);
  const totalTimeInMinutes = (totalTimeTakenInMs / (1000 * 60)).toFixed(2);

  logger.info(` Total time taken for resource creation: ${totalTimeInSeconds}s (~${totalTimeInMinutes} minutes)`);
  if (anyTaskFailed) {
    let failedTasks = [];
    if (facilityTask?.status == processStatuses.failed) {
      failedTasks.push(allProcesses.facilityCreation);
    }
    if (userTask?.status == processStatuses.failed) {
      failedTasks.push(allProcesses.userCreation);
    }
    if (projectTask?.status == processStatuses.failed) {
      failedTasks.push(allProcesses.projectCreation);
    }
    throwError("COMMON", 400, "RESOURCE_CREATION_ERROR", `${failedTasks.join(", ")} tasks failed.`);
  }
  else if(!allTaskCompleted) {
    throwError("COMMON", 400, "RESOURCE_CREATION_TIMED_OUT", "Resources creation timed out.");
  }
  logger.info(`Waiting for 20 seconds for all resources to get persisted...`);
  await new Promise(resolve => setTimeout(resolve, 20000));
}

async function createAllMappings(campaignDetails: any, parentCampaign: any, useruuid: string) {
  const { maxAttemptsForResourceCreationOrMapping, waitTimeOfEachAttemptOfResourceCreationOrMappping } = config?.resourceCreationConfig;
  logger.info(`Starting mappings...`);
  let mappingProcesses = [allProcesses.facilityMapping, allProcesses.userMapping, allProcesses.resourceMapping];
  let allCurrentProcesses = await getCurrentProcesses(campaignDetails?.campaignNumber, campaignDetails?.tenantId);
  for (let i = 0; i < mappingProcesses?.length; i++) {
    const task: any = allCurrentProcesses.find((process: any) => process?.processName == mappingProcesses[i]);
    if (task && task?.status == processStatuses.pending) {
      await produceModifiedMessages({
        task,
        CampaignDetails: campaignDetails,
        parentCampaign,
        useruuid
      }, config.kafka.KAFKA_START_ADMIN_CONSOLE_MAPPING_TASK_TOPIC, campaignDetails?.tenantId, mappingProcesses[i]);
    }
  }
  let allTaskCompleted = false;
  let anyTaskFailed = false;
  let attempts = 0;
  let facilityMappingTask: any, userMappingTask: any, resourceMappingTask: any;
  const startTime = Date.now();
  while (allTaskCompleted == false && anyTaskFailed == false && attempts < maxAttemptsForResourceCreationOrMapping) {
    logger.info(`Attempt ${attempts + 1}/${maxAttemptsForResourceCreationOrMapping}`);
    logger.info(`Waiting ${waitTimeOfEachAttemptOfResourceCreationOrMappping / 1000}s before polling mapping statuses...`);
    await new Promise(resolve => setTimeout(resolve, waitTimeOfEachAttemptOfResourceCreationOrMappping));
    let facilityMappingTaskArray = await getCurrentProcesses(campaignDetails?.campaignNumber, campaignDetails?.tenantId, allProcesses.facilityMapping);
    facilityMappingTask = facilityMappingTaskArray[0];
    let userMappingTaskArray = await getCurrentProcesses(campaignDetails?.campaignNumber, campaignDetails?.tenantId, allProcesses.userMapping);
    userMappingTask = userMappingTaskArray[0];
    let resourceMappingTaskArray = await getCurrentProcesses(campaignDetails?.campaignNumber, campaignDetails?.tenantId, allProcesses.resourceMapping);
    resourceMappingTask = resourceMappingTaskArray[0];
    if (facilityMappingTask?.status == processStatuses.completed && userMappingTask?.status == processStatuses.completed && resourceMappingTask?.status == processStatuses.completed) {
      allTaskCompleted = true;
    }
    if (facilityMappingTask?.status == processStatuses.failed || userMappingTask?.status == processStatuses.failed || resourceMappingTask?.status == processStatuses.failed) {
      anyTaskFailed = true;
    }
    const campaignResp = await searchProjectTypeCampaignService({ tenantId: campaignDetails?.tenantId, ids: [campaignDetails?.id] });
    const campaignDetailsStatus = campaignResp?.CampaignDetails?.[0]?.status;
    if (campaignDetailsStatus == campaignStatuses.failed || !campaignDetailsStatus) {
      throwError("COMMON", 400, "RESOURCE_MAPPING_ERROR", "Campaign creation failed during mappings creation.");
    }
    attempts++;
  }

  const totalTimeTakenInMs = Date.now() - startTime;
  const totalTimeInSeconds = (totalTimeTakenInMs / 1000).toFixed(2);
  const totalTimeInMinutes = (totalTimeTakenInMs / (1000 * 60)).toFixed(2);
  logger.debug(
    ` Total time taken for mappings creation: ${totalTimeInSeconds}s (~${totalTimeInMinutes} minutes)`
  );

  if (anyTaskFailed) {
    let failedTasks = [];
    if (facilityMappingTask?.status == processStatuses.failed) {
      failedTasks.push(allProcesses.facilityMapping);
    }
    if (userMappingTask?.status == processStatuses.failed) {
      failedTasks.push(allProcesses.userMapping);
    }
    if (resourceMappingTask?.status == processStatuses.failed) {
      failedTasks.push(allProcesses.resourceMapping);
    }
    throwError("COMMON", 400, "RESOURCE_MAPPING_ERROR", `${failedTasks.join(", ")} tasks failed.`);
  }
  else if(!allTaskCompleted) {
    throwError("COMMON", 400, "RESOURCE_MAPPING_TIMED_OUT", "Mappings creation timed out.");
  }
  campaignDetails.status = campaignStatuses.completed;
}

async function processBasedOnAction(request: any, actionInUrl: any) {
  if (actionInUrl === "create") {
    request.body.CampaignDetails.id = uuidv4();
  }

  const generationCheck = isGenerationTriggerNeeded(request);
  await enrichAndPersistProjectCampaignForFirst(request, actionInUrl, true);

  const shouldTriggerGeneration =
    request?.body?.CampaignDetails?.action === "draft" &&
    generationCheck?.trigger &&
    request?.body?.CampaignDetails?.boundaries?.length;

  if (shouldTriggerGeneration) {
    await tryTriggerGenerateIfBoundariesSynced(request, generationCheck.newBoundaries);
  }

  processAfterPersistNew(request, actionInUrl);
}

async function tryTriggerGenerateIfBoundariesSynced(request: any, expectedBoundaries: any[]) {
  const maxRetries = 4;
  const retryDelayMs = 1000;
  const campaignId = request?.body?.CampaignDetails?.id;
  const tenantId = request?.body?.CampaignDetails?.tenantId;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      logger.info(`Checking persisted campaign boundaries. Attempt ${attempt}`);
      const searchResponse = await searchProjectTypeCampaignService({ tenantId, ids: [campaignId] });
      const persistedBoundaries = searchResponse?.CampaignDetails?.[0]?.boundaries ?? [];

      if (areBoundariesSame(persistedBoundaries, expectedBoundaries)) {
        logger.info("Persisted boundaries match request. Triggering generation.");
        callGenerateIfBoundariesOrCampaignTypeDiffer(request);
        return;
      }

      logger.warn(`Persisted boundaries differ on attempt ${attempt}. Retrying...`);
    } catch (error: any) {
      logger.error(`Error checking persisted campaign boundaries on attempt ${attempt}: ${error.message}`);
    }

    if (attempt < maxRetries) {
      await new Promise(resolve => setTimeout(resolve, retryDelayMs));
    }
  }

  logger.error("Persisted boundaries did not match after 4 retries. Possible DB sync issue.");
  throwError("PERSISTENCE", 500, "BOUNDARY_SYNC_ERROR", "Boundaries could not be synced from DB after multiple retries.");
}

async function getLocalesFromStateInfo(tenantId: string): Promise<string[]> {
  const criteria = {
    tenantId,
    schemaCode: "common-masters.StateInfo",
    isActive: true,
  };

  const response = await searchMDMSDataViaV2Api({ MdmsCriteria: criteria });

  if (!response?.mdms?.length) {
    throw new Error("StateInfo data not found in MDMS");
  }

  const languageValues =
    response.mdms?.[0]?.data?.languages?.map((lang: any) => lang.value) || [];
  return languageValues;
}

async function getTemplateModules(
  tenantId: string,
  campaignType: string,
  schemaCode: string
): Promise<any[]> {
  const criteria = {
    tenantId,
    schemaCode,
    filters: { project: campaignType },
    isActive: true,
  };

  const response = await searchMDMSDataViaV2Api({ MdmsCriteria: criteria });

  return (response?.mdms || [])
    .map((item: any) => item?.data || [])
    .flat()
    .filter((module: any) => !module?.disabled);
}

async function upsertLocalisations(
  tenantId: string,
  baseModuleKey: string,
  updatedModuleKey: string,
  locales: string[],
  localisation: any,
  RequestInfo: any
): Promise<void> {
  const chunkSize = 100;

  for (const locale of locales) {
    let messages: any[] = [];

    try {
      messages = await localisation.getLocalizationResponseMessages(
        baseModuleKey,
        locale,
        tenantId
      );
    } catch (e: any) {
      logger.error(`Failed to fetch localisation for ${baseModuleKey} (${locale}): ${e?.message}`);
      continue;
    }

    const updatedMessages = messages.map((entry: any) => ({
      ...entry,
      locale,
      module: updatedModuleKey,
    }));

    for (let i = 0; i < updatedMessages.length; i += chunkSize) {
      const chunk = updatedMessages.slice(i, i + chunkSize);
      await localisation.createLocalisation(chunk, tenantId, RequestInfo);
      logger.info(`Localisation added for ${updatedModuleKey} (${locale})  chunk ${i / chunkSize + 1}`);
    }
  }
}

async function processAndInsertModules(
  tenantId: string,
  campaignType: string,
  campaignNumber: string,
  templateModules: any[],
  locales: string[],
  localisation: any,
  schemaCode: string,
  RequestInfo: any
): Promise<void> {
  const baseType = campaignType.toLowerCase();
  const useruuid = RequestInfo?.userInfo?.uuid;
  if (!useruuid) {
    throw new Error("User uuid not found in request");
  }
  if (!templateModules?.length) {
    logger.warn("No template modules found");
    return;
  }

  await Promise.all(
    templateModules.map((template) => {
      logger.info(`Inserting template module: ${template?.name} for campaign number ${campaignNumber}`);

      const moduleData = {
        ...template,
        project: campaignNumber,
        isSelected: true,
      };

      return createMdmsData(tenantId, schemaCode, moduleData, useruuid);
    })
  );

  for (const template of templateModules) {
    const moduleName = template?.name;
    if (!moduleName) continue;
    const baseKey = `hcm-base-${moduleName.toLowerCase()}-${baseType}`;
    const updatedKey = `hcm-${moduleName.toLowerCase()}-${campaignNumber}`;
    await upsertLocalisations(
      tenantId,
      baseKey,
      updatedKey,
      locales,
      localisation,
      RequestInfo
    );
  }
}

export async function createAppConfig(
  tenantId: string,
  campaignNumber: string,
  campaignType: string,
  RequestInfo: any
): Promise<void> {
  try {
    logger.info("Creating app configuration...");

    const FormConfigTemplate = "FormConfigTemplate";
    const FormConfig = "FormConfig";
    const templateSchema = `HCM-ADMIN-CONSOLE.${FormConfigTemplate}`;
    const configSchema = `HCM-ADMIN-CONSOLE.${FormConfig}`;

    const [locales, localisation] = await Promise.all([
      getLocalesFromStateInfo(tenantId),
      Localisation.getInstance(),
    ]);

    const templateModules = await getTemplateModules(tenantId, campaignType, templateSchema);

    await processAndInsertModules(
      tenantId,
      campaignType,
      campaignNumber,
      templateModules,
      locales,
      localisation,
      configSchema,
      RequestInfo
    );

    logger.info("App configuration created successfully.");
  } catch (err: any) {
    logger.error(`Failed to create app config: ${err?.message}`);
    throw err;
  }
}

export async function createAppConfigFromClone(
  tenantId: string,
  newCampaignNumber: string,
  cloneFromCampaignNumber: string,
  RequestInfo: any
): Promise<void> {
  try {
    logger.info("Started creating app config from clone...");

    const FormConfig = "FormConfig";
    const configSchema = `HCM-ADMIN-CONSOLE.${FormConfig}`;
    const useruuid = RequestInfo?.userInfo?.uuid;
    if (!useruuid) {
      throw new Error("User uuid not found in request");
    }

    const [locales, localisation] = await Promise.all([
      getLocalesFromStateInfo(tenantId),
      Localisation.getInstance(),
    ]);

    const cloneResponse = await fetchCloneModules(
      tenantId,
      configSchema,
      cloneFromCampaignNumber
    );

    const modulesToClone = (cloneResponse?.mdms || [])
      .map((item: any) => item?.data)
      .flat()
      .filter(Boolean);

    if (!modulesToClone.length) {
      logger.warn("No modules found to clone.");
      return;
    }

    for (const module of modulesToClone) {
      const moduleName = module?.name;
      if (!moduleName) continue;

      const baseKey = `hcm-${moduleName.toLowerCase()}-${cloneFromCampaignNumber}`;
      const newKey = `hcm-${moduleName.toLowerCase()}-${newCampaignNumber}`;

      await upsertLocalisations(tenantId, baseKey, newKey, locales, localisation, RequestInfo);

      const newModule = {
        ...module,
        project: newCampaignNumber,
        isSelected: true,
      };

      await createMdmsData(tenantId, configSchema, newModule, useruuid);
    }

    logger.info("App configuration cloned successfully.");
  } catch (err: any) {
    logger.error(`Failed to clone app config: ${err?.message}`);
    throw err;
  }
}

async function fetchCloneModules(
  tenantId: string,
  configSchema: string,
  cloneFromCampaignNumber: string
): Promise<any> {
  const cloneCriteria = {
    tenantId,
    schemaCode: configSchema,
    filters: { project: cloneFromCampaignNumber },
    isActive: true,
  };

  return await searchMDMSDataViaV2Api({ MdmsCriteria: cloneCriteria });
}

async function getLocalizedHierarchy(request: any, localizationMap: any) {
  var hierarchy = await getHierarchy(
    request?.query?.tenantId,
    request?.query?.hierarchyType
  );
  var modifiedHierarchy = hierarchy.map((ele) =>
    `${request?.query?.hierarchyType}_${ele}`.toUpperCase()
  );
  var resultHierarchy = getLocalizedHeaders(modifiedHierarchy, localizationMap);
  return resultHierarchy;
}

async function appendSheetsToWorkbook(
  request: any,
  boundaryData: any[],
  differentTabsBasedOnLevel: any,
  localizationMap?: any,
  fileUrl?: any
) {
  try {
    logger.info(
      "Received Boundary data for generating  different tabs based on configured boundary level"
    );
    const hierarchy: any[] = await getLocalizedHierarchy(
      request,
      localizationMap
    );
    const workbook = getNewExcelWorkbook();
    const type = request?.query?.type;
    const headingInSheet = headingMapping?.[type];
    const localisedHeading = getLocalizedName(headingInSheet, localizationMap);
    await createReadMeSheet(
      request,
      workbook,
      localisedHeading,
      localizationMap
    );
    const [
      mainSheetData,
      uniqueDistrictsForMainSheet,
      districtLevelRowBoundaryCodeMap,
    ] = createBoundaryDataMainSheet(
      request,
      boundaryData,
      differentTabsBasedOnLevel,
      hierarchy,
      localizationMap
    );
    const responseFromCampaignSearch = await getCampaignSearchResponse(request);
    const campaignObject = responseFromCampaignSearch?.CampaignDetails?.[0];
    // const isSourceMicroplan = checkIfSourceIsMicroplan(campaignObject);
    const mainSheet = workbook.addWorksheet(
      getLocalizedName(getBoundaryTabName(), localizationMap)
    );
    const columnWidths = Array(12).fill(30);
    mainSheet.columns = columnWidths.map((width) => ({ width }));
    // mainSheetData.forEach(row => mainSheet.addRow(row));
    addDataToSheet(
      request,
      mainSheet,
      mainSheetData,
      "F3842D",
      30,
      false,
      true
    );
    mainSheet.state = "hidden";
    logger.info("appending different districts tab in the sheet started");
    await appendDistricts(
      request,
      workbook,
      uniqueDistrictsForMainSheet,
      differentTabsBasedOnLevel,
      boundaryData,
      localizationMap,
      districtLevelRowBoundaryCodeMap,
      hierarchy,
      campaignObject,
      fileUrl
    );
    logger.info("Sheet with different tabs generated successfully");
    return workbook;
  } catch (error) {
    console.log(error);
    throw Error("An error occurred while creating tabs based on district:");
  }
}

async function appendDistricts(
  request: any,
  workbook: any,
  uniqueDistrictsForMainSheet: any,
  differentTabsBasedOnLevel: any,
  boundaryData: any,
  localizationMap: any,
  districtLevelRowBoundaryCodeMap: any,
  hierarchy: any,
  campaignObject: any,
  fileUrl?: any
) {
  const configurableColumnHeadersFromSchemaForTargetSheet =
    await getConfigurableColumnHeadersFromSchemaForTargetSheet(
      request,
      hierarchy,
      boundaryData,
      differentTabsBasedOnLevel,
      campaignObject,
      localizationMap
    );
  let sheetNamesOfProcessedFile: any;
  if (fileUrl) {
    const processedWorkbook = await getTargetWorkbook(fileUrl, localizationMap);
    sheetNamesOfProcessedFile = processedWorkbook.worksheets.map(
      (sheet: any) => sheet.name
    );
  }
  for (const uniqueData of uniqueDistrictsForMainSheet) {
    const uniqueDataFromLevelForDifferentTabs = uniqueData.slice(
      uniqueData.lastIndexOf("#") + 1
    );
    logger.info(
      `generating the boundary data for ${uniqueDataFromLevelForDifferentTabs} - ${differentTabsBasedOnLevel}`
    );
    const districtDataFiltered = boundaryData.filter(
      (boundary: any) =>
        boundary[differentTabsBasedOnLevel] ===
        uniqueDataFromLevelForDifferentTabs &&
        boundary[hierarchy[hierarchy.length - 1]]
    );
    const modifiedFilteredData = modifyFilteredData(
      districtDataFiltered,
      districtLevelRowBoundaryCodeMap.get(uniqueData),
      differentTabsBasedOnLevel,
      localizationMap
    );
    if (modifiedFilteredData?.[0]) {
      const newSheetData = [configurableColumnHeadersFromSchemaForTargetSheet];
      for (const data of modifiedFilteredData) {
        var rowData: any[] = [];
        for (const header of configurableColumnHeadersFromSchemaForTargetSheet) {
          rowData.push(data[header] || "");
        }
        newSheetData.push(rowData);
      }

      await createNewSheet(
        request,
        workbook,
        newSheetData,
        uniqueData,
        localizationMap,
        districtLevelRowBoundaryCodeMap,
        configurableColumnHeadersFromSchemaForTargetSheet,
        campaignObject,
        sheetNamesOfProcessedFile,
        fileUrl
      );
      logger.info(
        `${uniqueDataFromLevelForDifferentTabs} - ${differentTabsBasedOnLevel} boundary data generation completed`
      );
    }
  }
}

async function createNewSheet(
  request: any,
  workbook: any,
  newSheetData: any,
  uniqueData: any,
  localizationMap: any,
  districtLevelRowBoundaryCodeMap: any,
  localizedHeaders: any,
  campaignObject: any,
  sheetNamesOfProcessedFile: any,
  fileUrl?: any
) {
  const newSheet = workbook.addWorksheet(
    getLocalizedName(
      districtLevelRowBoundaryCodeMap.get(uniqueData),
      localizationMap
    )
  );
  let modifiedNewSheetData: any = newSheetData;
  const oldTargetColumnsToHide: any[] = [];
  if (fileUrl) {
    let processedDistrictSheetData: any;
    if (
      sheetNamesOfProcessedFile.includes(
        getLocalizedName(
          districtLevelRowBoundaryCodeMap.get(uniqueData),
          localizationMap
        )
      )
    ) {
      processedDistrictSheetData = await getSheetData(
        fileUrl,
        getLocalizedName(
          districtLevelRowBoundaryCodeMap.get(uniqueData),
          localizationMap
        ),
        false,
        undefined,
        localizationMap
      );
    }
    modifiedNewSheetData = modifyNewSheetData(
      processedDistrictSheetData,
      newSheetData,
      localizedHeaders,
      oldTargetColumnsToHide,
      localizationMap
    );
  }
  addDataToSheet(request, newSheet, modifiedNewSheetData, "F3842D", 40);
  if (oldTargetColumnsToHide && oldTargetColumnsToHide.length > 0) {
    const columnIndexesToBeHidden: any[] = [];
    oldTargetColumnsToHide.forEach((column: any) => {
      const localizedColumn = getLocalizedName(column, localizationMap);
      const columnIndex = getColumnIndexByHeader(newSheet, localizedColumn);
      columnIndexesToBeHidden.push(columnIndex);
    });
    hideColumnsOfProcessedFile(newSheet, columnIndexesToBeHidden);
  }
  let columnsNotToBeFreezed: any;
  const boundaryCodeColumnIndex = localizedHeaders.findIndex(
    (header: any) =>
      header ===
      getLocalizedName(config?.boundary?.boundaryCode, localizationMap)
  );
  if (
    isDynamicTargetTemplateForProjectType(campaignObject?.projectType) &&
    campaignObject.deliveryRules &&
    campaignObject.deliveryRules.length > 0
  ) {
    columnsNotToBeFreezed = localizedHeaders.slice(boundaryCodeColumnIndex + 1);
  } else {
    const mdmsResponse = await getMdmsDataBasedOnCampaignType(
      request,
      localizationMap
    );
    columnsNotToBeFreezed = mdmsResponse?.columnsNotToBeFreezed;
  }
  const localizedColumnsNotToBeFreezed = getLocalizedHeaders(
    columnsNotToBeFreezed,
    localizationMap
  );
  lockTargetFields(
    newSheet,
    localizedColumnsNotToBeFreezed,
    boundaryCodeColumnIndex
  );
}

function modifyFilteredData(
  districtDataFiltered: any,
  targetBoundaryCode: any,
  differentTabsBasedOnLevel: any,
  localizationMap?: any
): any {
  // Retrieve the localized version of the target boundary code if a localization map is provided
  const desiredBoundaryCode = getLocalizedName(
    targetBoundaryCode,
    localizationMap
  );
  // Filter the district data to include only rows where the boundary code matches the desired one
  const modifiedFilteredData = districtDataFiltered.filter((row: any) => {
    return row[differentTabsBasedOnLevel] == desiredBoundaryCode;
  });
  // Return the filtered data
  return modifiedFilteredData;
}

async function generateFilteredBoundaryData(
  request: any,
  FiltersFromCampaignId: any
) {
  const rootBoundary: any = (FiltersFromCampaignId?.Filters?.boundaries).filter(
    (boundary: any) => boundary.isRoot
  );
  // const params = {
  //   ...request?.query,
  //   includeChildren: true,
  //   codes: rootBoundary?.[0]?.code,
  // };
  // const boundaryDataFromRootOnwards = await getBoundaryRelationshipData(
  //   request,
  //   params
  // );
  const boundaryRelationshipResponse = await searchBoundaryRelationshipData(request?.query?.tenantId, request?.query?.hierarchyType, true, true, true, rootBoundary?.[0]?.code);
  const boundaryDataFromRootOnwards = boundaryRelationshipResponse?.TenantBoundary?.[0]?.boundary;
  logger.info(`filtering the boundaries`);
  const filteredBoundaryList = filterBoundaries(
    boundaryDataFromRootOnwards,
    FiltersFromCampaignId?.Filters
  );
  logger.info(`filtered the boundaries based on given criteria`);
  return filteredBoundaryList;
}

function filterBoundaries(boundaryData: any[], filters: any): any {
  function filterRecursive(boundary: any): any {
    const boundaryFilters = filters && filters.boundaries; // Accessing boundaries array from filters object
    const filter = boundaryFilters?.find(
      (f: any) =>
        f.code === boundary.code && f.boundaryType === boundary.boundaryType
    );

    if (!filter) {
      return {
        ...boundary,
        children: boundary.children.map(filterRecursive),
      };
    }

    if (!boundary.children.length) {
      if (!filter.includeAllChildren) {
        // throwError("COMMON", 400, "VALIDATION_ERROR", "Boundary cannot have includeAllChildren filter false if it does not have any children");
        logger.warn(
          "Boundary cannot have includeAllChildren filter false if it does not have any children"
        );
      }
      // If boundary has no children and includeAllChildren is true, return as is
      return {
        ...boundary,
        children: [],
      };
    }

    if (filter.includeAllChildren) {
      // If includeAllChildren is true, return boundary with all children
      return {
        ...boundary,
        children: boundary.children.map(filterRecursive),
      };
    }

    const filteredChildren: any[] = [];
    boundary.children.forEach((child: any) => {
      const matchingFilter = boundaryFilters.find(
        (f: any) =>
          f.code === child.code && f.boundaryType === child.boundaryType
      );
      if (matchingFilter) {
        filteredChildren.push(filterRecursive(child));
      }
    });
    return {
      ...boundary,
      children: filteredChildren,
    };
  }
  const filteredData = boundaryData.map(filterRecursive);
  return filteredData;
}

function generateHierarchy(boundaries: any[]) {
  // Create an object to store boundary types and their parents
  const parentMap: any = {};

  // Populate the object with boundary types and their parents
  for (const boundary of boundaries) {
    parentMap[boundary.boundaryType] = boundary.parentBoundaryType;
  }

  // Traverse the hierarchy to generate the hierarchy list
  const hierarchyList = [];
  for (const boundaryType in parentMap) {
    if (Object.prototype.hasOwnProperty.call(parentMap, boundaryType)) {
      const parentBoundaryType = parentMap[boundaryType];
      if (parentBoundaryType === null) {
        // This boundary type has no parent, add it to the hierarchy list
        hierarchyList.push(boundaryType);
        // Traverse its children recursively
        traverseChildren(boundaryType, parentMap, hierarchyList);
      }
    }
  }
  return hierarchyList;
}

function traverseChildren(parent: any, parentMap: any, hierarchyList: any[]) {
  for (const boundaryType in parentMap) {
    if (Object.prototype.hasOwnProperty.call(parentMap, boundaryType)) {
      const parentBoundaryType = parentMap[boundaryType];
      if (parentBoundaryType === parent) {
        // This boundary type has the current parent, add it to the hierarchy list
        hierarchyList.push(boundaryType);
        // Traverse its children recursively
        traverseChildren(boundaryType, parentMap, hierarchyList);
      }
    }
  }
}

function createBoundaryMap(
  boundaries: any[],
  boundaryMap: Map<string, string>
): void {
  for (const boundary of boundaries) {
    boundaryMap.set(boundary.code, boundary.boundaryType);
    if (boundary.children.length > 0) {
      createBoundaryMap(boundary.children, boundaryMap);
    }
  }
}

async function boundaryGeometryManagement(request: any, localizationMap: any) {
  try {
    logger.info("Boundary Relationship Creation Starts For Geometry Data");
    await autoGenerateBoundaryCodesForGeoJson(request, localizationMap);
  } catch (error: any) {
    console.log(error);
    await handleResouceDetailsError(request, error);
  }
}

async function boundaryBulkUpload(request: any, localizationMap?: any) {
  try {
    logger.info("Boundary Relationship Creation Starts");
    await autoGenerateBoundaryCodes(request, localizationMap);
    await generateProcessedFileAndPersist(request);
  } catch (error: any) {
    console.log(error);
    await handleResouceDetailsError(request, error);
  }
}

function updateBoundaryDataForBoundaryManagement(
  request: any,
  boundaryData: any[],
  localizationMap: any
): { updatedData: any[]; latLongData: [number, number][] } {
  const latLongData: [number, number][] = [];
  const latKey = getLocalizedName("HCM_ADMIN_CONSOLE_LAT", localizationMap);
  const longKey = getLocalizedName("HCM_ADMIN_CONSOLE_LONG", localizationMap);

  boundaryData.forEach((row) => {
    // Check if the row contains both latitude and longitude keys
    if (latKey in row && longKey in row) {
      // Push latitude and longitude to the latLongData array
      latLongData.push([row[latKey], row[longKey]]);

      // Remove the latitude and longitude from the original row
      delete row[latKey];
      delete row[longKey];
    }
  });

  // Return both the updated boundary data and latLongData
  return {
    updatedData: boundaryData,
    latLongData,
  };
}

async function autoGenerateBoundaryCodesForGeoJson(
  request: any,
  localizationMap?: any
) {
  const { hierarchyType, tenantId } = request?.body?.ResourceDetails || {};
  // const type = request?.body?.ResourceDetails?.type;
  const fileResponse = await httpRequest(
    config.host.filestore + config.paths.filestore + "/url",
    {},
    { tenantId, fileStoreIds: request?.body?.ResourceDetails?.fileStoreId },
    "get"
  );
  var boundaryData = await getDataFromGeoJson(
    fileResponse?.fileStoreIds?.[0]?.url
  );
  const hierarchy =
    (await getHierarchy(tenantId, hierarchyType)) || [];
  const dataFromGeoJson = getGeoJsonData(boundaryData, hierarchy);
  const childParentMap = getChildParentMap(dataFromGeoJson);
  const countMap = new Map<{ key: string; value: string }, number>();
  const mappingMap = new Map<{ key: string; value: string }, string>();
  const boundaryMap = await getAutoGeneratedBoundaryCodesHandler(
    dataFromGeoJson,
    childParentMap,
    mappingMap,
    countMap,
    request
  );
  logger.info("Boundary Code Auto Generation Completed");
  await createBoundaryEntities(request, boundaryMap);
  logger.info(
    "waiting for 2 secs to persist the boundary entities before creating boundary relationship"
  );
  await new Promise((resolve) => setTimeout(resolve, 2000));
  const modifiedChildParentMap = modifyChildParentMap(
    childParentMap,
    boundaryMap
  );
  await createBoundaryRelationship(
    request,
    boundaryMap,
    modifiedChildParentMap
  );
  const boundaryGeoJsonAfterProcessing = addBoundaryCodeToGeoJsonData(
    boundaryData,
    hierarchy,
    boundaryMap
  );
  logger.info(
    "Initiated the localisation message creation for the uploaded boundary"
  );
  transformAndCreateLocalisation(boundaryMap, request, false, false);
  const boundaryFileDetails: any = await createAndUploadJsonFile(
    boundaryGeoJsonAfterProcessing,
    request
  );
  await updateAndPersistResourceDetails(
    request,
    boundaryFileDetails,
    boundaryData?.name
  );
  logger.info("Boundary Relationship Creation Completed");
}

async function updateAndPersistResourceDetails(
  request: any,
  boundaryFileDetails: any,
  name: any
) {
  const fileStoreId = boundaryFileDetails[0]?.fileStoreId;
  const getLatestResourceDetails = await getResourceDetails(request);

  if (getLatestResourceDetails == null) {
    request.body.ResourceDetails = {
      ...request?.body?.ResourceDetails,
      processedFileStoreId: fileStoreId,
      status:
        request.body.ResourceDetails.status != resourceDataStatuses.invalid
          ? resourceDataStatuses.completed
          : resourceDataStatuses.invalid,
      auditDetails: {
        ...request?.body?.ResourceDetails?.auditDetails,
        lastModifiedBy: request?.body?.RequestInfo?.userInfo?.uuid,
        lastModifiedTime: Date.now(),
      },
      additionalDetails:
      {
        ...request?.body?.ResourceDetails?.additionalDetails,
        sheetErrors: request?.body?.additionalDetailsErrors,
        source:
          request?.body?.ResourceDetails?.additionalDetails?.source ==
            "microplan"
            ? "microplan"
            : null,
        [name]: [fileStoreId],
      },
    };
  } else {
    request.body.ResourceDetails = {
      ...getLatestResourceDetails,
      processedFileStoreId: fileStoreId,
      status:
        getLatestResourceDetails.status != resourceDataStatuses.invalid
          ? resourceDataStatuses.completed
          : resourceDataStatuses.invalid,
      auditDetails: {
        ...getLatestResourceDetails.auditDetails,
        lastModifiedBy: request?.body?.RequestInfo?.userInfo?.uuid,
        lastModifiedTime: Date.now(),
      },
      additionalDetails:
      {
        ...getLatestResourceDetails.additionalDetails,
        sheetErrors: request?.body?.additionalDetailsErrors,
        source:
          getLatestResourceDetails.additionalDetails?.source == "microplan"
            ? "microplan"
            : null,
      },
    };
    let additionalDetails = request?.body?.ResourceDetails?.additionalDetails;
    if (additionalDetails && additionalDetails[name]) {
      additionalDetails[name].push(fileStoreId);
    } else {
      additionalDetails = { ...additionalDetails, [name]: [fileStoreId] };
    }
    request.body.ResourceDetails.additionalDetails = additionalDetails;
  }

  const persistMessage: any = { ResourceDetails: request.body.ResourceDetails };
  await produceModifiedMessages(
    persistMessage,
    config?.kafka?.KAFKA_UPDATE_RESOURCE_DETAILS_TOPIC,
    request?.body?.ResourceDetails?.tenantId
  );
  logger.info(
    `ResourceDetails to persist : ${request.body.ResourceDetails.type}`
  );
}

export async function processDataForTargetCalculation(request: any, jsonData: any, codeColumnName: string, localizationMap?: any) {
  // Retrieve targetConfigs from MDMS
  const targetConfigs = await searchMDMS([request?.body?.CampaignDetails?.projectType], "HCM-ADMIN-CONSOLE.targetConfigs", request?.body?.RequestInfo);

  // Process each row of the sheet data
  const resultantData = jsonData.map((row: any) => {

    // Initialize an object to hold row-specific data
    let rowData: any = { [codeColumnName]: row[codeColumnName] };

    // Add placeholder fields for Parent Target and Current Target data
    rowData['Parent Target at the Selected Boundary level'] = {};
    rowData['Target at the Selected Boundary level'] = {};
    const beneficiaries = targetConfigs?.mdms?.[0]?.data?.beneficiaries;
    // Calculate the parent target values
    calculateTargetsAtParentLevel(request, row, rowData, beneficiaries, localizationMap);
    // Calculate the current target values
    calculateTargetsAtCurrentLevel(row, rowData, beneficiaries, localizationMap);

    // Return the processed row data
    return rowData;
  }).filter(Boolean); // Remove any null entries from the map (i.e., skip the header row)

  return resultantData;
}

export function calculateTargetsAtParentLevel(request: any, row: any, rowData: any, beneficiaries: any, localizationMap?: any) {
  // Check if a parent campaign exists in the request body
  if (request?.body?.parentCampaign) {
    // Loop through the beneficiaries for the specified campaign type
    if (Array.isArray(beneficiaries) && beneficiaries?.length > 0) {
      for (const beneficiary of beneficiaries) {
        const beneficiaryType = beneficiary?.beneficiaryType;
        const columns = beneficiary?.columns;
        let totalParentValue = 0;

        // Loop through each column to calculate the total parent value
        for (const col of columns) {
          // Get the parent value from the column and add it if it's an integer
          const parentValue = row[`${getLocalizedName(col, localizationMap)}(OLD)`];
          if (typeof parentValue === 'number' && Number.isInteger(parentValue)) {
            totalParentValue += parentValue;
          }
        }
        // Assign the total parent value to the corresponding beneficiary type
        rowData['Parent Target at the Selected Boundary level'][beneficiaryType] = totalParentValue;
      }
    }
    else {
      logger.warn("No beneficiaries config found for the specified campaign type");
    }
  }
}

export function calculateTargetsAtCurrentLevel(row: any, rowData: any, beneficiaries: any, localizationMap?: any) {
  // Loop through the beneficiaries again to calculate the current target values
  if (Array.isArray(beneficiaries) && beneficiaries?.length > 0) {
    for (const beneficiary of beneficiaries) {
      const beneficiaryType = beneficiary?.beneficiaryType;
      const columns = beneficiary?.columns;
      let totalCurrentValue = 0;

      // Loop through each column to calculate the total current value
      for (const col of columns) {
        const currentValue = row[getLocalizedName(col, localizationMap)];
        if (typeof currentValue === 'number' && Number.isInteger(currentValue)) {
          totalCurrentValue += currentValue;
        }
      }
      // Assign the total current value to the corresponding beneficiary type
      rowData['Target at the Selected Boundary level'][beneficiaryType] = totalCurrentValue;
    }
  }
  else {
    logger.warn("No beneficiaries config found for the specified campaign type");
  }
}

async function getResourceDetails(request: any) {
  const { tenantId, type, hierarchyType } =
    request?.body?.ResourceDetails || request?.query;
  const resourceDetails = request?.body?.ResourceDetails;

  request.body.SearchCriteria = request.body.SearchCriteria || {};

  request.body.SearchCriteria = {
    tenantId: tenantId,
    type: type,
    hierarchyType: hierarchyType,
    status: resourceDataStatuses.completed,
  };

  const response = await searchDataService(request);
  request.body.ResourceDetails = resourceDetails;
  if (response.length > 0) {
    response.sort(
      (a: any, b: any) =>
        b.auditDetails.lastModifiedTime - a.auditDetails.lastModifiedTime
    );
    return response[0];
  } else {
    return null;
  }
}
const addBoundaryCodeToGeoJsonData = (
  boundaryData: any,
  hiearchy: any,
  boundaryMap: Map<any, any>
) => {
  // const objectMap = boundaryMap.forEach((value, key) => {return { key: key.value, value: value });
  // Create the updatedBoundaryMap using a Map
  const updatedBoundaryMap = new Map();
  boundaryMap.forEach((value, key) => {
    const newKey = key.key + "_" + key.value; // Concatenate key and value
    updatedBoundaryMap.set(newKey, value); // Set in the updated map
  });

  // Iterate through the boundary data
  boundaryData.features.forEach((feature: any) => {
    // Extract the properties object from the feature
    const properties = feature.properties;

    // Iterate through the hierarchy
    hiearchy.forEach((h: string) => {
      // Build the field name
      const field = h.toLowerCase() + "_name";

      // Check if the field exists in the properties object
      if (properties[field]) {
        const boundaryName = h + "_" + properties[field];
        // Assign the boundary code to the properties object
        properties[config.boundary.boundaryCode] =
          updatedBoundaryMap.get(boundaryName); // Use .get() to access the Map
      }
    });
  });

  return boundaryData;
};
const getGeoJsonData = (boundaryData: any, hiearchy: any) => {
  var data: any = [];
  boundaryData.features?.forEach((feature: any) => {
    const properties = feature.properties;
    var row: any = [];
    hiearchy.forEach((h: string) => {
      const field = h.toLowerCase() + "_name";
      if (properties[field]) {
        const d = {
          key: h,
          value: properties[field],
        };
        row.push(d);
      }
    });
    data.push(row);
  });
  return data;
};

const getDataFromGeoJson = async (url: string) => {
  // Define headers for HTTP request
  const headers = {
    "Content-Type": "application/json",
    Accept: "application/json",
  };
  logger.info("loading for the file based on fileurl");
  // Make HTTP request to retrieve Excel file as arraybuffer
  const responseFile = await httpRequest(url, null, {}, "get", "json", headers);
  logger.info("received the file response");
  return responseFile;
};

const autoGenerateBoundaryCodes = async (
  request: any,
  localizationMap?: any
) => {
  const { hierarchyType, tenantId } = request?.body?.ResourceDetails || {};
  const hierarchy =
    (await getHierarchy(tenantId, hierarchyType)) || [];
  const headersOfBoundarySheet = hierarchy.map(
    (e) => `${hierarchyType.toUpperCase()}_${e.toUpperCase()}`
  );
  const localizedHeadersOfBoundarySheet = getLocalizedHeaders(
    headersOfBoundarySheet,
    localizationMap
  );
  const type = request?.body?.ResourceDetails?.type;
  const fileResponse = await httpRequest(
    config.host.filestore + config.paths.filestore + "/url",
    {},
    { tenantId, fileStoreIds: request?.body?.ResourceDetails?.fileStoreId },
    "get"
  );
  const localizedBoundaryTab = getLocalizedName(
    getBoundaryTabName(),
    localizationMap
  );
  var boundaryData = await getSheetData(
    fileResponse?.fileStoreIds?.[0]?.url,
    localizedBoundaryTab,
    false,
    undefined,
    localizationMap
  );
  var latLongData: any;
  if (type === "boundaryManagement") {
    validateBoundarySheetDataInCreateFlow(
      boundaryData,
      localizedHeadersOfBoundarySheet
    );
    const result = updateBoundaryDataForBoundaryManagement(
      request,
      boundaryData,
      localizationMap
    );
    latLongData = result.latLongData;
    boundaryData = result.updatedData;
  }
  const updatedBoundaryData = updateBoundaryData(boundaryData, localizedHeadersOfBoundarySheet);
  const headerToHierarchyMap = createHeaderToHierarchyMap(localizedHeadersOfBoundarySheet, hierarchy);
  const modifiedBoundaryData = modifyBoundaryDataHeadersWithMap(updatedBoundaryData, headerToHierarchyMap);
  const [withBoundaryCode, withoutBoundaryCode] = modifyBoundaryData(
    modifiedBoundaryData,
    localizationMap
  );
  const { mappingMap, countMap } =
    getCodeMappingsOfExistingBoundaryCodes(withBoundaryCode, localizationMap);
  const childParentMap = getChildParentMap([
    ...withBoundaryCode,
    ...withoutBoundaryCode,
  ]);
  const boundaryMap = await getAutoGeneratedBoundaryCodesHandler(
    withoutBoundaryCode,
    childParentMap,
    mappingMap,
    countMap,
    request,
    hierarchy
  );
  logger.info("Boundary Code Auto Generation Completed");
  await createBoundaryEntities(request, boundaryMap);
  logger.info(
    "waiting for 2 secs to persist the boundary entities before creating boundary relationship"
  );
  await new Promise((resolve) => setTimeout(resolve, 2000));
  const modifiedChildParentMap = modifyChildParentMap(
    childParentMap,
    boundaryMap
  );
  await createBoundaryRelationship(
    request,
    boundaryMap,
    modifiedChildParentMap
  );
  const boundaryDataForSheet = addBoundaryCodeToData(
    withBoundaryCode,
    withoutBoundaryCode,
    boundaryMap,
    hierarchy,
    localizationMap
  );
  logger.info(
    "Initiated the localisation message creation for the uploaded boundary"
  );
  const frenchLocalizationMap = extractFrenchOrPortugeseLocalizationMap(boundaryDataForSheet, true, false, localizationMap);
  const portugeseLocalizationMap = extractFrenchOrPortugeseLocalizationMap(boundaryDataForSheet, false, true, localizationMap);
  await transformAndCreateLocalisation(frenchLocalizationMap, request, true, false);
  await transformAndCreateLocalisation(portugeseLocalizationMap, request, false, true);
  await transformAndCreateLocalisation(boundaryMap, request, false, false);
  const modifiedHierarchy = hierarchy.map((ele) =>
    `${hierarchyType}_${ele}`.toUpperCase()
  );
  var headers = [...modifiedHierarchy, config?.boundary?.boundaryCode];
  const data = prepareDataForExcel(
    boundaryDataForSheet,
    hierarchy,
    boundaryMap,
    localizationMap
  );
  if (type === "boundaryManagement") {
    headers = [
      ...headers,
      getLocalizedName("HCM_ADMIN_CONSOLE_FRENCH_LOCALIZATION_MESSAGE", localizationMap),
      getLocalizedName("HCM_ADMIN_CONSOLE_FRENCH_LOCALIZATION_MESSAGE", localizationMap),
      getLocalizedName("HCM_ADMIN_CONSOLE_LAT", localizationMap),
      getLocalizedName("HCM_ADMIN_CONSOLE_LONG", localizationMap)
    ];
    data.forEach((row: any[], index: string | number) => {
      if (latLongData.length > index) {
        row.push(latLongData[index][0], latLongData[index][1]);
      }
    });
  }
  const localizedHeaders = getLocalizedHeaders(headers, localizationMap);
  const boundarySheetData: any = await createExcelSheet(data, localizedHeaders);
  const workbook = getNewExcelWorkbook();
  const boundarySheet = workbook.addWorksheet(localizedBoundaryTab);
  addDataToSheet(request, boundarySheet, boundarySheetData, "93C47D", 40, true);
  const boundaryFileDetails: any = await createAndUploadFile(workbook, request);
  request.body.ResourceDetails.processedFileStoreId =
    boundaryFileDetails?.[0]?.fileStoreId;
};

function updateBoundaryData(boundaryData: any[], hierarchy: any[]): any[] {
  const map: Map<string, string> = new Map();
  const count: Map<string, number> = new Map();
  boundaryData = boundaryData.map(row =>
    Object.fromEntries(
      Object.entries(row).map(([key, value]) =>
        [key, typeof value === "string" ? value.trim() : value]
      )
    )
  );

  boundaryData.forEach((row) => {
    const keys = Object.keys(row).filter((key) => hierarchy.includes(key));
    keys.forEach((key, index) => {
      if (index > 0) {
        const element = row[key];
        const previousKey = keys[index - 1];
        const previousElement = row[keys[index - 1]];
        const previousElementKey = `${previousKey}:${previousElement}`;
        const elementKey = `${key}:${element}`;

        if (!map.has(elementKey)) {
          map.set(elementKey, previousElementKey);
          count.set(elementKey, 1);
        } else {
          const currentCount = count.get(elementKey)!;
          if (map.get(elementKey) !== previousElementKey) {
            map.set(elementKey, previousElementKey);
            count.set(elementKey, currentCount + 1);
          }
          const uniqueCount = count.get(elementKey)!;
          const uniqueElement =
            uniqueCount > 1
              ? `${element}_${key.length > 3 ? key.slice(0, 3).toLowerCase() : key.toLowerCase()}_${(uniqueCount - 1).toString().padStart(2, "0")}`
              : `${element}`;
          row[key] = uniqueElement;
        }
      }
    });
  });
  return boundaryData;
}

// function modifyBoundaryDataHeaders(
//   boundaryData: any[],
//   hierarchy: any[],
//   localizationMap?: any
// ) {
//   const updatedData = boundaryData.map((obj: any) => {
//     const updatedObj: { [key: string]: string | undefined } = {}; // Updated object with modified keys

//     let hierarchyIndex = 0; // Track the index of the hierarchy array

//     for (const key in obj) {
//       if (
//         key != getLocalizedName(config?.boundary?.boundaryCode, localizationMap)
//       ) {
//         if (Object.prototype.hasOwnProperty.call(obj, key)) {
//           const hierarchyKey = hierarchy[hierarchyIndex]; // Get the key from the hierarchy array
//           updatedObj[hierarchyKey] = obj[key]; // Map the key to the updated object
//           hierarchyIndex++; // Move to the next key in the hierarchy array
//         }
//       } else {
//         updatedObj[key] = obj[key];
//       }
//     }

//     return updatedObj;
//   });
//   return updatedData;
// }

function modifyChildParentMap(
  childParentMap: Map<any, any>,
  boundaryMap: Map<any, any>
): Map<string, string | null> {
  const modifiedMap: Map<string, string | null> = new Map();

  // Iterate over each entry in childParentMap
  childParentMap.forEach((value, key) => {
    // Get the modified key and value from boundaryMap
    const modifiedKey = findMapValue(boundaryMap, key) || null;
    const modifiedValue = value ? findMapValue(boundaryMap, value) : null;

    // Set the modified key-value pair in modifiedMap
    modifiedMap.set(modifiedKey, modifiedValue);
  });

  return modifiedMap;
}

async function convertSheetToDifferentTabs(
  request: any,
  boundaryData: any,
  differentTabsBasedOnLevel: any,
  localizationMap?: any,
  fileUrl?: any
) {
  // create different tabs on the level of hierarchy we want to
  const updatedWorkbook = await appendSheetsToWorkbook(
    request,
    boundaryData,
    differentTabsBasedOnLevel,
    localizationMap,
    fileUrl
  );
  // upload the excel and generate file store id
  const boundaryDetails = await createAndUploadFile(updatedWorkbook, request);
  return boundaryDetails;
}

async function getBoundaryDataAfterGeneration(
  result: any,
  request: any,
  localizationMap?: any
) {
  const fileStoreId = result[0].fileStoreId;
  const fileResponse = await httpRequest(
    config.host.filestore + config.paths.filestore + "/url",
    {},
    { tenantId: request?.query?.tenantId, fileStoreIds: fileStoreId },
    "get"
  );
  if (!fileResponse?.fileStoreIds?.[0]?.url) {
    throwError("FILE", 400, "INVALID_FILE");
  }
  const boundaryData = await getSheetData(
    fileResponse?.fileStoreIds?.[0]?.url,
    getBoundaryTabName(),
    false,
    undefined,
    localizationMap
  );
  return boundaryData;
}

function getLocalizedName(
  expectedName: string,
  localizationMap?: { [key: string]: string }
) {
  if (!localizationMap || !(expectedName in localizationMap)) {
    return expectedName;
  }
  const localizedName = localizationMap[expectedName];
  return localizedName;
}

function getLocalizedNameOnlyIfMessagePresent(
  expectedName: string,
  localizationMap?: { [key: string]: string }
) {
  if (!localizationMap || !(expectedName in localizationMap)) {
    return '';
  }
  const localizedName = localizationMap[expectedName];
  return localizedName;
}

async function getTargetBoundariesRelatedToCampaignId(
  request: any,
  localizationMap?: any
) {
  let CampaignDetailsNew: any;
  if (request?.body?.ResourceDetails?.campaignId) {
    // const searchBody = {
    //   RequestInfo: request?.body?.RequestInfo,
    const CampaignDetails = {
      ids: [request?.body?.ResourceDetails?.campaignId],
      tenantId: request?.body?.ResourceDetails?.tenantId,
    }
    // const req: any = replicateRequest(request, searchBody);
    const response = await searchProjectTypeCampaignService(CampaignDetails);
    if (response?.CampaignDetails?.[0]) {
      CampaignDetailsNew = response?.CampaignDetails?.[0];
      await addBoundariesForData(request, CampaignDetailsNew);
    } else {
      throwError(
        "CAMPAIGN",
        400,
        "CAMPAIGN_NOT_FOUND",
        "Campaign not found while Validating sheet boundaries"
      );
    }
  }
  return CampaignDetailsNew?.boundaries;
}

async function getFiltersFromCampaignSearchResponse(
  request: any,
  responseFromCampaignSearch: any
) {
  const boundaries = await getBoundariesFromCampaignSearchResponse(
    request,
    responseFromCampaignSearch?.CampaignDetails?.[0]
  );
  const boundariesModified = boundaries?.map((ele: any) => ({
    ...ele,
    boundaryType: ele?.type,
  }));
  if (!boundariesModified) {
    logger.info(`no boundaries found so considering the complete hierarchy`);
    return { Filters: null };
  }
  logger.info(`boundaries found for filtering`);
  return { Filters: { boundaries: boundariesModified } };
}

const getConfigurableColumnHeadersBasedOnCampaignType = async (
  request: any,
  localizationMap?: any
) => {
  try {
    const responseFromCampaignSearch = await getCampaignSearchResponse(request);
    const campaignObject = responseFromCampaignSearch?.CampaignDetails?.[0];
    let campaignType = campaignObject?.projectType;
    const isSourceMicroplan = checkIfSourceIsMicroplan(campaignObject);
    campaignType = isSourceMicroplan
      ? `${config?.prefixForMicroplanCampaigns}-${campaignType}`
      : campaignType;
    const isUpdate = request?.body?.parentCampaignObject ? true : false;
    const mdmsResponse = await callMdmsTypeSchema(
      request?.query?.tenantId || request?.body?.ResourceDetails?.tenantId,
      isUpdate,
      request?.query?.type || request?.body?.ResourceDetails?.type,
      campaignType
    );
    if (!mdmsResponse || mdmsResponse?.columns.length === 0) {
      logger.error(
        `Campaign Type ${campaignType} has not any columns configured in schema`
      );
      throwError(
        "COMMON",
        400,
        "SCHEMA_ERROR",
        `Campaign Type ${campaignType} has not any columns configured in schema`
      );
    }
    // Extract columns from the response
    const columnsForGivenCampaignId = mdmsResponse?.columns;

    // Get localized headers based on the column names
    const headerColumnsAfterHierarchy = getLocalizedHeaders(
      columnsForGivenCampaignId,
      localizationMap
    );
    if (
      !headerColumnsAfterHierarchy.includes(
        getLocalizedName(config.boundary.boundaryCode, localizationMap)
      )
    ) {
      logger.error(
        `Column Headers of generated Boundary Template does not have ${getLocalizedName(
          config.boundary.boundaryCode,
          localizationMap
        )} column`
      );
      throwError(
        "COMMON",
        400,
        "VALIDATION_ERROR",
        `Column Headers of generated Boundary Template does not have ${getLocalizedName(
          config.boundary.boundaryCode,
          localizationMap
        )} column`
      );
    }
    return headerColumnsAfterHierarchy;
  } catch (error: any) {
    console.log(error);
    throwError(
      "FILE",
      400,
      "FETCHING_COLUMN_ERROR",
      "Error fetching column Headers From Schema (either boundary code column not found or given  Campaign Type not found in schema) Check logs"
    );
  }
};

async function getFinalValidHeadersForTargetSheetAsPerCampaignType(
  request: any,
  hierarchy: any[],
  differentTabsBasedOnLevel: any,
  localizationMap?: any
) {
  const modifiedHierarchy = hierarchy.map((ele) =>
    `${request?.body?.ResourceDetails?.hierarchyType}_${ele}`.toUpperCase()
  );
  const localizedHierarchy = getLocalizedHeaders(
    modifiedHierarchy,
    localizationMap
  );
  const index = localizedHierarchy.indexOf(
    getLocalizedName(differentTabsBasedOnLevel, localizationMap)
  );
  const responseFromCampaignSearch = await getCampaignSearchResponse(request);
  const campaignObject = responseFromCampaignSearch?.CampaignDetails?.[0];
  const isSourceMicroplan = checkIfSourceIsMicroplan(campaignObject);
  var expectedHeadersForTargetSheetUptoHierarchy: any;
  if (isSourceMicroplan) {
    expectedHeadersForTargetSheetUptoHierarchy = localizedHierarchy;
  } else {
    expectedHeadersForTargetSheetUptoHierarchy =
      index !== -1
        ? localizedHierarchy.slice(index)
        : throwError(
          "COMMON",
          400,
          "VALIDATION_ERROR",
          `${differentTabsBasedOnLevel} level not present in the hierarchy`
        );
  }
  const columnFromSchemaOfTargetTemplate = await generateDynamicTargetHeaders(
    request,
    campaignObject,
    localizationMap
  );
  const localizedcolumnFromSchemaOfTargetTemplate = getLocalizedHeaders(
    columnFromSchemaOfTargetTemplate,
    localizationMap
  );
  let updatedLocalizedcolumnFromSchemaOfTargetTemplate =
    localizedcolumnFromSchemaOfTargetTemplate;
  if (request?.body?.parentCampaignObject) {
    updatedLocalizedcolumnFromSchemaOfTargetTemplate =
      localizedcolumnFromSchemaOfTargetTemplate
        .map((item: any) => `${item}(OLD)`)
        .concat(localizedcolumnFromSchemaOfTargetTemplate);
  }
  const expectedHeadersForTargetSheet = [
    ...expectedHeadersForTargetSheetUptoHierarchy,
    getLocalizedName(config?.boundary?.boundaryCode, localizationMap),
    ...updatedLocalizedcolumnFromSchemaOfTargetTemplate,
  ];
  return expectedHeadersForTargetSheet;
}

async function getDifferentTabGeneratedBasedOnConfig(
  request: any,
  boundaryDataGeneratedBeforeDifferentTabSeparation: any,
  localizationMap?: any,
  fileUrl?: any
) {
  var boundaryDataGeneratedAfterDifferentTabSeparation: any =
    boundaryDataGeneratedBeforeDifferentTabSeparation;
  const boundaryData = await getBoundaryDataAfterGeneration(
    boundaryDataGeneratedBeforeDifferentTabSeparation,
    request,
    localizationMap
  );
  let differentTabsBasedOnLevel = await getBoundaryOnWhichWeSplit(
    request?.query?.campaignId,
    request?.query?.tenantId
  );
  differentTabsBasedOnLevel = getLocalizedName(
    `${request?.query?.hierarchyType}_${differentTabsBasedOnLevel}`.toUpperCase(),
    localizationMap
  );
  logger.info(
    `Boundaries are seperated based on hierarchy type ${differentTabsBasedOnLevel}`
  );
  const isKeyOfThatTypePresent = boundaryData.some((data: any) =>
    data.hasOwnProperty(differentTabsBasedOnLevel)
  );
  const boundaryTypeOnWhichWeSplit = boundaryData.filter(
    (data: any) => data[differentTabsBasedOnLevel]
  );
  if (
    isKeyOfThatTypePresent &&
    boundaryTypeOnWhichWeSplit.length >=
    parseInt(config?.boundary?.numberOfBoundaryDataOnWhichWeSplit)
  ) {
    logger.info(
      `sinces the conditions are matched boundaries are getting splitted into different tabs`
    );
    boundaryDataGeneratedAfterDifferentTabSeparation =
      await convertSheetToDifferentTabs(
        request,
        boundaryData,
        differentTabsBasedOnLevel,
        localizationMap,
        fileUrl
      );
  }
  return boundaryDataGeneratedAfterDifferentTabSeparation;
}

async function getBoundaryOnWhichWeSplit(campaignId: string, tenantId: string) {
  const campaignDetailsResponse: any = await searchProjectTypeCampaignService({ tenantId, ids: [campaignId] });
  const campaignDetails: any = campaignDetailsResponse?.CampaignDetails?.[0];
  const MdmsCriteria: any = {
    tenantId: tenantId,
    schemaCode: `${config.values.moduleName}.${config.masterNameForSplitBoundariesOn}`,
    filters: {
      hierarchy: campaignDetails?.hierarchyType,
    },
  };
  const mdmsResponse: any = await searchMDMSDataViaV2Api(MdmsCriteria);
  if (!Array.isArray(mdmsResponse?.mdms) || mdmsResponse.mdms.length === 0) {
    throwError("MDMS", 500, "MDMS_DATA_NOT_FOUND_ERROR", `${campaignDetails?.hierarchyType} hierarchy not configured in mdms data 
                ${config.values.moduleName}.${config.masterNameForSplitBoundariesOn}`)
  }
  return mdmsResponse?.mdms?.[0]?.data?.splitBoundariesOn;
}

function checkIfSourceIsMicroplan(objectWithAdditionalDetails: any): boolean {
  return objectWithAdditionalDetails?.additionalDetails?.source === "microplan";
}

function createIdRequests(employees: any[]): any[] {
  if (employees && Array.isArray(employees) && employees.length > 0) {
    const { tenantId } = employees[0]; // Assuming all employees have the same tenantId
    return Array.from({ length: employees.length }, () => ({
      tenantId: tenantId,
      idName: config?.values?.idgen?.idNameForUserNameGeneration,
      format: config?.values?.idgen?.formatForUserName,
    }));
  } else {
    return [];
  }
}

async function createUniqueUserNameViaIdGen(idRequests: any) {
  const idgenurl = config?.host?.idGenHost + config?.paths?.idGen;
  try {
    // Make HTTP request to ID generation service
    const result = await httpRequest(
      idgenurl,
      { RequestInfo: defaultRequestInfo?.RequestInfo, idRequests },
      undefined,
      undefined,
      undefined,
      undefined
    );

    // Return null if ID generation fails
    return result;
  } catch (error: any) {
    // Log the error
    logger.error(`Error during ID generation: ${error.message}`);

    // Throw a custom error
    throwError(
      "ID_GENERATION",
      500,
      "ID_GENERATION_FAILED",
      `Error occurred while generating ID: ${error.message}`
    );
  }
}

async function processFetchMicroPlan(request: any) {
  try {
    logger.info("Waiting for 1 second for templates to get generated...");
    await new Promise((resolve) => setTimeout(resolve, 1000));

    logger.info("Started processing fetch microplan");

    const { tenantId } = request.body.MicroplanDetails;
    const localizationMap = await getLocalizedMessagesHandler(request, tenantId);
    const resources: any = request?.body?.CampaignDetails?.resources || [];
    const filteredResources = resources.filter(
      (obj: any) => obj?.filestoreId && obj?.resourceId
    );

    logger.info(`Filtered resources with valid IDs: ${filteredResources?.length}`);
    logger.debug(`Filtered resources: ${getFormattedStringForDebug(filteredResources)}`);

    const fetchOperations: Promise<void>[] = [];

    // Add fetch operations conditionally
    if (filteredResources.length === 0 || filteredResources.every((obj: any) => obj?.type !== "facility")) {
      fetchOperations.push(fetchFacilityData(request, localizationMap));
    }
    if (filteredResources.length === 0 || filteredResources.every((obj: any) => obj?.type !== "boundaryWithTarget")) {
      fetchOperations.push(fetchTargetData(request, localizationMap));
    }
    if (filteredResources.length === 0 || filteredResources.every((obj: any) => obj?.type !== "user")) {
      fetchOperations.push(fetchUserData(request, localizationMap));
    }

    // Run all fetch operations in parallel
    await Promise.all(fetchOperations);

    logger.info("Updating campaign object after successful fetch microplan...");
    await updateCampaignAfterSearch(request, "MICROPLAN_COMPLETED");

    logger.info("Completed processing fetch microplan");
  } catch (error: any) {
    logger.error(`Error during microplan fetch: ${error.message}`);
    await updateCampaignAfterSearch(request, "MICROPLAN_FETCH_FAILED");
  }
}


async function updateCampaignAfterSearch(request: any, source = "MICROPLAN_FETCHING") {
  logger.info("search campaign with id ")
  const { tenantId, campaignId } = request.body.MicroplanDetails;
  const campaignDetails = {
    tenantId: tenantId,
    ids: [campaignId]
  }
  const searchedCampaignResponse = await searchProjectTypeCampaignService(campaignDetails)
  const searchedCamapignObject = searchedCampaignResponse?.CampaignDetails;
  if (Array.isArray(searchedCamapignObject) && searchedCamapignObject.length > 0) {
    const newRequestBody = {
      RequestInfo: request.body.RequestInfo, // Retain the original RequestInfo
      CampaignDetails: searchedCamapignObject?.[0] // campaigndetails from search response
    };
    const req: any = replicateRequest(request, newRequestBody)
    logger.info("Updating the received campaign object, source & its key");
    if (!req.body.CampaignDetails.additionalDetails) {
      req.body.CampaignDetails.additionalDetails = {};
    }
    req.body.CampaignDetails.additionalDetails.activity = source;
    (!req.body?.CampaignDetails?.additionalDetails?.["disease"]) && (req.body.CampaignDetails.additionalDetails["disease"] = "MALARIA"),
      (!req.body?.CampaignDetails?.additionalDetails?.["beneficiaryType"]) && (req.body.CampaignDetails.additionalDetails["beneficiaryType"] =
        "INDIVIDUAL");
    req.body.CampaignDetails.additionalDetails["key"] = 1;
    logger.debug(
      `updated object with new source , disease & beneficiarytype ${getFormattedStringForDebug(req.body.CampaignDetails)}`
    );
    await updateProjectTypeCampaignService(req);
    logger.info("Updated the received campaign object");
  } else {
    throwError("CAMPAIGN", 500, "CAMPAIGN_SEARCH_ERROR", "Error in campaign search");
  }
}

export function getBoundaryCodeAndBoundaryTypeMapping(boundaries: any, currentMapping: any = {}) {
  for (const boundary of boundaries) {
    currentMapping[boundary.code] = boundary.boundaryType;
    if (boundary.children?.length > 0) {
      getBoundaryCodeAndBoundaryTypeMapping(boundary.children, currentMapping);
    }
  }
  return currentMapping;
}

export function validateUsernamesFormat(data: any[], localizationMap: any) {
  if (!data?.length) return [];

  const userSheet = getLocalizedName(createAndSearch?.user?.parseArrayConfig?.sheetName, localizationMap);
  const errors: any[] = [];
  const userNameColumn = getLocalizedName("UserName", localizationMap);

  const usernameMap = new Map<string, number[]>(); // username -> rowNumbers[]

  data.forEach((item: any) => {
    const rowNumber = item?.["!row#number!"];
    const username = item[userNameColumn];

    // Check format validity
    const isValid = /^[A-Za-z][A-Za-z0-9-]*$/.test(username);
    if (username && !isValid) {
      errors.push({
        status: "INVALID",
        rowNumber,
        sheetName: userSheet,
        errorDetails: "Invalid username format User name can only be alphanumeric",
      });
    }

    // Collect row numbers for duplicates
    if (username) {
      if (!usernameMap.has(username)) {
        usernameMap.set(username, []);
      }
      usernameMap.get(username)!.push(rowNumber);
    }
  });

  // Now identify duplicates and push those to errors
  usernameMap.forEach((rows, username) => {
    if (rows.length > 1) {
      rows.forEach((rowNumber) => {
        errors.push({
          status: "INVALID",
          rowNumber,
          sheetName: userSheet,
          errorDetails: `Duplicate username '${username}'`,
        });
      });
    }
  });

  return errors;
}

export function getAllColumnsFromSchema(schema: any) {
  const properties = schema?.properties;
  const columns = Object.keys(properties);
  for (const header of Object.keys(properties)) {
    if (properties?.[header]?.multiSelectDetails) {
      const maxColumns = properties?.[header]?.multiSelectDetails?.maxSelections;
      for (let i = 1; i <= maxColumns; i++) {
        columns.push(`${header}_MULTISELECT_${i}`);
      }
    }
  }

  return columns;
}

export async function isCampaignIdOfMicroplan(tenantId: string, campaignId: string) {
  try {
    const tableName = getTableName(config.DB_CONFIG.DB_CAMPAIGN_DETAILS_TABLE_NAME, tenantId);
    const query = `SELECT id FROM ${tableName} WHERE id = $1 and tenantId = $2 and additionalDetails->>'source' = 'microplan'`;
    const result = await executeQuery(query, [campaignId, tenantId]);
    return Array.isArray(result?.rows) && result?.rows?.length > 0;
  } catch (e) {
    console.log(e);
    logger.error(`Error checking if campaign id ${campaignId} is of microplan: ${e}`);
    throwError("COMMON", 500, "INTERNAL_SERVER_ERROR", "Error checking if campaign id is of microplan");
    return false;
  }
}

export {
  generateProcessedFileAndPersist,
  convertToTypeData,
  getChildParentMap,
  addBoundaryCodeToData,
  prepareDataForExcel,
  extractCodesFromBoundaryRelationshipResponse,
  searchProjectCampaignResourcData,
  processDataSearchRequest,
  getCodeMappingsOfExistingBoundaryCodes,
  processBasedOnAction,
  appendSheetsToWorkbook,
  generateFilteredBoundaryData,
  generateHierarchy,
  createBoundaryMap,
  autoGenerateBoundaryCodes,
  convertSheetToDifferentTabs,
  getBoundaryDataAfterGeneration,
  boundaryBulkUpload,
  enrichAndPersistCampaignWithError,
  getLocalizedName,
  reorderBoundaries,
  reorderBoundariesOfDataAndValidate,
  getTargetBoundariesRelatedToCampaignId,
  getFiltersFromCampaignSearchResponse,
  getConfigurableColumnHeadersBasedOnCampaignType,
  getFinalValidHeadersForTargetSheetAsPerCampaignType,
  getDifferentTabGeneratedBasedOnConfig,
  checkIfSourceIsMicroplan,
  getBoundaryOnWhichWeSplit,
  createIdRequests,
  createUniqueUserNameViaIdGen,
  getRootBoundaryCode,
  boundaryGeometryManagement,
  getResourceDetails,
  enrichInnerCampaignDetails,
  processFetchMicroPlan,
  updateCampaignAfterSearch,
  processBoundary,
  getLocalizedNameOnlyIfMessagePresent
};
